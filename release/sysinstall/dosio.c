begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996 Robert Nordier  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"dosio.h"
end_include

begin_define
define|#
directive|define
name|SECSIZ
value|512
end_define

begin_comment
comment|/* sector size */
end_comment

begin_define
define|#
directive|define
name|SSHIFT
value|9
end_define

begin_comment
comment|/* SECSIZ shift */
end_comment

begin_define
define|#
directive|define
name|DEPSEC
value|16
end_define

begin_comment
comment|/* directory entries per sector */
end_comment

begin_define
define|#
directive|define
name|DSHIFT
value|4
end_define

begin_comment
comment|/* DEPSEC shift */
end_comment

begin_define
define|#
directive|define
name|NFATS
value|2
end_define

begin_comment
comment|/* number of FATs */
end_comment

begin_define
define|#
directive|define
name|DENMSZ
value|8
end_define

begin_comment
comment|/* DE name size */
end_comment

begin_define
define|#
directive|define
name|DEXTSZ
value|3
end_define

begin_comment
comment|/* DE extension size */
end_comment

begin_define
define|#
directive|define
name|DENXSZ
value|11
end_define

begin_comment
comment|/* DE name + extension size */
end_comment

begin_define
define|#
directive|define
name|LOCLUS
value|2
end_define

begin_comment
comment|/* lowest cluster number */
end_comment

begin_comment
comment|/* DOS "BIOS Parameter Block" */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|secsiz
index|[
literal|2
index|]
decl_stmt|;
comment|/* sector size */
name|u_char
name|spc
decl_stmt|;
comment|/* sectors per cluster */
name|u_char
name|ressec
index|[
literal|2
index|]
decl_stmt|;
comment|/* reserved sectors */
name|u_char
name|fats
decl_stmt|;
comment|/* FATs */
name|u_char
name|dirents
index|[
literal|2
index|]
decl_stmt|;
comment|/* root directory entries */
name|u_char
name|secs
index|[
literal|2
index|]
decl_stmt|;
comment|/* total sectors */
name|u_char
name|media
decl_stmt|;
comment|/* media descriptor */
name|u_char
name|spf
index|[
literal|2
index|]
decl_stmt|;
comment|/* sectors per FAT */
name|u_char
name|spt
index|[
literal|2
index|]
decl_stmt|;
comment|/* sectors per track */
name|u_char
name|heads
index|[
literal|2
index|]
decl_stmt|;
comment|/* drive heads */
name|u_char
name|hidsec
index|[
literal|4
index|]
decl_stmt|;
comment|/* hidden sectors */
name|u_char
name|lsecs
index|[
literal|4
index|]
decl_stmt|;
comment|/* huge sectors */
block|}
name|DOS_BPB
typedef|;
end_typedef

begin_comment
comment|/* Fixed portion of DOS boot sector */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|jmp
index|[
literal|3
index|]
decl_stmt|;
comment|/* usually 80x86 'jmp' opcode */
name|u_char
name|oem
index|[
literal|8
index|]
decl_stmt|;
comment|/* OEM name and version */
name|DOS_BPB
name|bpb
decl_stmt|;
comment|/* BPB */
name|u_char
name|drive
decl_stmt|;
comment|/* drive number */
name|u_char
name|reserved
decl_stmt|;
comment|/* reserved */
name|u_char
name|extsig
decl_stmt|;
comment|/* extended boot signature */
name|u_char
name|volid
index|[
literal|4
index|]
decl_stmt|;
comment|/* volume ID */
name|u_char
name|label
index|[
literal|11
index|]
decl_stmt|;
comment|/* volume label */
name|u_char
name|fstype
index|[
literal|8
index|]
decl_stmt|;
comment|/* file system type */
block|}
name|DOS_BS
typedef|;
end_typedef

begin_comment
comment|/* Supply missing "." and ".." root directory entries */
end_comment

begin_decl_stmt
specifier|static
name|DOS_DE
name|dot
index|[
literal|2
index|]
init|=
block|{
block|{
literal|".       "
block|,
literal|"   "
block|,
name|FA_DIR
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x21
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
literal|"..      "
block|,
literal|"   "
block|,
name|FA_DIR
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x21
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O error handler address */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|dos_ioerr
function_decl|)
parameter_list|(
name|int
name|op
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* The usual conversion macros to avoid multiplication and division */
end_comment

begin_define
define|#
directive|define
name|bytsec
parameter_list|(
name|n
parameter_list|)
value|((n)>> (SSHIFT))
end_define

begin_define
define|#
directive|define
name|secbyt
parameter_list|(
name|s
parameter_list|)
value|((u_long)(s)<< (SSHIFT))
end_define

begin_define
define|#
directive|define
name|entsec
parameter_list|(
name|e
parameter_list|)
value|((e)>> (DSHIFT))
end_define

begin_define
define|#
directive|define
name|bytblk
parameter_list|(
name|fs
parameter_list|,
name|n
parameter_list|)
value|((n)>> (fs)->bshift)
end_define

begin_define
define|#
directive|define
name|blkbyt
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|((u_long)(b)<< (fs)->bshift)
end_define

begin_define
define|#
directive|define
name|blksec
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|((u_long)(b)<< ((fs)->bshift - (SSHIFT)))
end_define

begin_comment
comment|/* Convert cluster number to offset within filesystem */
end_comment

begin_define
define|#
directive|define
name|blkoff
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|secbyt((fs)->lsndta) + blkbyt(fs, (b) - (LOCLUS))
end_define

begin_comment
comment|/* Convert cluster number to logical sector number */
end_comment

begin_define
define|#
directive|define
name|blklsn
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|((fs)->lsndta + blksec(fs, (b) - (LOCLUS)))
end_define

begin_comment
comment|/* Convert cluster number to offset within FAT */
end_comment

begin_define
define|#
directive|define
name|fatoff
parameter_list|(
name|fat12
parameter_list|,
name|c
parameter_list|)
value|((u_long)(c) + ((fat12) ? (c)>> 1 : (c)))
end_define

begin_comment
comment|/* Does cluster number reference a valid data cluster? */
end_comment

begin_define
define|#
directive|define
name|okclus
parameter_list|(
name|fs
parameter_list|,
name|c
parameter_list|)
value|((c)>= (LOCLUS)&& (c)<= (fs)->xclus)
end_define

begin_comment
comment|/* Return on error */
end_comment

begin_define
define|#
directive|define
name|RETERR
parameter_list|(
name|err
parameter_list|)
value|{  \    errno = err;        \    return -1;          \ }
end_define

begin_function_decl
specifier|static
name|int
name|dosunmount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dosstat
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_DE
modifier|*
name|de
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parsebs
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_BS
modifier|*
name|bs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|namede
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|DOS_DE
modifier|*
modifier|*
name|dep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DOS_DE
modifier|*
name|lookup
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|unsigned
name|c
parameter_list|,
specifier|const
name|u_char
modifier|*
name|nx
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|fsize
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_DE
modifier|*
name|de
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|fatget
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_short
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fatend
parameter_list|(
name|int
name|fat12
parameter_list|,
name|u_short
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fatcnt
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_short
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ioread
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ioget
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_long
name|lsec
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|nsec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|nxname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|endptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sepchar
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wildchar
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doschar
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Mount DOS filesystem  */
end_comment

begin_function
name|int
name|dos_mount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|)
block|{
name|char
name|buf
index|[
name|SECSIZ
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|memset
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DOS_FS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|RETERR
argument_list|(
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|err
operator|=
name|parsebs
argument_list|(
name|fs
argument_list|,
operator|(
name|DOS_BS
operator|*
operator|)
name|buf
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fat
operator|=
name|malloc
argument_list|(
name|secbyt
argument_list|(
name|fs
operator|->
name|spf
argument_list|)
argument_list|)
operator|)
condition|)
name|err
operator|=
name|errno
expr_stmt|;
else|else
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
name|fs
operator|->
name|lsnfat
argument_list|,
name|fs
operator|->
name|fat
argument_list|,
name|fs
operator|->
name|spf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dosunmount
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|fs
operator|->
name|bsize
operator|=
name|secbyt
argument_list|(
name|fs
operator|->
name|spc
argument_list|)
expr_stmt|;
name|fs
operator|->
name|bshift
operator|=
name|ffs
argument_list|(
name|fs
operator|->
name|bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount mounted filesystem  */
end_comment

begin_function
name|int
name|dos_unmount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|links
condition|)
name|RETERR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dosunmount
argument_list|(
name|fs
argument_list|)
operator|)
condition|)
name|RETERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Common code shared by dos_mount() and dos_unmount()  */
end_comment

begin_function
specifier|static
name|int
name|dosunmount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|)
block|{
if|if
condition|(
name|fs
operator|->
name|fat
condition|)
name|free
argument_list|(
name|fs
operator|->
name|fat
argument_list|)
expr_stmt|;
return|return
name|close
argument_list|(
name|fs
operator|->
name|fd
argument_list|)
condition|?
name|errno
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Determine free data space in filesystem (in bytes)  */
end_comment

begin_function
name|u_long
name|dos_free
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|,
name|c
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|LOCLUS
init|;
name|c
operator|<=
name|fs
operator|->
name|xclus
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|fatget
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|blkbyt
argument_list|(
name|fs
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close open file  */
end_comment

begin_function
name|int
name|dos_close
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|DOS_FILE
modifier|*
name|f
init|=
name|v
decl_stmt|;
name|f
operator|->
name|fs
operator|->
name|links
operator|--
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reposition with file  */
end_comment

begin_function
name|fpos_t
name|dos_seek
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|fpos_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|;
name|u_long
name|size
decl_stmt|;
name|DOS_FILE
modifier|*
name|f
init|=
name|v
decl_stmt|;
name|size
operator|=
name|cv4
argument_list|(
name|f
operator|->
name|de
operator|.
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|off
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|off
operator|=
name|f
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|off
operator|=
name|size
expr_stmt|;
break|break;
default|default:
name|RETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|off
operator|>
name|size
condition|)
name|RETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|f
operator|->
name|offset
operator|=
name|off
expr_stmt|;
name|f
operator|->
name|c
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read from file  */
end_comment

begin_function
name|int
name|dos_read
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|off_t
name|size
decl_stmt|;
name|u_long
name|off
decl_stmt|,
name|cnt
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|clus
decl_stmt|,
name|c
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DOS_FILE
modifier|*
name|f
init|=
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|fsize
argument_list|(
name|f
operator|->
name|fs
argument_list|,
operator|&
name|f
operator|->
name|de
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|RETERR
argument_list|(
name|EBADFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
operator|(
name|n
operator|=
name|size
operator|-
name|f
operator|->
name|offset
operator|)
condition|)
name|nbytes
operator|=
name|n
expr_stmt|;
name|off
operator|=
name|f
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|clus
operator|=
name|cv2
argument_list|(
name|f
operator|->
name|de
operator|.
name|clus
argument_list|)
operator|)
condition|)
name|off
operator|&=
name|f
operator|->
name|fs
operator|->
name|bsize
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|f
operator|->
name|c
expr_stmt|;
name|cnt
operator|=
name|nbytes
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|clus
operator|)
condition|)
name|n
operator|=
name|bytblk
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|f
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|off
condition|)
name|n
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|c
operator|=
name|fatget
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okclus
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|c
argument_list|)
condition|)
name|RETERR
argument_list|(
name|EBADFS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clus
operator|||
operator|(
name|n
operator|=
name|f
operator|->
name|fs
operator|->
name|bsize
operator|-
name|off
operator|)
operator|>
name|cnt
condition|)
name|n
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ioread
argument_list|(
name|f
operator|->
name|fs
operator|->
name|fd
argument_list|,
operator|(
name|c
condition|?
name|blkoff
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|c
argument_list|)
else|:
name|secbyt
argument_list|(
name|f
operator|->
name|fs
operator|->
name|lsndir
argument_list|)
operator|)
operator|+
name|off
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|)
condition|)
name|RETERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|f
operator|->
name|offset
operator|+=
name|n
expr_stmt|;
name|f
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
name|n
expr_stmt|;
name|cnt
operator|-=
name|n
expr_stmt|;
block|}
return|return
name|nbytes
return|;
block|}
end_function

begin_comment
comment|/*  * Get file status   */
end_comment

begin_function
name|int
name|dos_stat
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|DOS_DE
modifier|*
name|de
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|namede
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|||
operator|(
name|err
operator|=
name|dosstat
argument_list|(
name|fs
argument_list|,
name|de
argument_list|,
name|sb
argument_list|)
operator|)
condition|)
name|RETERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get file status of open file  */
end_comment

begin_function
name|int
name|dos_fstat
parameter_list|(
name|DOS_FILE
modifier|*
name|f
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dosstat
argument_list|(
name|f
operator|->
name|fs
argument_list|,
operator|&
name|f
operator|->
name|de
argument_list|,
name|sb
argument_list|)
operator|)
condition|)
name|RETERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * File status primitive  */
end_comment

begin_function
specifier|static
name|int
name|dosstat
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_DE
modifier|*
name|de
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|memset
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_mode
operator|=
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
condition|?
name|S_IFDIR
operator||
literal|0777
else|:
name|S_IFREG
operator||
literal|0666
expr_stmt|;
if|if
condition|(
name|de
operator|->
name|attr
operator|&
name|FA_RDONLY
condition|)
name|sb
operator|->
name|st_mode
operator|&=
operator|~
literal|0222
expr_stmt|;
if|if
condition|(
name|de
operator|->
name|attr
operator|&
name|FA_HIDDEN
condition|)
name|sb
operator|->
name|st_mode
operator|&=
operator|~
literal|0007
expr_stmt|;
if|if
condition|(
name|de
operator|->
name|attr
operator|&
name|FA_SYSTEM
condition|)
name|sb
operator|->
name|st_mode
operator|&=
operator|~
literal|0077
expr_stmt|;
name|sb
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|dos_cvtime
argument_list|(
operator|&
name|sb
operator|->
name|st_atime
argument_list|,
name|cv2
argument_list|(
name|de
operator|->
name|date
argument_list|)
argument_list|,
name|cv2
argument_list|(
name|de
operator|->
name|time
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_mtime
operator|=
name|sb
operator|->
name|st_atime
expr_stmt|;
name|sb
operator|->
name|st_ctime
operator|=
name|sb
operator|->
name|st_atime
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|->
name|st_size
operator|=
name|fsize
argument_list|(
name|fs
argument_list|,
name|de
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|EBADFS
return|;
if|if
condition|(
operator|!
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
operator|||
name|cv2
argument_list|(
name|de
operator|->
name|clus
argument_list|)
condition|)
name|sb
operator|->
name|st_blocks
operator|=
name|bytblk
argument_list|(
name|fs
argument_list|,
name|sb
operator|->
name|st_size
operator|+
name|fs
operator|->
name|bsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|=
name|fs
operator|->
name|bsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from DOS date and time  */
end_comment

begin_function
name|void
name|dos_cvtime
parameter_list|(
name|time_t
modifier|*
name|timer
parameter_list|,
name|u_short
name|ddate
parameter_list|,
name|u_short
name|dtime
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
operator|(
name|dtime
operator|&
literal|0x1f
operator|)
operator|<<
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|dtime
operator|>>
literal|5
operator|&
literal|0x3f
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|dtime
operator|>>
literal|11
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|ddate
operator|&
literal|0x1f
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|ddate
operator|>>
literal|5
operator|&
literal|0xf
operator|)
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
literal|80
operator|+
operator|(
name|ddate
operator|>>
literal|9
operator|)
expr_stmt|;
operator|*
name|timer
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open DOS file  */
end_comment

begin_function
name|FILE
modifier|*
name|dos_open
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|DOS_DE
modifier|*
name|de
decl_stmt|;
name|DOS_FILE
modifier|*
name|f
decl_stmt|;
name|u_long
name|size
decl_stmt|;
name|u_int
name|clus
decl_stmt|;
name|int
name|err
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|namede
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
operator|&
name|de
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|clus
operator|=
name|cv2
argument_list|(
name|de
operator|->
name|clus
argument_list|)
expr_stmt|;
name|size
operator|=
name|cv4
argument_list|(
name|de
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clus
operator|&&
operator|(
operator|!
name|okclus
argument_list|(
name|fs
argument_list|,
name|clus
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
operator|&&
operator|!
name|size
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|clus
operator|&&
operator|!
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
operator|&&
name|size
operator|)
condition|)
return|return
name|NULL
return|;
name|f
operator|=
operator|(
name|DOS_FILE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DOS_FILE
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DOS_FILE
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|fs
operator|->
name|links
operator|++
expr_stmt|;
name|f
operator|->
name|de
operator|=
operator|*
name|de
expr_stmt|;
name|fp
operator|=
name|funopen
argument_list|(
name|f
argument_list|,
name|dos_read
argument_list|,
name|NULL
argument_list|,
name|dos_seek
argument_list|,
name|dos_close
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Parse DOS boot sector  */
end_comment

begin_function
specifier|static
name|int
name|parsebs
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_BS
modifier|*
name|bs
parameter_list|)
block|{
name|u_long
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|bs
operator|->
name|jmp
index|[
literal|0
index|]
operator|!=
literal|0xe9
operator|&&
operator|(
name|bs
operator|->
name|jmp
index|[
literal|0
index|]
operator|!=
literal|0xeb
operator|||
name|bs
operator|->
name|jmp
index|[
literal|2
index|]
operator|!=
literal|0x90
operator|)
operator|)
operator|||
name|bs
operator|->
name|bpb
operator|.
name|media
operator|<
literal|0xf0
operator|||
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|secsiz
argument_list|)
operator|!=
name|SECSIZ
operator|||
operator|!
name|bs
operator|->
name|bpb
operator|.
name|spc
operator|||
operator|(
name|bs
operator|->
name|bpb
operator|.
name|spc
operator|^
operator|(
name|bs
operator|->
name|bpb
operator|.
name|spc
operator|-
literal|1
operator|)
operator|)
operator|<
name|bs
operator|->
name|bpb
operator|.
name|spc
condition|)
return|return
name|EINVAL
return|;
name|fs
operator|->
name|spf
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|spf
argument_list|)
expr_stmt|;
name|fs
operator|->
name|dirents
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|dirents
argument_list|)
expr_stmt|;
name|fs
operator|->
name|spc
operator|=
name|bs
operator|->
name|bpb
operator|.
name|spc
expr_stmt|;
name|sc
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|secs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|&&
name|bs
operator|->
name|extsig
operator|==
literal|0x29
condition|)
name|sc
operator|=
name|cv4
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|lsecs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|||
name|bs
operator|->
name|bpb
operator|.
name|fats
operator|!=
name|NFATS
operator|||
name|bs
operator|->
name|bpb
operator|.
name|spc
operator|>
literal|64
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|fs
operator|->
name|dirents
operator|||
name|fs
operator|->
name|dirents
operator|&
operator|(
name|DEPSEC
operator|-
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|fs
operator|->
name|lsnfat
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|ressec
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lsndir
operator|=
name|fs
operator|->
name|lsnfat
operator|+
operator|(
name|u_long
operator|)
name|fs
operator|->
name|spf
operator|*
name|NFATS
expr_stmt|;
name|fs
operator|->
name|lsndta
operator|=
name|fs
operator|->
name|lsndir
operator|+
name|entsec
argument_list|(
name|fs
operator|->
name|dirents
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|lsndta
operator|>
name|sc
operator|||
operator|!
operator|(
name|sc
operator|=
operator|(
name|sc
operator|-
name|fs
operator|->
name|lsndta
operator|)
operator|/
name|fs
operator|->
name|spc
operator|)
operator|||
name|sc
operator|>=
literal|0xfff6
condition|)
return|return
name|EINVAL
return|;
name|fs
operator|->
name|fat12
operator|=
name|sc
operator|<
literal|0xff6
expr_stmt|;
name|fs
operator|->
name|xclus
operator|=
name|sc
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|spf
operator|<
name|bytsec
argument_list|(
name|fatoff
argument_list|(
name|fs
operator|->
name|fat12
argument_list|,
name|fs
operator|->
name|xclus
argument_list|)
operator|+
name|SECSIZ
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|bs
operator|->
name|extsig
operator|==
literal|0x29
condition|)
name|fs
operator|->
name|volid
operator|=
name|cv4
argument_list|(
name|bs
operator|->
name|volid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return directory entry from path  */
end_comment

begin_function
specifier|static
name|int
name|namede
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|DOS_DE
modifier|*
modifier|*
name|dep
parameter_list|)
block|{
name|DOS_DE
modifier|*
name|de
decl_stmt|;
name|u_char
modifier|*
name|nx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|de
operator|=
name|dot
expr_stmt|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|path
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|nx
operator|=
name|nxname
argument_list|(
name|path
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|path
argument_list|)
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
condition|)
return|return
name|ENOTDIR
return|;
if|if
condition|(
operator|!
operator|(
name|de
operator|=
name|lookup
argument_list|(
name|fs
argument_list|,
name|cv2
argument_list|(
name|de
operator|->
name|clus
argument_list|)
argument_list|,
name|nx
argument_list|,
operator|&
name|err
argument_list|)
operator|)
condition|)
return|return
name|err
condition|?
name|err
else|:
name|ENOENT
return|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|dep
operator|=
name|de
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup path segment  */
end_comment

begin_function
specifier|static
name|DOS_DE
modifier|*
name|lookup
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|unsigned
name|c
parameter_list|,
specifier|const
name|u_char
modifier|*
name|nx
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
specifier|static
name|DOS_DE
name|dir
index|[
name|DEPSEC
index|]
decl_stmt|;
name|u_long
name|lsec
decl_stmt|;
name|u_int
name|nsec
decl_stmt|;
name|int
name|s
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
literal|2
condition|;
name|e
operator|++
control|)
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|dot
operator|+
name|e
argument_list|,
name|nx
argument_list|,
name|DENXSZ
argument_list|)
condition|)
return|return
name|dot
operator|+
name|e
return|;
name|nsec
operator|=
operator|!
name|c
condition|?
name|entsec
argument_list|(
name|fs
operator|->
name|dirents
argument_list|)
else|:
name|fs
operator|->
name|spc
expr_stmt|;
name|lsec
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|c
operator|&&
operator|!
name|lsec
condition|)
name|lsec
operator|=
name|fs
operator|->
name|lsndir
expr_stmt|;
elseif|else
if|if okclus
condition|(
name|fs
operator|,
name|c
condition|)
name|lsec
operator|=
name|blklsn
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|err
operator|=
name|EBADFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|nsec
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
name|lsec
operator|+
name|s
argument_list|,
name|dir
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
operator|*
name|err
operator|=
name|e
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|DEPSEC
condition|;
name|e
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|dir
index|[
name|e
index|]
operator|.
name|name
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|dir
index|[
name|e
index|]
operator|.
name|name
operator|==
literal|0xe5
operator|||
name|dir
index|[
name|e
index|]
operator|.
name|attr
operator|&
name|FA_LABEL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|dir
operator|+
name|e
argument_list|,
name|nx
argument_list|,
name|DENXSZ
argument_list|)
condition|)
return|return
name|dir
operator|+
name|e
return|;
block|}
block|}
block|}
do|while
condition|(
name|c
operator|&&
operator|!
name|fatend
argument_list|(
name|fs
operator|->
name|fat12
argument_list|,
name|c
operator|=
name|fatget
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
argument_list|)
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Return size of file in bytes  */
end_comment

begin_function
specifier|static
name|off_t
name|fsize
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_DE
modifier|*
name|de
parameter_list|)
block|{
name|u_long
name|size
decl_stmt|;
name|u_int
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|size
operator|=
name|cv4
argument_list|(
name|de
operator|->
name|size
argument_list|)
operator|)
operator|&&
name|de
operator|->
name|attr
operator|&
name|FA_DIR
condition|)
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|cv2
argument_list|(
name|de
operator|->
name|clus
argument_list|)
operator|)
condition|)
name|size
operator|=
name|fs
operator|->
name|dirents
operator|*
sizeof|sizeof
argument_list|(
name|DOS_DE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|fatcnt
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|n
return|;
name|size
operator|=
name|blkbyt
argument_list|(
name|fs
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/*  * Return next cluster in cluster chain  */
end_comment

begin_function
specifier|static
name|u_short
name|fatget
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_short
name|c
parameter_list|)
block|{
name|u_short
name|x
decl_stmt|;
name|x
operator|=
name|cv2
argument_list|(
name|fs
operator|->
name|fat
operator|+
name|fatoff
argument_list|(
name|fs
operator|->
name|fat12
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fs
operator|->
name|fat12
condition|?
name|c
operator|&
literal|1
condition|?
name|x
operator|>>
literal|4
else|:
name|x
operator|&
literal|0xfff
else|:
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Count number of clusters in chain  */
end_comment

begin_function
specifier|static
name|int
name|fatcnt
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_short
name|c
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|okclus
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
condition|;
name|n
operator|++
control|)
name|c
operator|=
name|fatget
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|fatend
argument_list|(
name|fs
operator|->
name|fat12
argument_list|,
name|c
argument_list|)
condition|?
name|n
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Is cluster an end-of-chain marker?  */
end_comment

begin_function
specifier|static
name|int
name|fatend
parameter_list|(
name|int
name|fat12
parameter_list|,
name|u_short
name|c
parameter_list|)
block|{
return|return
name|c
operator|>
operator|(
name|fat12
condition|?
literal|0xff7
else|:
literal|0xfff7
operator|)
operator|||
name|c
operator|==
literal|0xfff0
return|;
block|}
end_function

begin_comment
comment|/*  * Offset-based I/O primitive  */
end_comment

begin_function
specifier|static
name|int
name|ioread
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|char
name|tmp
index|[
name|SECSIZ
index|]
decl_stmt|;
name|u_int
name|off
decl_stmt|,
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|offset
operator|&
operator|(
name|SECSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|offset
operator|-=
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fd
argument_list|,
name|bytsec
argument_list|(
name|offset
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|err
return|;
name|offset
operator|+=
name|SECSIZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|SECSIZ
operator|-
name|off
operator|)
operator|>
name|nbytes
condition|)
name|n
operator|=
name|nbytes
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|tmp
operator|+
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|n
expr_stmt|;
name|nbytes
operator|-=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|nbytes
operator|&
operator|(
name|SECSIZ
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|-=
name|n
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fd
argument_list|,
name|bytsec
argument_list|(
name|offset
argument_list|)
argument_list|,
name|buf
argument_list|,
name|bytsec
argument_list|(
name|nbytes
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|err
return|;
name|offset
operator|+=
name|nbytes
expr_stmt|;
name|buf
operator|+=
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fd
argument_list|,
name|bytsec
argument_list|(
name|offset
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|err
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Sector-based I/O primitive  */
end_comment

begin_function
specifier|static
name|int
name|ioget
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_long
name|lsec
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|nsec
parameter_list|)
block|{
name|size_t
name|nbytes
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
name|nbytes
operator|=
name|secbyt
argument_list|(
name|nsec
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|secbyt
argument_list|(
name|lsec
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|errno
return|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EIO
operator|&&
name|dos_ioerr
operator|&&
name|dos_ioerr
argument_list|(
literal|0
argument_list|)
condition|)
do|;
if|if
condition|(
name|n
operator|!=
name|nbytes
condition|)
return|return
name|n
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
name|EIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Convert name to DOS directory (name + extension) format  */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|nxname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|endptr
parameter_list|)
block|{
specifier|static
name|u_char
name|nx
index|[
name|DENXSZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|nx
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|nx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DENMSZ
operator|&&
name|doschar
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
name|nx
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|DENMSZ
condition|)
while|while
condition|(
operator|!
name|sepchar
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
block|{
name|name
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEXTSZ
operator|&&
name|doschar
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
name|nx
index|[
name|DENMSZ
operator|+
name|i
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DEXTSZ
condition|)
while|while
condition|(
operator|!
name|sepchar
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
block|{
name|nx
index|[
literal|0
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|nx
index|[
literal|1
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|name
operator|&&
operator|*
name|name
operator|!=
literal|'/'
operator|)
operator|||
operator|*
name|nx
operator|==
literal|' '
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|nx
operator|==
literal|0xe5
condition|)
operator|*
name|nx
operator|=
literal|5
expr_stmt|;
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
return|return
name|nx
return|;
block|}
end_function

begin_comment
comment|/*  * Is character a path-separator?  */
end_comment

begin_function
specifier|static
name|int
name|sepchar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|!
name|wildchar
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|doschar
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is character a wildcard?  */
end_comment

begin_function
specifier|static
name|int
name|wildchar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'?'
return|;
block|}
end_function

begin_comment
comment|/*  * Is character valid in a DOS name?  */
end_comment

begin_function
specifier|static
name|int
name|doschar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|&
literal|0x80
operator|||
operator|(
name|c
operator|>=
literal|' '
operator|&&
operator|!
name|strchr
argument_list|(
literal|"\"*+,./:;<=>?[\\]|"
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

