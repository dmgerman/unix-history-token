begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2009 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ICONV_H
end_ifdef

begin_include
include|#
directive|include
file|<iconv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/*  * This same file is used pretty much verbatim for all test harnesses.  *  * The next few lines are the only differences.  * TODO: Move this into a separate configuration header, have all test  * suites share one copy of this file.  */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD: src/usr.bin/tar/test/main.c,v 1.6 2008/11/05 06:40:53 kientzle Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|KNOWNREF
value|"test_patterns_2.tar.uu"
end_define

begin_define
define|#
directive|define
name|ENVBASE
value|"BSDTAR"
end_define

begin_comment
comment|/* Prefix for environment variables. */
end_comment

begin_define
define|#
directive|define
name|PROGRAM
value|"bsdtar"
end_define

begin_comment
comment|/* Name of program being tested. */
end_comment

begin_define
define|#
directive|define
name|PROGRAM_ALIAS
value|"tar"
end_define

begin_comment
comment|/* Generic alias for program */
end_comment

begin_undef
undef|#
directive|undef
name|LIBRARY
end_undef

begin_comment
comment|/* Not testing a library. */
end_comment

begin_undef
undef|#
directive|undef
name|EXTRA_DUMP
end_undef

begin_comment
comment|/* How to dump extra data */
end_comment

begin_undef
undef|#
directive|undef
name|EXTRA_ERRNO
end_undef

begin_comment
comment|/* How to dump errno */
end_comment

begin_comment
comment|/* How to generate extra version info. */
end_comment

begin_define
define|#
directive|define
name|EXTRA_VERSION
value|(systemf("%s --version", testprog) ? "" : "")
end_define

begin_comment
comment|/*  *  * Windows support routines  *  * Note: Configuration is a tricky issue.  Using HAVE_* feature macros  * in the test harness is dangerous because they cover up  * configuration errors.  The classic example of this is omitting a  * configure check.  If libarchive and libarchive_test both look for  * the same feature macro, such errors are hard to detect.  Platform  * macros (e.g., _WIN32 or __GNUC__) are a little better, but can  * easily lead to very messy code.  It's best to limit yourself  * to only the most generic programming techniques in the test harness  * and thus avoid conditionals altogether.  Where that's not possible,  * try to minimize conditionals by grouping platform-specific tests in  * one place (e.g., test_acl_freebsd) or by adding new assert()  * functions (e.g., assertMakeHardlink()) to cover up platform  * differences.  Platform-specific coding in libarchive_test is often  * a symptom that some capability is missing from libarchive itself.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|F_OK
end_ifndef

begin_define
define|#
directive|define
name|F_OK
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|access
value|_access
end_define

begin_undef
undef|#
directive|undef
name|chdir
end_undef

begin_define
define|#
directive|define
name|chdir
value|_chdir
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|fileno
end_ifndef

begin_define
define|#
directive|define
name|fileno
value|_fileno
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#define fstat _fstat64*/
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|getcwd
value|_getcwd
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_comment
comment|/*#define lstat _stat64*/
end_comment

begin_comment
comment|/*#define stat _stat64*/
end_comment

begin_define
define|#
directive|define
name|rmdir
value|_rmdir
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|strdup
value|_strdup
end_define

begin_define
define|#
directive|define
name|umask
value|_umask
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|int64_t
value|__int64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CrtSetReportMode
argument_list|)
end_if

begin_include
include|#
directive|include
file|<crtdbg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
name|void
modifier|*
name|GetFunctionKernel32
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|HINSTANCE
name|lib
decl_stmt|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|lib
operator|=
name|LoadLibrary
argument_list|(
literal|"kernel32.dll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lib
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't load kernel32.dll?!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_CreateSymbolicLinkA
parameter_list|(
specifier|const
name|char
modifier|*
name|linkname
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|static
name|BOOLEAN
function_decl|(
name|WINAPI
modifier|*
name|f
function_decl|)
parameter_list|(
name|LPCSTR
parameter_list|,
name|LPCSTR
parameter_list|,
name|DWORD
parameter_list|)
function_decl|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|GetFunctionKernel32
argument_list|(
literal|"CreateSymbolicLinkA"
argument_list|)
expr_stmt|;
block|}
return|return
name|f
operator|==
name|NULL
condition|?
literal|0
else|:
call|(
modifier|*
name|f
call|)
argument_list|(
name|linkname
argument_list|,
name|target
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_CreateHardLinkA
parameter_list|(
specifier|const
name|char
modifier|*
name|linkname
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
specifier|static
name|BOOLEAN
function_decl|(
name|WINAPI
modifier|*
name|f
function_decl|)
parameter_list|(
name|LPCSTR
parameter_list|,
name|LPCSTR
parameter_list|,
name|LPSECURITY_ATTRIBUTES
parameter_list|)
function_decl|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|GetFunctionKernel32
argument_list|(
literal|"CreateHardLinkA"
argument_list|)
expr_stmt|;
block|}
return|return
name|f
operator|==
name|NULL
condition|?
literal|0
else|:
call|(
modifier|*
name|f
call|)
argument_list|(
name|linkname
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|my_GetFileInformationByName
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|BY_HANDLE_FILE_INFORMATION
modifier|*
name|bhfi
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
name|int
name|r
decl_stmt|;
name|memset
argument_list|(
name|bhfi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bhfi
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|CreateFile
argument_list|(
name|path
argument_list|,
name|FILE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|GetFileInformationByHandle
argument_list|(
name|h
argument_list|,
name|bhfi
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CrtSetReportMode
argument_list|)
end_if

begin_function
specifier|static
name|void
name|invalid_parameter_handler
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|expression
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|function
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|uintptr_t
name|pReserved
parameter_list|)
block|{
comment|/* nop */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  * OPTIONS FLAGS  *  */
end_comment

begin_comment
comment|/* Enable core dump on failure. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_on_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to remove temp dirs and log data for successful tests. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_temp_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to run the specified tests once and report errors. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|until_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to just report pass/fail for each test. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbosity
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VERBOSITY_SUMMARY_ONLY
value|-1
end_define

begin_comment
comment|/* -q */
end_comment

begin_define
define|#
directive|define
name|VERBOSITY_PASSFAIL
value|0
end_define

begin_comment
comment|/* Default */
end_comment

begin_define
define|#
directive|define
name|VERBOSITY_LIGHT_REPORT
value|1
end_define

begin_comment
comment|/* -v */
end_comment

begin_define
define|#
directive|define
name|VERBOSITY_FULL
value|2
end_define

begin_comment
comment|/* -vv */
end_comment

begin_comment
comment|/* A few places generate even more output for verbosity> VERBOSITY_FULL,  * mostly for debugging the test harness itself. */
end_comment

begin_comment
comment|/* Cumulative count of assertion failures. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|failures
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cumulative count of reported skips. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|skips
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cumulative count of assertions checked. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|assertions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory where uuencoded reference files can be found. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|refdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Report log information selectively to console and/or disk log.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|log_console
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vlogprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|va_copy
name|va_list
name|lfap
decl_stmt|;
name|va_copy
argument_list|(
name|lfap
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|log_console
condition|)
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
ifdef|#
directive|ifdef
name|va_copy
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|lfap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|lfap
argument_list|)
expr_stmt|;
else|#
directive|else
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|logprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vlogprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up a message to display only if next assertion fails. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|msgbuff
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|nextmsg
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|failure
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
name|nextmsg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|msgbuff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|nextmsg
operator|=
name|msgbuff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy arguments into file-local variables.  * This was added to permit vararg assert() functions without needing  * variadic wrapper macros.  Turns out that the vararg capability is almost  * never used, so almost all of the vararg assertions can be simplified  * by removing the vararg capability and reworking the wrapper macro to  * pass __FILE__, __LINE__ directly into the function instead of using  * this hook.  I suspect this machinery is used so rarely that we  * would be better off just removing it entirely.  That would simplify  * the code here noticeably.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|skipping_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skipping_line
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|skipping_setup
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|skipping_filename
operator|=
name|filename
expr_stmt|;
name|skipping_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at the beginning of each assert() function. */
end_comment

begin_function
specifier|static
name|void
name|assertion_count
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
operator|(
name|void
operator|)
name|file
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|line
expr_stmt|;
comment|/* UNUSED */
operator|++
name|assertions
expr_stmt|;
comment|/* Proper handling of "failure()" message. */
name|msg
operator|=
name|nextmsg
expr_stmt|;
name|nextmsg
operator|=
name|NULL
expr_stmt|;
comment|/* Uncomment to print file:line after every assertion. 	 * Verbose, but occasionally useful in tracking down crashes. */
comment|/* printf("Checked %s:%d\n", file, line); */
block|}
end_function

begin_comment
comment|/*  * For each test source file, we remember how many times each  * assertion was reported.  Cleared before each new test,  * used by test_summarize().  */
end_comment

begin_struct
specifier|static
struct|struct
name|line
block|{
name|int
name|count
decl_stmt|;
name|int
name|skip
decl_stmt|;
block|}
name|failed_lines
index|[
literal|10000
index|]
struct|;
end_struct

begin_decl_stmt
specifier|const
name|char
modifier|*
name|failed_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count this failure, setup up log destination and handle initial report. */
end_comment

begin_function
specifier|static
name|void
name|failure_start
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* Record another failure for this line. */
operator|++
name|failures
expr_stmt|;
name|failed_filename
operator|=
name|filename
expr_stmt|;
name|failed_lines
index|[
name|line
index|]
operator|.
name|count
operator|++
expr_stmt|;
comment|/* Determine whether to log header to console. */
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|VERBOSITY_LIGHT_REPORT
case|:
name|log_console
operator|=
operator|(
name|failed_lines
index|[
name|line
index|]
operator|.
name|count
operator|<
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|log_console
operator|=
operator|(
name|verbosity
operator|>=
name|VERBOSITY_FULL
operator|)
expr_stmt|;
block|}
comment|/* Log file:line header for this failure */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|#
directive|if
name|_MSC_VER
name|logprintf
argument_list|(
literal|"%s(%d): "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
name|logprintf
argument_list|(
literal|"%s:%d: "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vlogprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
operator|&&
name|msg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|logprintf
argument_list|(
literal|"   Description: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Determine whether to log details to console. */
if|if
condition|(
name|verbosity
operator|==
name|VERBOSITY_LIGHT_REPORT
condition|)
name|log_console
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Complete reporting of failed tests. */
end_comment

begin_comment
comment|/*  * The 'extra' hook here is used by libarchive to include libarchive  * error messages with assertion failures.  It could also be used  * to add strerror() output, for example.  Just define the EXTRA_DUMP()  * macro appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|failure_finish
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|)
block|{
operator|(
name|void
operator|)
name|extra
expr_stmt|;
comment|/* UNUSED (maybe) */
ifdef|#
directive|ifdef
name|EXTRA_DUMP
if|if
condition|(
name|extra
operator|!=
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"    errno: %d\n"
argument_list|,
name|EXTRA_ERRNO
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   detail: %s\n"
argument_list|,
name|EXTRA_DUMP
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dump_on_failure
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" *** forcing core dump so failure can be debugged ***\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Inform user that we're skipping some checks. */
end_comment

begin_function
name|void
name|test_skipping
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* Use failure() message if set. */
name|msg
operator|=
name|nextmsg
expr_stmt|;
name|nextmsg
operator|=
name|NULL
expr_stmt|;
comment|/* failure_start() isn't quite right, but is awfully convenient. */
name|failure_start
argument_list|(
name|skipping_filename
argument_list|,
name|skipping_line
argument_list|,
literal|"SKIPPING: %s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
operator|--
name|failures
expr_stmt|;
comment|/* Undo failures++ in failure_start() */
comment|/* Don't failure_finish() here. */
comment|/* Mark as skip, so doesn't count as failed test. */
name|failed_lines
index|[
name|skipping_line
index|]
operator|.
name|skip
operator|=
literal|1
expr_stmt|;
operator|++
name|skips
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * ASSERTIONS  *  */
end_comment

begin_comment
comment|/* Generic assert() just displays the failed condition. */
end_comment

begin_function
name|int
name|assertion_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|condition
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Assertion failed: %s"
argument_list|,
name|condition
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* chdir() and report any errors */
end_comment

begin_function
name|int
name|assertion_chdir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pathname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"chdir(\"%s\")"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify two integers are equal. */
end_comment

begin_function
name|int
name|assertion_equal_int
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|long
name|long
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
name|long
name|long
name|v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      %s=%lld (0x%llx, 0%llo)\n"
argument_list|,
name|e1
argument_list|,
name|v1
argument_list|,
name|v1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      %s=%lld (0x%llx, 0%llo)\n"
argument_list|,
name|e2
argument_list|,
name|v2
argument_list|,
name|v2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility to convert a single UTF-8 sequence.  */
end_comment

begin_function
specifier|static
name|int
name|_utf8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|utf8_count
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 00 - 0F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 10 - 1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20 - 2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30 - 3F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 50 - 5F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60 - 6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* C0 - CF */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* D0 - DF */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* E0 - EF */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* F0 - FF */
block|}
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|uint32_t
name|wc
decl_stmt|;
operator|*
name|pwc
operator|=
literal|0
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Decode 1-4 bytes depending on the value of the first byte. 	 */
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Standard:  return 0 for end-of-string. */
name|cnt
operator|=
name|utf8_count
index|[
name|ch
index|]
expr_stmt|;
comment|/* Invalide sequence or there are not plenty bytes. */
if|if
condition|(
name|n
operator|<
operator|(
name|size_t
operator|)
name|cnt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Make a Unicode code point from a single UTF-8 sequence. */
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
literal|1
case|:
comment|/* 1 byte sequence. */
operator|*
name|pwc
operator|=
name|ch
operator|&
literal|0x7f
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
case|case
literal|2
case|:
comment|/* 2 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|pwc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
case|case
literal|3
case|:
comment|/* 3 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x0f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x800
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Overlong sequence. */
break|break;
case|case
literal|4
case|:
comment|/* 4 bytes sequence. */
if|if
condition|(
name|n
operator|<
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|3
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x07
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|3
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x10000
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Overlong sequence. */
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* The code point larger than 0x10FFFF is not leagal 	 * Unicode values. */
if|if
condition|(
name|wc
operator|>
literal|0x10FFFF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Correctly gets a Unicode, returns used bytes. */
operator|*
name|pwc
operator|=
name|wc
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|strdump
parameter_list|(
specifier|const
name|char
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|ewidth
parameter_list|,
name|int
name|utf8
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|logprintf
argument_list|(
literal|"      %*s = "
argument_list|,
name|ewidth
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|logprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|unsigned
name|int
name|c
init|=
literal|0xff
operator|&
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\a'
case|:
name|printf
argument_list|(
literal|"\a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|printf
argument_list|(
literal|"\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|32
operator|&&
name|c
operator|<
literal|127
condition|)
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|logprintf
argument_list|(
literal|"\\x%02X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|logprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|" (length %d)"
argument_list|,
name|q
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the current string is UTF-8, dump its code points. 	 */
if|if
condition|(
name|utf8
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|uint32_t
name|uc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|" ["
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|_utf8_to_unicode
argument_list|(
operator|&
name|uc
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|q
condition|)
name|logprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"%04X"
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|" (count %d"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|logprintf
argument_list|(
literal|",unknown %d bytes"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify two strings are equal, dump them if not. */
end_comment

begin_function
name|int
name|assertion_equal_string
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
specifier|const
name|char
modifier|*
name|v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|,
name|int
name|utf8
parameter_list|)
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
operator|||
operator|(
name|v1
operator|!=
name|NULL
operator|&&
name|v2
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strlen
argument_list|(
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|<
name|l2
condition|)
name|l1
operator|=
name|l2
expr_stmt|;
name|strdump
argument_list|(
name|e1
argument_list|,
name|v1
argument_list|,
name|l1
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|strdump
argument_list|(
name|e2
argument_list|,
name|v2
argument_list|,
name|l1
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcsdump
parameter_list|(
specifier|const
name|char
modifier|*
name|e
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|w
parameter_list|)
block|{
name|logprintf
argument_list|(
literal|"      %s = "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"(null)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|logprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|w
operator|!=
literal|L'
expr|\0'
condition|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|w
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|32
operator|&&
name|c
operator|<
literal|127
condition|)
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|256
condition|)
name|logprintf
argument_list|(
literal|"\\x%02X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000
condition|)
name|logprintf
argument_list|(
literal|"\\u%04X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|logprintf
argument_list|(
literal|"\\U%08X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_WCSCMP
end_ifndef

begin_function
specifier|static
name|int
name|wcscmp
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|L'
expr|\0'
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|s1
operator|>
operator|*
operator|--
name|s2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Verify that two wide strings are equal, dump them if not. */
end_comment

begin_function
name|int
name|assertion_equal_wstring
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|v1
operator|!=
name|NULL
operator|&&
name|v2
operator|!=
name|NULL
operator|&&
name|wcscmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|wcsdump
argument_list|(
name|e1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|wcsdump
argument_list|(
name|e2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pretty standard hexdump routine.  As a bonus, if ref != NULL, then  * any bytes in p that differ from ref will be highlighted with '_'  * before and after the hex value.  */
end_comment

begin_function
specifier|static
name|void
name|hexdump
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|,
name|size_t
name|l
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|sep
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"(null)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|logprintf
argument_list|(
literal|"%04x"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|+
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ref
operator|!=
name|NULL
operator|&&
name|p
index|[
name|i
operator|+
name|j
index|]
operator|!=
name|ref
index|[
name|i
operator|+
name|j
index|]
condition|)
name|sep
operator|=
literal|'_'
expr_stmt|;
name|logprintf
argument_list|(
literal|"%c%02x"
argument_list|,
name|sep
argument_list|,
literal|0xff
operator|&
operator|(
name|int
operator|)
name|p
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|!=
name|NULL
operator|&&
name|p
index|[
name|i
operator|+
name|j
index|]
operator|==
name|ref
index|[
name|i
operator|+
name|j
index|]
condition|)
name|sep
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|logprintf
argument_list|(
literal|"%c  "
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|' '
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|+
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
name|int
name|c
init|=
name|p
index|[
name|i
operator|+
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|126
condition|)
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|logprintf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Verify that two blocks of memory are the same, display the first  * block of differences if they're not. */
end_comment

begin_function
name|int
name|assertion_equal_mem
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|void
modifier|*
name|_v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|_v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|size_t
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|ld
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|v1
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_v1
decl_stmt|;
specifier|const
name|char
modifier|*
name|v2
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_v2
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
operator|||
operator|(
name|v1
operator|!=
name|NULL
operator|&&
name|v2
operator|!=
name|NULL
operator|&&
name|memcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      size %s = %d\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|int
operator|)
name|l
argument_list|)
expr_stmt|;
comment|/* Dump 48 bytes (3 lines) so that the first difference is 	 * in the second line. */
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|64
operator|&&
name|memcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
literal|32
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Two lines agree, so step forward one line. */
name|v1
operator|+=
literal|16
expr_stmt|;
name|v2
operator|+=
literal|16
expr_stmt|;
name|l
operator|-=
literal|16
expr_stmt|;
name|offset
operator|+=
literal|16
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"      Dump of %s\n"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|l
operator|<
literal|128
condition|?
name|l
else|:
literal|128
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      Dump of %s\n"
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|v2
argument_list|,
name|v1
argument_list|,
name|l
operator|<
literal|128
condition|?
name|l
else|:
literal|128
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file exists and is empty. */
end_comment

begin_function
name|int
name|assertion_empty_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f1
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Stat failed: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should be empty: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"    File size: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"    Contents:\n"
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|f1
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"    Unable to open %s\n"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
operator|(
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|<
name|st
operator|.
name|st_size
operator|)
condition|?
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
else|:
operator|(
name|ssize_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
name|s
operator|=
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|NULL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file exists and is not empty. */
end_comment

begin_function
name|int
name|assertion_non_empty_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Stat failed: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File empty: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that two files have the same contents. */
end_comment

begin_comment
comment|/* TODO: hexdump the first bytes that actually differ. */
end_comment

begin_function
name|int
name|assertion_equal_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn1
parameter_list|,
specifier|const
name|char
modifier|*
name|fn2
parameter_list|)
block|{
name|char
name|buff1
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|buff2
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f1
operator|=
name|fopen
argument_list|(
name|fn1
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|f2
operator|=
name|fopen
argument_list|(
name|fn2
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n1
operator|=
name|fread
argument_list|(
name|buff1
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff1
argument_list|)
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|n2
operator|=
name|fread
argument_list|(
name|buff2
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff2
argument_list|)
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|!=
name|n2
condition|)
break|break;
if|if
condition|(
name|n1
operator|==
literal|0
operator|&&
name|n2
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buff1
argument_list|,
name|buff2
argument_list|,
name|n1
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Files not identical"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file1=\"%s\"\n"
argument_list|,
name|fn1
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file2=\"%s\"\n"
argument_list|,
name|fn2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file does exist. */
end_comment

begin_function
name|int
name|assertion_file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
operator|!
name|_access
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|access
argument_list|(
name|f
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file doesn't exist. */
end_comment

begin_function
name|int
name|assertion_file_not_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|_access
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|access
argument_list|(
name|f
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should not exist: %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the contents of a file to a block of memory. */
end_comment

begin_function
name|int
name|assertion_file_contents
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|int
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|contents
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|n
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|contents
operator|=
name|malloc
argument_list|(
name|s
operator|*
literal|2
argument_list|)
expr_stmt|;
name|n
operator|=
name|fread
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|s
operator|*
literal|2
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|s
operator|&&
name|memcmp
argument_list|(
name|buff
argument_list|,
name|contents
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File contents don't match"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file=\"%s\"\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|hexdump
argument_list|(
name|contents
argument_list|,
name|buff
argument_list|,
name|n
operator|>
literal|512
condition|?
literal|512
else|:
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|logprintf
argument_list|(
literal|"  File empty, contents should be:\n"
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|NULL
argument_list|,
name|s
operator|>
literal|512
condition|?
literal|512
else|:
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check the contents of a text file, being tolerant of line endings. */
end_comment

begin_function
name|int
name|assertion_text_file_contents
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|contents
decl_stmt|;
specifier|const
name|char
modifier|*
name|btxt
decl_stmt|,
modifier|*
name|ftxt
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|s
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File doesn't exist: %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|contents
operator|=
name|malloc
argument_list|(
name|s
operator|*
literal|2
operator|+
literal|128
argument_list|)
expr_stmt|;
name|n
operator|=
name|fread
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|s
operator|*
literal|2
operator|+
literal|128
operator|-
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|contents
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Compare texts. */
name|btxt
operator|=
name|buff
expr_stmt|;
name|ftxt
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|contents
expr_stmt|;
while|while
condition|(
operator|*
name|btxt
operator|!=
literal|'\0'
operator|&&
operator|*
name|ftxt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|btxt
operator|==
operator|*
name|ftxt
condition|)
block|{
operator|++
name|btxt
expr_stmt|;
operator|++
name|ftxt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|btxt
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|ftxt
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|ftxt
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* Pass over different new line characters. */
operator|++
name|btxt
expr_stmt|;
name|ftxt
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|btxt
operator|==
literal|'\0'
operator|&&
operator|*
name|ftxt
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Contents don't match"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file=\"%s\"\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|hexdump
argument_list|(
name|contents
argument_list|,
name|buff
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  expected\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|contents
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logprintf
argument_list|(
literal|"  File empty, contents should be:\n"
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|NULL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that a text file contains the specified lines, regardless of order */
end_comment

begin_comment
comment|/* This could be more efficient if we sorted both sets of lines, etc, but  * since this is used only for testing and only ever deals with a dozen or so  * lines at a time, this relatively crude approach is just fine. */
end_comment

begin_function
name|int
name|assertion_file_contains_lines_any_order
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|lines
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|buff
decl_stmt|;
name|size_t
name|buff_size
decl_stmt|;
name|size_t
name|expected_count
decl_stmt|,
name|actual_count
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|expected
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|actual
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|expected_failure
init|=
literal|0
decl_stmt|,
name|actual_failure
init|=
literal|0
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|buff
operator|=
name|slurpfile
argument_list|(
operator|&
name|buff_size
argument_list|,
literal|"%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|pathname
argument_list|,
name|line
argument_list|,
literal|"Can't read file: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Make a copy of the provided lines and count up the expected file size. */
name|expected_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lines
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{ 	}
name|expected_count
operator|=
name|i
expr_stmt|;
name|expected
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|expected_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lines
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|expected
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Break the file into lines */
name|actual_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'\0'
operator|,
name|p
operator|=
name|buff
init|;
name|p
operator|<
name|buff
operator|+
name|buff_size
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\x0d'
operator|||
operator|*
name|p
operator|==
literal|'\x0a'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|actual_count
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|actual
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|actual_count
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p
operator|=
name|buff
init|;
name|p
operator|<
name|buff
operator|+
name|buff_size
condition|;
name|p
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|actual
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
comment|/* Erase matching lines from both lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expected_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|actual_count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actual
index|[
name|j
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|expected
index|[
name|i
index|]
argument_list|,
name|actual
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|expected
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|expected
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|actual
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If there's anything left, it's a failure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expected_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|++
name|expected_failure
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|actual_count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actual
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
operator|++
name|actual_failure
expr_stmt|;
block|}
if|if
condition|(
name|expected_failure
operator|==
literal|0
operator|&&
name|actual_failure
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|actual
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File doesn't match: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expected_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"  Expected but not present: %s\n"
argument_list|,
name|expected
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|actual_count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actual
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|logprintf
argument_list|(
literal|"  Present but not expected: %s\n"
argument_list|,
name|actual
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|actual
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test that two paths point to the same file. */
end_comment

begin_comment
comment|/* As a side-effect, asserts that both files exist. */
end_comment

begin_function
specifier|static
name|int
name|is_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|BY_HANDLE_FILE_INFORMATION
name|bhfi1
decl_stmt|,
name|bhfi2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|path1
argument_list|,
operator|&
name|bhfi1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s can't be inspected?"
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|path2
argument_list|,
operator|&
name|bhfi2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s can't be inspected?"
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|bhfi1
operator|.
name|dwVolumeSerialNumber
operator|==
name|bhfi2
operator|.
name|dwVolumeSerialNumber
operator|&&
name|bhfi1
operator|.
name|nFileIndexHigh
operator|==
name|bhfi2
operator|.
name|nFileIndexHigh
operator|&&
name|bhfi1
operator|.
name|nFileIndexLow
operator|==
name|bhfi2
operator|.
name|nFileIndexLow
operator|)
return|;
else|#
directive|else
name|struct
name|stat
name|st1
decl_stmt|,
name|st2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|path1
argument_list|,
operator|&
name|st1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|lstat
argument_list|(
name|path2
argument_list|,
operator|&
name|st2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|st1
operator|.
name|st_ino
operator|==
name|st2
operator|.
name|st_ino
operator|&&
name|st1
operator|.
name|st_dev
operator|==
name|st2
operator|.
name|st_dev
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|assertion_is_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
if|if
condition|(
name|is_hardlink
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Files %s and %s are not hardlinked"
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|assertion_is_not_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_hardlink
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Files %s and %s should not be hardlinked"
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify a/b/mtime of 'pathname'. */
end_comment

begin_comment
comment|/* If 'recent', verify that it's within last 10 seconds. */
end_comment

begin_function
specifier|static
name|int
name|assertion_file_time
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|recent
parameter_list|)
block|{
name|long
name|long
name|filet
decl_stmt|,
name|filet_nsec
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
define|#
directive|define
name|EPOC_TIME
value|(116444736000000000ULL)
name|FILETIME
name|ftime
decl_stmt|,
name|fbirthtime
decl_stmt|,
name|fatime
decl_stmt|,
name|fmtime
decl_stmt|;
name|ULARGE_INTEGER
name|wintm
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|ftime
operator|.
name|dwLowDateTime
operator|=
literal|0
expr_stmt|;
name|ftime
operator|.
name|dwHighDateTime
operator|=
literal|0
expr_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Note: FILE_FLAG_BACKUP_SEMANTICS applies to open 	 * a directory file. If not, CreateFile() will fail when 	 * the pathname is a directory. */
name|h
operator|=
name|CreateFile
argument_list|(
name|pathname
argument_list|,
name|FILE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't access %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|GetFileTime
argument_list|(
name|h
argument_list|,
operator|&
name|fbirthtime
argument_list|,
operator|&
name|fatime
argument_list|,
operator|&
name|fmtime
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'a'
case|:
name|ftime
operator|=
name|fatime
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ftime
operator|=
name|fbirthtime
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|ftime
operator|=
name|fmtime
expr_stmt|;
break|break;
block|}
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't GetFileTime %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wintm
operator|.
name|LowPart
operator|=
name|ftime
operator|.
name|dwLowDateTime
expr_stmt|;
name|wintm
operator|.
name|HighPart
operator|=
name|ftime
operator|.
name|dwHighDateTime
expr_stmt|;
name|filet
operator|=
operator|(
name|wintm
operator|.
name|QuadPart
operator|-
name|EPOC_TIME
operator|)
operator|/
literal|10000000
expr_stmt|;
name|filet_nsec
operator|=
operator|(
operator|(
name|wintm
operator|.
name|QuadPart
operator|-
name|EPOC_TIME
operator|)
operator|%
literal|10000000
operator|)
operator|*
literal|100
expr_stmt|;
name|nsec
operator|=
operator|(
name|nsec
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
comment|/* Round the request */
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't stat %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'a'
case|:
name|filet
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|filet
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|filet
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"INTERNAL: Bad type %c for file time"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'a'
case|:
name|filet_nsec
operator|=
name|st
operator|.
name|st_atimespec
operator|.
name|tv_nsec
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|filet
operator|=
name|st
operator|.
name|st_birthtime
expr_stmt|;
name|filet_nsec
operator|=
name|st
operator|.
name|st_birthtimespec
operator|.
name|tv_nsec
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|filet_nsec
operator|=
name|st
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"INTERNAL: Bad type %c for file time"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* FreeBSD generally only stores to microsecond res, so round. */
name|filet_nsec
operator|=
operator|(
name|filet_nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|nsec
operator|=
operator|(
name|nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
else|#
directive|else
name|filet_nsec
operator|=
name|nsec
operator|=
literal|0
expr_stmt|;
comment|/* Generic POSIX only has whole seconds. */
if|if
condition|(
name|type
operator|==
literal|'b'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Generic POSIX doesn't have birthtime */
if|#
directive|if
name|defined
argument_list|(
name|__HAIKU__
argument_list|)
if|if
condition|(
name|type
operator|==
literal|'a'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Haiku doesn't have atime. */
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|recent
condition|)
block|{
comment|/* Check that requested time is up-to-date. */
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|filet
operator|<
name|now
operator|-
literal|10
operator|||
name|filet
operator|>
name|now
operator|+
literal|1
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %ctime %lld, %lld seconds ago\n"
argument_list|,
name|pathname
argument_list|,
name|type
argument_list|,
name|filet
argument_list|,
name|now
operator|-
name|filet
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|filet
operator|!=
name|t
operator|||
name|filet_nsec
operator|!=
name|nsec
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %ctime %lld.%09lld, expected %lld.%09lld"
argument_list|,
name|pathname
argument_list|,
name|type
argument_list|,
name|filet
argument_list|,
name|filet_nsec
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify atime of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_atime
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|,
literal|'a'
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify atime of 'pathname' is up-to-date. */
end_comment

begin_function
name|int
name|assertion_file_atime_recent
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'a'
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify birthtime of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_birthtime
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|,
literal|'b'
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify birthtime of 'pathname' is up-to-date. */
end_comment

begin_function
name|int
name|assertion_file_birthtime_recent
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'b'
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify mtime of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_mtime
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|,
literal|'m'
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify mtime of 'pathname' is up-to-date. */
end_comment

begin_function
name|int
name|assertion_file_mtime_recent
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'m'
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify number of links to 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_nlinks
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|nlinks
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|BY_HANDLE_FILE_INFORMATION
name|bhfi
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|pathname
argument_list|,
operator|&
name|bhfi
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|bhfi
operator|.
name|nNumberOfLinks
operator|==
operator|(
name|DWORD
operator|)
name|nlinks
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %d links, expected %d"
argument_list|,
name|pathname
argument_list|,
name|bhfi
operator|.
name|nNumberOfLinks
argument_list|,
name|nlinks
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_nlink
operator|==
name|nlinks
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %d links, expected %d"
argument_list|,
name|pathname
argument_list|,
name|st
operator|.
name|st_nlink
argument_list|,
name|nlinks
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Verify size of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_size
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|int64_t
name|filesize
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
block|{
name|BY_HANDLE_FILE_INFORMATION
name|bhfi
decl_stmt|;
name|r
operator|=
operator|!
name|my_GetFileInformationByName
argument_list|(
name|pathname
argument_list|,
operator|&
name|bhfi
argument_list|)
expr_stmt|;
name|filesize
operator|=
operator|(
operator|(
name|int64_t
operator|)
name|bhfi
operator|.
name|nFileSizeHigh
operator|<<
literal|32
operator|)
operator|+
name|bhfi
operator|.
name|nFileSizeLow
expr_stmt|;
block|}
else|#
directive|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|filesize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|filesize
operator|==
name|size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has size %ld, expected %ld"
argument_list|,
name|pathname
argument_list|,
operator|(
name|long
operator|)
name|filesize
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assert that 'pathname' is a dir.  If mode>= 0, verify that too. */
end_comment

begin_function
name|int
name|assertion_is_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Dir should exist: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s is not a dir"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Windows doesn't handle permissions the same way as POSIX, 	 * so just ignore the mode tests. */
comment|/* TODO: Can we do better here? */
if|if
condition|(
name|mode
operator|>=
literal|0
operator|&&
name|mode
operator|!=
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|07777
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Dir %s has wrong mode"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Expected: 0%3o\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Found: 0%3o\n"
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that 'pathname' is a regular file.  If 'mode' is>= 0,  * verify that too. */
end_comment

begin_function
name|int
name|assertion_is_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Windows doesn't handle permissions the same way as POSIX, 	 * so just ignore the mode tests. */
comment|/* TODO: Can we do better here? */
if|if
condition|(
name|mode
operator|>=
literal|0
operator|&&
name|mode
operator|!=
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|07777
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has wrong mode"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Expected: 0%3o\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Found: 0%3o\n"
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether 'pathname' is a symbolic link.  If 'contents' is  * non-NULL, verify that the symlink has those contents. */
end_comment

begin_function
specifier|static
name|int
name|is_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|pathname
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|contents
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Windows sort-of has real symlinks, but they're only usable 	 * by privileged users and are crippled even then, so there's 	 * really not much point in bothering with this. */
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|char
name|buff
index|[
literal|300
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|ssize_t
name|linklen
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Symlink should exist: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|linklen
operator|=
name|readlink
argument_list|(
name|pathname
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|linklen
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't read symlink %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|buff
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|contents
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Assert that path is a symlink that (optionally) contains contents. */
end_comment

begin_function
name|int
name|assertion_is_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|)
block|{
if|if
condition|(
name|is_symlink
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path
argument_list|,
name|contents
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|contents
condition|)
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s is not a symlink to %s"
argument_list|,
name|path
argument_list|,
name|contents
argument_list|)
expr_stmt|;
else|else
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s is not a symlink"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a directory and report any errors. */
end_comment

begin_function
name|int
name|assertion_make_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
literal|0
operator|==
name|_mkdir
argument_list|(
name|dirname
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
literal|0
operator|==
name|mkdir
argument_list|(
name|dirname
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create directory %s"
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a file with the specified contents and report any failures. */
end_comment

begin_function
name|int
name|assertion_make_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* TODO: Rework this to set file mode as well. */
name|FILE
modifier|*
name|f
decl_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create file %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|contents
argument_list|)
operator|!=
name|fwrite
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|contents
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not write file %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|int
name|fd
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
name|mode
operator|>=
literal|0
condition|?
name|mode
else|:
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ssize_t
operator|)
name|strlen
argument_list|(
name|contents
argument_list|)
operator|!=
name|write
argument_list|(
name|fd
argument_list|,
name|contents
argument_list|,
name|strlen
argument_list|(
name|contents
argument_list|)
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not write to %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Create a hardlink and report any failures. */
end_comment

begin_function
name|int
name|assertion_make_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
specifier|const
name|char
modifier|*
name|linkto
parameter_list|)
block|{
name|int
name|succeeded
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|succeeded
operator|=
name|my_CreateHardLinkA
argument_list|(
name|newpath
argument_list|,
name|linkto
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|HAVE_LINK
name|succeeded
operator|=
operator|!
name|link
argument_list|(
name|linkto
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
else|#
directive|else
name|succeeded
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|succeeded
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create hardlink"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   New link: %s\n"
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   Old name: %s\n"
argument_list|,
name|linkto
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a symlink and report any failures. */
end_comment

begin_function
name|int
name|assertion_make_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
specifier|const
name|char
modifier|*
name|linkto
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|int
name|targetIsDir
init|=
literal|0
decl_stmt|;
comment|/* TODO: Fix this */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_CreateSymbolicLinkA
argument_list|(
name|newpath
argument_list|,
name|linkto
argument_list|,
name|targetIsDir
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
name|HAVE_SYMLINK
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|symlink
argument_list|(
name|linkto
argument_list|,
name|newpath
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create symlink"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   New link: %s\n"
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   Old name: %s\n"
argument_list|,
name|linkto
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set umask, report failures. */
end_comment

begin_function
name|int
name|assertion_umask
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|file
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|line
expr_stmt|;
comment|/* UNUSED */
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set times, report failures. */
end_comment

begin_function
name|int
name|assertion_utimes
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|at
parameter_list|,
name|long
name|at_nsec
parameter_list|,
name|long
name|mt
parameter_list|,
name|long
name|mt_nsec
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
define|#
directive|define
name|WINTIME
parameter_list|(
name|sec
parameter_list|,
name|nsec
parameter_list|)
value|((Int32x32To64(sec, 10000000) + EPOC_TIME)\ 	 + (((nsec)/1000)*10))
name|HANDLE
name|h
decl_stmt|;
name|ULARGE_INTEGER
name|wintm
decl_stmt|;
name|FILETIME
name|fatime
decl_stmt|,
name|fmtime
decl_stmt|;
name|FILETIME
modifier|*
name|pat
decl_stmt|,
modifier|*
name|pmt
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|h
operator|=
name|CreateFileA
argument_list|(
name|pathname
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't access %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|at
operator|>
literal|0
operator|||
name|at_nsec
operator|>
literal|0
condition|)
block|{
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|at
argument_list|,
name|at_nsec
argument_list|)
expr_stmt|;
name|fatime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fatime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
name|pat
operator|=
operator|&
name|fatime
expr_stmt|;
block|}
else|else
name|pat
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mt
operator|>
literal|0
operator|||
name|mt_nsec
operator|>
literal|0
condition|)
block|{
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|mt
argument_list|,
name|mt_nsec
argument_list|)
expr_stmt|;
name|fmtime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fmtime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
name|pmt
operator|=
operator|&
name|fmtime
expr_stmt|;
block|}
else|else
name|pmt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|NULL
operator|||
name|pmt
operator|!=
name|NULL
condition|)
name|r
operator|=
name|SetFileTime
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
name|pat
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
literal|1
expr_stmt|;
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't SetFileTime %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* defined(_WIN32)&& !defined(__CYGWIN__) */
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mt_nsec
operator|=
name|at_nsec
operator|=
literal|0
expr_stmt|;
comment|/* Generic POSIX only has whole seconds. */
endif|#
directive|endif
if|if
condition|(
name|mt
operator|==
literal|0
operator|&&
name|mt_nsec
operator|==
literal|0
operator|&&
name|at
operator|==
literal|0
operator|&&
name|at_nsec
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't stat %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mt
operator|==
literal|0
operator|&&
name|mt_nsec
operator|==
literal|0
condition|)
block|{
name|mt
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mt_nsec
operator|=
name|st
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
expr_stmt|;
comment|/* FreeBSD generally only stores to microsecond res, so round. */
name|mt_nsec
operator|=
operator|(
name|mt_nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|at
operator|==
literal|0
operator|&&
name|at_nsec
operator|==
literal|0
condition|)
block|{
name|at
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|at_nsec
operator|=
name|st
operator|.
name|st_atimespec
operator|.
name|tv_nsec
expr_stmt|;
comment|/* FreeBSD generally only stores to microsecond res, so round. */
name|at_nsec
operator|=
operator|(
name|at_nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
block|}
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mt
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|mt_nsec
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|at
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|at_nsec
operator|/
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LUTIMES
name|r
operator|=
name|lutimes
argument_list|(
name|pathname
argument_list|,
name|times
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|utimes
argument_list|(
name|pathname
argument_list|,
name|times
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't utimes %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* defined(_WIN32)&& !defined(__CYGWIN__) */
block|}
end_function

begin_comment
comment|/*  *  *  UTILITIES for use by tests.  *  */
end_comment

begin_comment
comment|/*  * Check whether platform supports symlinks.  This is intended  * for tests to use in deciding whether to bother testing symlink  * support; if the platform doesn't support symlinks, there's no point  * in checking whether the program being tested can create them.  *  * Note that the first time this test is called, we actually go out to  * disk to create and verify a symlink.  This is necessary because  * symlink support is actually a property of a particular filesystem  * and can thus vary between directories on a single system.  After  * the first call, this returns the cached result from memory, so it's  * safe to call it as often as you wish.  */
end_comment

begin_function
name|int
name|canSymlink
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Remember the test result */
specifier|static
name|int
name|value
init|=
literal|0
decl_stmt|,
name|tested
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tested
condition|)
return|return
operator|(
name|value
operator|)
return|;
operator|++
name|tested
expr_stmt|;
name|assertion_make_file
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"canSymlink.0"
argument_list|,
literal|0644
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|/* Note: Cygwin has its own symlink() emulation that does not 	 * use the Win32 CreateSymbolicLink() function. */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|value
operator|=
name|my_CreateSymbolicLinkA
argument_list|(
literal|"canSymlink.1"
argument_list|,
literal|"canSymlink.0"
argument_list|,
literal|0
argument_list|)
operator|&&
name|is_symlink
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"canSymlink.1"
argument_list|,
literal|"canSymlink.0"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|HAVE_SYMLINK
name|value
operator|=
operator|(
literal|0
operator|==
name|symlink
argument_list|(
literal|"canSymlink.0"
argument_list|,
literal|"canSymlink.1"
argument_list|)
operator|)
operator|&&
name|is_symlink
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"canSymlink.1"
argument_list|,
literal|"canSymlink.0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the gzip program?  */
end_comment

begin_comment
comment|/* Platform-dependent options for hiding the output of a subcommand. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redirectArgs
init|=
literal|">NUL 2>NUL"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Win32 cmd.exe */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redirectArgs
init|=
literal|">/dev/null 2>/dev/null"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* POSIX 'sh' */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|canGzip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"gzip -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the gunzip program?  */
end_comment

begin_function
name|int
name|canGunzip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"gunzip -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sleep as needed; useful for verifying disk timestamp changes by  * ensuring that the wall-clock time has actually changed before we  * go back to re-read something from disk.  */
end_comment

begin_function
name|void
name|sleepUntilAfter
parameter_list|(
name|time_t
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|>=
name|time
argument_list|(
name|NULL
argument_list|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|Sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
else|#
directive|else
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Call standard system() call, but build up the command line using  * sprintf() conventions.  */
end_comment

begin_function
name|int
name|systemf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buff
index|[
literal|8192
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|r
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>
name|VERBOSITY_FULL
condition|)
name|logprintf
argument_list|(
literal|"Cmd: %s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|r
operator|=
name|system
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slurp a file into memory for ease of comparison and testing.  * Returns size of file in 'sizep' if non-NULL, null-terminates  * data in memory for ease of use.  */
end_comment

begin_function
name|char
modifier|*
name|slurpfile
parameter_list|(
name|size_t
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|filename
index|[
literal|8192
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|r
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|filename
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* Note: No error; non-existent file is okay here. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|r
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't stat file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't allocate %ld bytes of memory to read file %s\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|st
operator|.
name|st_size
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bytes_read
operator|=
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
name|st
operator|.
name|st_size
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't read file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
index|[
name|st
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a uuencoded file from the reference directory, decode, and  * write the result into the current directory. */
end_comment

begin_define
define|#
directive|define
name|UUDECODE
parameter_list|(
name|c
parameter_list|)
value|(((c) - 0x20)& 0x3f)
end_define

begin_function
name|void
name|extract_reference_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s.uu"
argument_list|,
name|refdir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|buff
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Couldn't open reference file %s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|in
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return;
comment|/* Read up to and including the 'begin' line. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* TODO: This is a failure. */
return|return;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buff
argument_list|,
literal|"begin "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Now, decode the rest and write it. */
comment|/* Not a lot of error checking here; the input better be right. */
name|out
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|buff
decl_stmt|;
name|int
name|bytes
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buff
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|bytes
operator|=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Write out 1-3 bytes from that. */
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|fputc
argument_list|(
name|n
operator|>>
literal|16
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|n
operator|&
literal|0xFF
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|is_LargeInode
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|BY_HANDLE_FILE_INFORMATION
name|bhfi
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|file
argument_list|,
operator|&
name|bhfi
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|bhfi
operator|.
name|nFileIndexHigh
operator|&
literal|0x0000FFFFUL
operator|)
return|;
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
name|int64_t
name|ino
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ino
operator|=
operator|(
name|int64_t
operator|)
name|st
operator|.
name|st_ino
expr_stmt|;
return|return
operator|(
name|ino
operator|>
literal|0xffffffff
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *  * TEST management  *  */
end_comment

begin_comment
comment|/*  * "list.h" is simply created by "grep DEFINE_TEST test_*.c"; it has  * a line like  *      DEFINE_TEST(test_function)  * for each test.  */
end_comment

begin_comment
comment|/* Use "list.h" to declare all of the test functions. */
end_comment

begin_undef
undef|#
directive|undef
name|DEFINE_TEST
end_undef

begin_define
define|#
directive|define
name|DEFINE_TEST
parameter_list|(
name|name
parameter_list|)
value|void name(void);
end_define

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_comment
comment|/* Use "list.h" to create a list of all tests (functions and names). */
end_comment

begin_undef
undef|#
directive|undef
name|DEFINE_TEST
end_undef

begin_define
define|#
directive|define
name|DEFINE_TEST
parameter_list|(
name|n
parameter_list|)
value|{ n, #n, 0 },
end_define

begin_struct
struct|struct
block|{
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|failures
decl_stmt|;
block|}
name|tests
index|[]
init|=
block|{
include|#
directive|include
file|"list.h"
block|}
struct|;
end_struct

begin_comment
comment|/*  * Summarize repeated failures in the just-completed test.  */
end_comment

begin_function
specifier|static
name|void
name|test_summarize
parameter_list|(
name|int
name|failed
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|VERBOSITY_SUMMARY_ONLY
case|:
name|printf
argument_list|(
name|failed
condition|?
literal|"E"
else|:
literal|"."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERBOSITY_PASSFAIL
case|:
name|printf
argument_list|(
name|failed
condition|?
literal|"FAIL\n"
else|:
literal|"ok\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|log_console
operator|=
operator|(
name|verbosity
operator|==
name|VERBOSITY_LIGHT_REPORT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|failed_lines
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|failed_lines
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|failed_lines
index|[
name|i
index|]
operator|.
name|count
operator|>
literal|1
operator|&&
operator|!
name|failed_lines
index|[
name|i
index|]
operator|.
name|skip
condition|)
name|logprintf
argument_list|(
literal|"%s:%d: Summary: Failed %d times\n"
argument_list|,
name|failed_filename
argument_list|,
name|i
argument_list|,
name|failed_lines
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the failure history for the next file. */
name|failed_filename
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|failed_lines
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|failed_lines
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Actually run a single test, with appropriate setup and cleanup.  */
end_comment

begin_function
specifier|static
name|int
name|test_run
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir
parameter_list|)
block|{
name|char
name|workdir
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|logfilename
index|[
literal|64
index|]
decl_stmt|;
name|int
name|failures_before
init|=
name|failures
decl_stmt|;
name|int
name|oldumask
decl_stmt|;
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|VERBOSITY_SUMMARY_ONLY
case|:
comment|/* No per-test reports at all */
break|break;
case|case
name|VERBOSITY_PASSFAIL
case|:
comment|/* rest of line will include ok/FAIL marker */
name|printf
argument_list|(
literal|"%3d: %-50s"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Title of test, details will follow */
name|printf
argument_list|(
literal|"%3d: %s\n"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Chdir to the top-level work directory. */
if|if
condition|(
operator|!
name|assertChdir
argument_list|(
name|tmpdir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Can't chdir to top work dir %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create a log file for this test. */
name|sprintf
argument_list|(
name|logfilename
argument_list|,
literal|"%s.log"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s\n\n"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Chdir() to a work dir for this specific test. */
name|snprintf
argument_list|(
name|workdir
argument_list|,
sizeof|sizeof
argument_list|(
name|workdir
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|tmpdir
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|testworkdir
operator|=
name|workdir
expr_stmt|;
if|if
condition|(
operator|!
name|assertMakeDir
argument_list|(
name|testworkdir
argument_list|,
literal|0755
argument_list|)
operator|||
operator|!
name|assertChdir
argument_list|(
name|testworkdir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Can't chdir to work dir %s\n"
argument_list|,
name|testworkdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Explicitly reset the locale before each test. */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
comment|/* Record the umask before we run the test. */
name|umask
argument_list|(
name|oldumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Run the actual test. 	 */
operator|(
operator|*
name|tests
index|[
name|i
index|]
operator|.
name|func
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* 	 * Clean up and report afterwards. 	 */
name|testworkdir
operator|=
name|NULL
expr_stmt|;
comment|/* Restore umask */
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
comment|/* Reset locale. */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
comment|/* Reset directory. */
if|if
condition|(
operator|!
name|assertChdir
argument_list|(
name|tmpdir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Couldn't chdir to temp dir %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Report per-test summaries. */
name|tests
index|[
name|i
index|]
operator|.
name|failures
operator|=
name|failures
operator|-
name|failures_before
expr_stmt|;
name|test_summarize
argument_list|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
argument_list|)
expr_stmt|;
comment|/* Close the per-test log file. */
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|NULL
expr_stmt|;
comment|/* If there were no failures, we can remove the work dir and logfile. */
if|if
condition|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|keep_temp_files
operator|&&
name|assertChdir
argument_list|(
name|tmpdir
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Make sure not to leave empty directories. 			 * Sometimes a processing of closing files used by tests 			 * is not done, then rmdir will be failed and it will 			 * leave a empty test directory. So we should wait a few 			 * seconds and retry rmdir. */
name|int
name|r
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|10
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|>
literal|0
condition|)
name|Sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|r
operator|=
name|systemf
argument_list|(
literal|"rmdir /S /Q %s"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
break|break;
block|}
name|systemf
argument_list|(
literal|"del %s"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
else|#
directive|else
name|systemf
argument_list|(
literal|"rm -rf %s"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|systemf
argument_list|(
literal|"rm %s"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Return appropriate status. */
return|return
operator|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  *  * MAIN and support routines.  *  *  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|program
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|limit
init|=
sizeof|sizeof
argument_list|(
name|tests
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tests
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Usage: %s [options]<test><test> ...\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Default is to run all tests.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Otherwise, specify the numbers of the tests you wish to run.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -d  Dump core after any failure, for debugging.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -k  Keep all temp files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Default: temp files for successful tests deleted.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROGRAM
name|printf
argument_list|(
literal|"  -p<path>  Path to executable to be tested.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Default: path taken from "
name|ENVBASE
literal|" environment variable.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  -q  Quiet.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -r<dir>   Path to dir containing reference files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Default: Current directory.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -u  Keep running specifies tests until one fails.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -v  Verbose.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Available tests:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  %d: %s\n"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_refdir
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|)
block|{
name|char
name|tried
index|[
literal|512
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|char
name|buff
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* If a dir was specified, try that */
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|pwd
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Get the current dir. */
ifdef|#
directive|ifdef
name|PATH_MAX
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Solaris getcwd needs the size. */
else|#
directive|else
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for a known file. */
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s/test"
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LIBRARY
argument_list|)
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s/%s/test"
argument_list|,
name|pwd
argument_list|,
name|LIBRARY
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s/%s/test"
argument_list|,
name|pwd
argument_list|,
name|PROGRAM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PROGRAM_ALIAS
argument_list|)
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s/%s/test"
argument_list|,
name|pwd
argument_list|,
name|PROGRAM_ALIAS
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|memcmp
argument_list|(
name|pwd
argument_list|,
literal|"/usr/obj"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|pwd
operator|+
literal|8
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%s/test"
argument_list|,
name|pwd
operator|+
literal|8
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tried
argument_list|)
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
name|printf
argument_list|(
literal|"Unable to locate known reference file %s\n"
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Checked following directories:\n%s\n"
argument_list|,
name|tried
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|DebugBreak
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|success
label|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|buff
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|limit
init|=
sizeof|sizeof
argument_list|(
name|tests
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tests
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|tests_run
init|=
literal|0
decl_stmt|,
name|tests_failed
init|=
literal|0
decl_stmt|,
name|option
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|refdir_alloc
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
modifier|*
name|saved_argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|option_arg
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|tmpdir
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|testprogdir
decl_stmt|,
modifier|*
name|tmp2
init|=
name|NULL
decl_stmt|;
name|char
name|tmpdir_timestamp
index|[
literal|256
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|argc
expr_stmt|;
comment|/* UNUSED */
comment|/* Get the current dir. */
ifdef|#
directive|ifdef
name|PATH_MAX
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Solaris getcwd needs the size. */
else|#
directive|else
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CrtSetReportMode
argument_list|)
comment|/* To stop to run the default invalid parameter handler. */
name|_set_invalid_parameter_handler
argument_list|(
name|invalid_parameter_handler
argument_list|)
expr_stmt|;
comment|/* Disable annoying assertion message box. */
name|_CrtSetReportMode
argument_list|(
name|_CRT_ASSERT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Name of this program, used to build root of our temp directory 	 * tree. 	 */
name|progname
operator|=
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|testprogdir
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|progname
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|testprogdir
argument_list|,
name|progname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Support \ or / dir separators for Windows compat. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|progname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|testprogdir
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|testprogdir
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
comment|/* Fixup path for relative directories. */
if|if
condition|(
operator|(
name|testprogdir
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|testprogdir
argument_list|,
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|testprogdir
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|testprogdir
operator|+
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|+
literal|1
argument_list|,
name|testprogdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|testprogdir
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|testprogdir
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROGRAM
comment|/* Get the target program from environment, if available. */
name|testprogfile
operator|=
name|getenv
argument_list|(
name|ENVBASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"TEMPDIR"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TEMPDIR"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
literal|"/tmp"
expr_stmt|;
comment|/* Allow -d to be controlled through the environment. */
if|if
condition|(
name|getenv
argument_list|(
name|ENVBASE
literal|"_DEBUG"
argument_list|)
operator|!=
name|NULL
condition|)
name|dump_on_failure
operator|=
literal|1
expr_stmt|;
comment|/* Get the directory holding test files from environment. */
name|refdir
operator|=
name|getenv
argument_list|(
name|ENVBASE
literal|"_TEST_FILES"
argument_list|)
expr_stmt|;
comment|/* 	 * Parse options, without using getopt(), which isn't available 	 * on all platforms. 	 */
operator|++
name|argv
expr_stmt|;
comment|/* Skip program name */
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|!=
literal|'-'
condition|)
break|break;
name|p
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|++
name|p
expr_stmt|;
comment|/* Skip '-' */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|option
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|option_arg
operator|=
name|NULL
expr_stmt|;
comment|/* If 'opt' takes an argument, parse that. */
if|if
condition|(
name|option
operator|==
literal|'p'
operator|||
name|option
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|option_arg
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Option -%c requires argument.\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
block|}
else|else
name|option_arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
comment|/* End of this option word. */
block|}
comment|/* Now, handle the option. */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'d'
case|:
name|dump_on_failure
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keep_temp_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
ifdef|#
directive|ifdef
name|PROGRAM
name|testprogfile
operator|=
name|option_arg
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-p option not permitted\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'q'
case|:
name|verbosity
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|refdir
operator|=
name|option_arg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|until_failure
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbosity
operator|++
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized option '%c'\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Sanity-check that our options make sense. 	 */
ifdef|#
directive|ifdef
name|PROGRAM
if|if
condition|(
name|testprogfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tmp2
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|testprogdir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|PROGRAM
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp2
argument_list|,
name|testprogdir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp2
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp2
argument_list|,
name|PROGRAM
argument_list|)
expr_stmt|;
name|testprogfile
operator|=
name|tmp2
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|testprg
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Command.com sometimes rejects '/' separators. */
name|testprg
operator|=
name|strdup
argument_list|(
name|testprogfile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|testprg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|testprg
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|testprg
index|[
name|i
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
name|testprogfile
operator|=
name|testprg
expr_stmt|;
endif|#
directive|endif
comment|/* Quote the name that gets put into shell command lines. */
name|testprg
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|testprogfile
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|testprg
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|testprg
argument_list|,
name|testprogfile
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|testprg
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|testprog
operator|=
name|testprg
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
block|{
comment|/* Ignore SIGPIPE signals */
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Create a temp directory for the following tests. 	 * Include the time the tests started as part of the name, 	 * to make it easier to track the results of multiple tests. 	 */
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|strftime
argument_list|(
name|tmpdir_timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpdir_timestamp
argument_list|)
argument_list|,
literal|"%Y-%m-%dT%H.%M.%S"
argument_list|,
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpdir
argument_list|,
literal|"%s/%s.%s-%03d"
argument_list|,
name|tmp
argument_list|,
name|progname
argument_list|,
name|tmpdir_timestamp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertMakeDir
argument_list|(
name|tmpdir
argument_list|,
literal|0755
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|999
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Unable to create temp directory %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the user didn't specify a directory for locating 	 * reference files, try to find the reference files in 	 * the "usual places." 	 */
name|refdir
operator|=
name|refdir_alloc
operator|=
name|get_refdir
argument_list|(
name|refdir
argument_list|)
expr_stmt|;
comment|/* 	 * Banner with basic information. 	 */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If tests fail or crash, details will be in:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>
name|VERBOSITY_SUMMARY_ONLY
condition|)
block|{
name|printf
argument_list|(
literal|"Reference files will be read from: %s\n"
argument_list|,
name|refdir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROGRAM
name|printf
argument_list|(
literal|"Running tests on: %s\n"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Exercising: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|EXTRA_VERSION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Running "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Run some or all of the individual tests. 	 */
name|saved_argv
operator|=
name|argv
expr_stmt|;
do|do
block|{
name|argv
operator|=
name|saved_argv
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
block|{
comment|/* Default: Run all tests. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|tests_run
operator|++
expr_stmt|;
if|if
condition|(
name|test_run
argument_list|(
name|i
argument_list|,
name|tmpdir
argument_list|)
condition|)
block|{
name|tests_failed
operator|++
expr_stmt|;
if|if
condition|(
name|until_failure
condition|)
goto|goto
name|finish
goto|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|(
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|argv
operator|<=
literal|'9'
condition|)
block|{
name|char
modifier|*
name|vp
init|=
operator|*
name|argv
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|>=
literal|'0'
operator|&&
operator|*
name|vp
operator|<=
literal|'9'
condition|)
block|{
name|start
operator|*=
literal|10
expr_stmt|;
name|start
operator|+=
operator|*
name|vp
operator|-
literal|'0'
expr_stmt|;
operator|++
name|vp
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|vp
operator|==
literal|'\0'
condition|)
block|{
name|end
operator|=
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|vp
operator|==
literal|'-'
condition|)
block|{
operator|++
name|vp
expr_stmt|;
if|if
condition|(
operator|*
name|vp
operator|==
literal|'\0'
condition|)
block|{
name|end
operator|=
name|limit
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|>=
literal|'0'
operator|&&
operator|*
name|vp
operator|<=
literal|'9'
condition|)
block|{
name|end
operator|*=
literal|10
expr_stmt|;
name|end
operator|+=
operator|*
name|vp
operator|-
literal|'0'
expr_stmt|;
operator|++
name|vp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"*** INVALID Test %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refdir_alloc
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|end
operator|>=
name|limit
operator|||
name|start
operator|>
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"*** INVALID Test %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refdir_alloc
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|start
operator|=
literal|0
init|;
name|start
operator|<
name|limit
condition|;
operator|++
name|start
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|tests
index|[
name|start
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|limit
condition|)
block|{
name|printf
argument_list|(
literal|"*** INVALID Test ``%s''\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refdir_alloc
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
comment|/* usage() never returns */
block|}
block|}
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
name|tests_run
operator|++
expr_stmt|;
if|if
condition|(
name|test_run
argument_list|(
name|start
argument_list|,
name|tmpdir
argument_list|)
condition|)
block|{
name|tests_failed
operator|++
expr_stmt|;
if|if
condition|(
name|until_failure
condition|)
goto|goto
name|finish
goto|;
block|}
operator|++
name|start
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|until_failure
condition|)
do|;
name|finish
label|:
comment|/* Must be freed after all tests run */
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|testprogdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
comment|/* 	 * Report summary statistics. 	 */
if|if
condition|(
name|verbosity
operator|>
name|VERBOSITY_SUMMARY_ONLY
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Totals:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tests run:         %8d\n"
argument_list|,
name|tests_run
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tests failed:      %8d\n"
argument_list|,
name|tests_failed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Assertions checked:%8d\n"
argument_list|,
name|assertions
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Assertions failed: %8d\n"
argument_list|,
name|failures
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Skips reported:    %8d\n"
argument_list|,
name|skips
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failures
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failing tests:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
condition|)
name|printf
argument_list|(
literal|"  %d: %s (%d failures)\n"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|failures
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Details for failing tests: %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSITY_SUMMARY_ONLY
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d tests passed, no failures\n"
argument_list|,
name|tests_run
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|refdir_alloc
argument_list|)
expr_stmt|;
comment|/* If the final tmpdir is empty, we can remove it. */
comment|/* This should be the usual case when all tests succeed. */
name|assertChdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|rmdir
argument_list|(
name|tmpdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|tests_failed
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

