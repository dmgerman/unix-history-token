begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)chgbars.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Derived from original program by A. Dain Samples.  *   * The program chgbars will accept the output from a diff comparison of  * two versions of a file.  It will then read the new version of the file  * and insert the appropriate troff commands to put change bars in the  * right margin. Typing 'chgbars' without any arguments will give you  * some documentation and an example.  *   * Caveat: If you make a change inside an equation or table, the  * preprocessors eqn and tbl may not like what chgbars does to the file.  * You may have to go into the output from chgbars to remove or rearrange  * some of the lines of the form '.mc |  \"open' or '.mc  \"close' in  * order to get through tbl or eqn.  *   * Unfortunately, users of RCS will be disappointed: one cannot use rcsdiff.  * Rcsdiff compares the files in the wrong order.  *   * There is a relatively easy way to do the job with the tools sed and awk.  * However, sed does not allow enough commands to process large documents.  * In the true spirit of a filter/tool, chgbars is limited only by the  * amount of memory on the machine, and is fast and useful.  *   * The modifications necessary are outlined:  *   * FORM OF DIFF OUTPUT	COMMENT			NEW SED COMMANDS  * ================================================================  * 100a			means those lines	100a\\  * L1			were deleted from	.mc |\\  * L2			oldfile			.mc  * :  * Ln  * .  * ----------------------------------------------------------------  * 100c			  * L1		  * L2	  * :   * Ln						  * .  *	means that line 100 in newfile replaced all those lines in oldfile.  *		100a  *		.mc  *		99 a  *		.mc |  * ----------------------------------------------------------------  * 100d			that line was added	100a\\  *			to oldfile		.mc  *						99a\\  *						.mc |  * ----------------------------------------------------------------  * 100,200d		those lines were	200a\\  *			added to oldfile		.mc  *						99a\\  *						.mc |  * ----------------------------------------------------------------  * 100,200c		  * L1		  * L2	  * :  * Ln  * .  *	means lines 100 to 200 of newfile replaced all the following lines  *	in oldfile.  *		200a  *		.mc  *		99a  *		.mc |  * ----------------------------------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|dbg
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
comment|/* fprintf(stderr,"s\n") */
end_comment

begin_define
define|#
directive|define
name|none
value|0
end_define

begin_define
define|#
directive|define
name|open
value|1
end_define

begin_define
define|#
directive|define
name|close
value|2
end_define

begin_define
define|#
directive|define
name|both
value|3
end_define

begin_expr_stmt
name|char
argument_list|(
operator|*
name|action
argument_list|)
index|[]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|file1
decl_stmt|,
modifier|*
name|file2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|linebuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nextch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num1
decl_stmt|,
name|num2
decl_stmt|,
name|t
decl_stmt|,
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lineact
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1986 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* open $1 */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|file1
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|file1
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: can't open %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * read each entry setting the appropriate entry in action[] 	 * 	 * get the first line number: since diff -e puts the numbers out 	 * in reverse order, this tells us how big to make the file 	 */
name|readline
argument_list|()
expr_stmt|;
if|if
condition|(
name|lineact
operator|==
literal|'a'
condition|)
name|t
operator|=
name|num1
expr_stmt|;
else|else
name|t
operator|=
name|num2
expr_stmt|;
name|action
operator|=
operator|(
name|char
argument_list|(
operator|*
argument_list|)
index|[]
operator|)
name|malloc
argument_list|(
name|t
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|action
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|none
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file1
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineact
operator|==
literal|'a'
condition|)
block|{
operator|(
operator|*
name|action
operator|)
index|[
name|num1
index|]
operator|=
name|both
expr_stmt|;
name|skiptilldot
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|action
operator|)
index|[
name|num1
operator|-
literal|1
index|]
operator|=
name|open
expr_stmt|;
operator|(
operator|*
name|action
operator|)
index|[
name|num2
index|]
operator|=
name|close
expr_stmt|;
if|if
condition|(
name|lineact
operator|==
literal|'c'
condition|)
name|skiptilldot
argument_list|()
expr_stmt|;
else|else
name|skiptilleol
argument_list|()
expr_stmt|;
block|}
name|readline
argument_list|()
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file1
argument_list|)
expr_stmt|;
comment|/* open $2 */
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|file2
operator|=
name|stdin
expr_stmt|;
else|else
name|file2
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file2
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open %2\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file2
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
name|linebuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<=
name|t
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|action
operator|)
index|[
name|line
index|]
condition|)
block|{
case|case
name|open
case|:
name|printf
argument_list|(
literal|".mc |   \\\"open\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|close
case|:
name|printf
argument_list|(
literal|".mc     \\\"close\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|both
case|:
name|printf
argument_list|(
literal|".mc |   \\\"both\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".mc\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|<=
name|t
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"oops: number of lines read does not match\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"number of lines expected\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tchgbars diff.out\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\treads the output from diff, and expects the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\tfile to be modified on stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tchgbars diff.out file.tbm\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\tboth the output from diff and the file to be\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\tmodified are stated explicitly\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tchgbars - file.tbm\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\treads the output from diff on stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nE.g.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"diff -b -e newfile oldfile | chgbars - newfile | vtroff -ms\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t(note the order of the files in the diff command!)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nBe forewarned: chgbars does not know about tables or equations.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"If any part of a table or equation is changed, chgbars will insert the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".mc commands, whether tbl or eqn likes it or not.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This means that you may have to do some hand editing of the output of\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chgbars to make it acceptable to one or both of these preprocessors.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|readnum
argument_list|()
end_macro

begin_block
block|{
name|int
name|num
decl_stmt|;
name|dbg
argument_list|(
name|readnum
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
name|nextch
operator|=
name|getc
argument_list|(
name|file1
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|nextch
argument_list|)
condition|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
name|nextch
operator|-
literal|'0'
expr_stmt|;
name|nextch
operator|=
name|getc
argument_list|(
name|file1
argument_list|)
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_block

begin_macro
name|readline
argument_list|()
end_macro

begin_block
block|{
name|dbg
argument_list|(
name|readline
argument_list|)
expr_stmt|;
name|num1
operator|=
name|readnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextch
operator|==
literal|','
condition|)
name|num2
operator|=
name|readnum
argument_list|()
expr_stmt|;
else|else
name|num2
operator|=
name|num1
expr_stmt|;
name|lineact
operator|=
name|nextch
expr_stmt|;
block|}
end_block

begin_macro
name|skiptilleol
argument_list|()
end_macro

begin_block
block|{
name|dbg
argument_list|(
name|skiptilleol
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextch
operator|!=
literal|'\n'
condition|)
name|nextch
operator|=
name|getc
argument_list|(
name|file1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|skiptilldot
argument_list|()
end_macro

begin_block
block|{
name|dbg
argument_list|(
name|skiptilldot
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
argument_list|,
name|file1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error reading file1\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
literal|".\n"
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
end_block

end_unit

