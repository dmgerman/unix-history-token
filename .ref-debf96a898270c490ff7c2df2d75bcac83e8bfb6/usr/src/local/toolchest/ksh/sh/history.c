begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)history.c	1.1 */
end_comment

begin_comment
comment|/*  *   History file manipulation routines  *  *   David Korn  *   AT&T Bell Laboratories  *   Room 5D-112  *   Murray Hill, N. J. 07974  *   Tel. x7975  *  */
end_comment

begin_comment
comment|/*  * Each command in the history file starts on an even byte is null terminated.  * The first byte must contain the special character H_UNDO and the second  * byte is the version number.  The sequence H_UNDO 0, following a command,  * nullifies the previous command. A six byte sequence starting with  * H_CMDNO is used to store the command number so that it is not necessary  * to read the file from beginning to end to get to the last block of  * commands.  This format of this sequence is different in version 1  * then in version 0.  Version 1 allows commands to use the full 8 bit  * character set.  It can understand version 0 format files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_include
include|#
directive|include
file|"national.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

begin_function_decl
name|int
name|hist_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hist_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|hist_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hist_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hist_cancel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hist_eof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|histloc
name|hist_find
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ESH
end_ifdef

begin_function_decl
name|histloc
name|hist_locate
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ESH */
end_comment

begin_function_decl
name|long
name|hist_position
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_function_decl
name|void
name|hist_subst
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|aeval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|chkrdwr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|create
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|frenumber
value|hist_rename
end_define

begin_define
define|#
directive|define
name|tmp_open
parameter_list|(
name|s
parameter_list|)
value|tmpfile()
end_define

begin_define
define|#
directive|define
name|p_str
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
value|(fputs(s,stderr),putc(c,stderr))
end_define

begin_define
define|#
directive|define
name|closefd
parameter_list|(
name|f
parameter_list|)
value|fclose(f)
end_define

begin_define
define|#
directive|define
name|aeval
parameter_list|(
name|str
parameter_list|)
value|atoi(str)
end_define

begin_define
define|#
directive|define
name|TMPSIZ
value|20
end_define

begin_define
define|#
directive|define
name|NL
value|'\n'
end_define

begin_define
define|#
directive|define
name|output
value|stderr
end_define

begin_decl_stmt
name|struct
name|fixcmd
modifier|*
name|fc_fix
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|hist_rename
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|login_sh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|histfname
init|=
literal|"./history"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|unknown
value|"unknown"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|substitute
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|tmp_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|fixmask
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hist_trim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hist_nearend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hist_check
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|hist_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|heof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * open the history file  * if HISTNAME is not given and userid==0 then no history file.  * if login_sh and HISTFILE is longer than HISTMAX bytes then it is  * cleaned up.  */
end_comment

begin_function
name|int
name|hist_open
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|histname
decl_stmt|;
name|char
name|fname
index|[
name|TMPSIZ
index|]
decl_stmt|;
name|char
name|hname
index|[
literal|256
index|]
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|long
name|hsize
init|=
literal|0
decl_stmt|;
name|int
name|his_start
decl_stmt|;
if|if
condition|(
name|fc_fix
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|histname
operator|=
name|valup
argument_list|(
name|HISTFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|histname
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|KSHELL
if|if
condition|(
name|userid
operator|==
literal|0
operator|&&
name|login_sh
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* KSHELL */
name|cp
operator|=
name|movstr
argument_list|(
name|valup
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|hname
argument_list|)
expr_stmt|;
name|movstr
argument_list|(
name|histfname
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|histname
operator|=
name|hname
expr_stmt|;
block|}
operator|*
name|fname
operator|=
literal|0
expr_stmt|;
name|retry
label|:
comment|/* first try to open the current file */
ifdef|#
directive|ifdef
name|KSHELL
if|if
condition|(
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
name|histname
argument_list|,
literal|012
argument_list|)
argument_list|,
literal|"a+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* if you can't then try to create it */
if|if
condition|(
name|fd
operator|=
name|create
argument_list|(
name|histname
argument_list|)
condition|)
block|{
name|fd
operator|=
name|chkrdwr
argument_list|(
name|histname
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|histname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|hsize
operator|=
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fd
operator|=
name|fopen
argument_list|(
name|histname
argument_list|,
literal|"a+"
argument_list|)
condition|)
block|{
name|chmod
argument_list|(
name|histname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|hsize
operator|=
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KSHELL */
comment|/* make sure that file has history file format */
if|if
condition|(
name|hsize
operator|&&
name|hist_check
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|histname
argument_list|)
expr_stmt|;
name|hsize
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|fd
operator|=
name|tmp_open
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fd
operator|=
name|frenumber
argument_list|(
name|fd
argument_list|,
name|FCIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|valup
argument_list|(
name|HISTSIZE
argument_list|)
condition|)
name|maxlines
operator|=
operator|(
name|unsigned
operator|)
name|aeval
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
name|maxlines
operator|=
name|HIS_DFLT
expr_stmt|;
for|for
control|(
name|fixmask
operator|=
literal|16
init|;
name|fixmask
operator|<=
name|maxlines
condition|;
name|fixmask
operator|<<=
literal|1
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
operator|(
expr|struct
name|fixcmd
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fixcmd
argument_list|)
operator|+
operator|(
operator|--
name|fixmask
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fc_fix
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|fixfd
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|fixmax
operator|=
name|maxlines
expr_stmt|;
name|setbuf
argument_list|(
name|fd
argument_list|,
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fixind
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|fixline
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fixcmds
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|fp
operator|->
name|fixcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|hsize
operator|==
literal|0
condition|)
block|{
comment|/* put special characters at front of file */
name|putc
argument_list|(
name|H_UNDO
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|H_VERSION
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* initialize history list */
if|if
condition|(
name|hsize
condition|)
block|{
name|int
name|nlines
init|=
name|maxlines
decl_stmt|;
name|long
name|size
init|=
name|hsize
operator|-
operator|(
name|HISMAX
operator|/
literal|4
operator|)
decl_stmt|;
do|do
block|{
name|size
operator|-=
operator|(
operator|(
name|HISMAX
operator|/
literal|4
operator|)
operator|+
name|nlines
operator|*
name|HISLINE
operator|)
expr_stmt|;
name|his_start
operator|=
name|fp
operator|->
name|fixind
operator|=
name|hist_nearend
argument_list|(
name|fd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hist_eof
argument_list|()
expr_stmt|;
name|nlines
operator|=
name|maxlines
operator|-
operator|(
name|fp
operator|->
name|fixind
operator|-
name|his_start
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|his_start
operator|>
literal|1
operator|&&
name|nlines
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|fname
condition|)
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|login_sh
operator|&&
name|his_start
operator|>
literal|1
operator|&&
name|hsize
operator|>
name|HISMAX
condition|)
block|{
name|FILE
modifier|*
name|fdo
decl_stmt|;
if|if
condition|(
operator|(
name|fdo
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
name|histname
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unlink
argument_list|(
name|histname
argument_list|)
expr_stmt|;
name|hist_trim
argument_list|(
name|fdo
argument_list|,
name|fp
operator|->
name|fixind
operator|-
name|maxlines
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check history file format to see if it begins with special byte  */
end_comment

begin_function
specifier|static
name|int
name|hist_check
parameter_list|(
name|fd
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
name|setbuf
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getc
argument_list|(
name|fd
argument_list|)
operator|!=
name|H_UNDO
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hist_version
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy the last<n> commands to a new file and make this the history file  */
end_comment

begin_function
specifier|static
name|void
name|hist_trim
parameter_list|(
name|fdo
parameter_list|,
name|n
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fdo
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
name|struct
name|fixcmd
modifier|*
name|fsave
decl_stmt|;
comment|/* use the old history I/O buffer for fdo */
name|setbuf
argument_list|(
name|fdo
argument_list|,
name|fp
operator|->
name|fixfd
operator|->
name|_base
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fc_fix
operator|=
literal|0
expr_stmt|;
name|hist_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|fc_fix
operator|==
literal|0
condition|)
return|return;
name|fsave
operator|=
name|fc_fix
expr_stmt|;
name|fd
operator|=
name|fc_fix
operator|->
name|fixfd
expr_stmt|;
do|do
block|{
name|fc_fix
operator|=
name|fp
expr_stmt|;
name|fseek
argument_list|(
name|fdo
argument_list|,
name|hist_position
argument_list|(
operator|++
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fc_fix
operator|=
name|fsave
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fdo
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KSHELL
name|states
operator||=
name|FIXFLG
expr_stmt|;
endif|#
directive|endif
comment|/* KSHELL */
name|hist_flush
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|EOF
condition|)
do|;
name|fclose
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fdo
operator|->
name|_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * position history file at size and find next command number   */
end_comment

begin_function
specifier|static
name|int
name|hist_nearend
parameter_list|(
name|fd
parameter_list|,
name|size
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|state
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
goto|goto
name|begin
goto|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip to numbered command and return the number */
comment|/* numbering commands occur after a null and begin with H_CMDNO */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|state
operator|==
literal|5
condition|)
block|{
return|return
operator|(
name|n
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|==
literal|1
condition|)
block|{
comment|/* see if H_CMDNO is followed by 0 */
if|if
condition|(
name|hist_version
operator|&&
name|c
condition|)
block|{
name|n
operator|+=
literal|2
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hist_version
condition|)
name|n
operator|=
operator|(
name|n
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|<
literal|3
condition|)
name|n
operator|=
operator|(
name|n
operator|<<
literal|7
operator|)
operator|+
operator|(
name|c
operator|&
literal|0177
operator|)
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|0
operator|&&
name|c
operator|==
name|H_CMDNO
condition|)
block|{
name|fc_fix
operator|->
name|fixcnt
operator|=
name|size
operator|+
name|n
operator|+
literal|6
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
operator|(
name|c
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|begin
label|:
name|fseek
argument_list|(
name|fd
argument_list|,
literal|2L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fc_fix
operator|->
name|fixcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine unlinks the history file if the file is a temp file  */
end_comment

begin_function
name|void
name|hist_close
parameter_list|()
block|{
if|if
condition|(
name|fc_fix
condition|)
name|fclose
argument_list|(
name|fc_fix
operator|->
name|fixfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine reads the history file from the present position  * to the end-of-file and puts the information in the in-core  * history table  * Note that H_CMDNO is only recognized at the beginning of a command  * and that H_UNDO as the first character of a command is skipped  * unless it is followed by 0.  If followed by 0 then it cancels  * the previous command.  */
end_comment

begin_function
name|void
name|hist_eof
parameter_list|()
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|incr
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|oldc
init|=
literal|0
decl_stmt|;
specifier|register
name|long
name|count
init|=
name|fp
operator|->
name|fixcnt
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|heof
operator|++
expr_stmt|;
comment|/* don't add line number markers */
name|fseek
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|skip
operator|--
operator|>
literal|0
condition|)
block|{
name|oldc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|oldc
operator|==
name|H_CMDNO
operator|&&
name|incr
operator|==
literal|0
condition|)
name|skip
operator|=
literal|3
expr_stmt|;
name|fp
operator|->
name|fixind
operator|+=
name|incr
expr_stmt|;
name|fp
operator|->
name|fixcmds
index|[
name|fp
operator|->
name|fixind
operator|&
name|fixmask
index|]
operator|=
name|count
expr_stmt|;
name|incr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|H_CMDNO
condition|)
block|{
comment|/* old format history file */
if|if
condition|(
name|hist_version
operator|==
literal|0
condition|)
name|skip
operator|=
literal|4
expr_stmt|;
name|incr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|H_UNDO
condition|)
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|incr
operator|=
literal|1
expr_stmt|;
name|oldc
operator|=
name|c
expr_stmt|;
block|}
name|fp
operator|->
name|fixline
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fixcnt
operator|=
name|count
expr_stmt|;
name|heof
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine will cause the previous command to be cancelled  */
end_comment

begin_function
name|void
name|hist_cancel
parameter_list|()
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
name|fd
operator|=
name|fp
operator|->
name|fixfd
expr_stmt|;
name|putc
argument_list|(
name|H_UNDO
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fixcnt
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
operator|(
operator|--
name|fp
operator|->
name|fixind
operator|)
operator|&
name|fixmask
expr_stmt|;
name|fp
operator|->
name|fixcmds
index|[
name|c
index|]
operator|=
name|fp
operator|->
name|fixcnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine adds one or two null bytes and flushes the history buffer  */
end_comment

begin_function
name|void
name|hist_flush
parameter_list|()
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|KSHELL
if|if
condition|(
operator|(
name|states
operator|&
name|FIXFLG
operator|)
operator|==
literal|0
condition|)
return|return;
name|states
operator|&=
operator|~
name|FIXFLG
expr_stmt|;
endif|#
directive|endif
comment|/* KSHELL */
name|fd
operator|=
name|fp
operator|->
name|fixfd
expr_stmt|;
name|fp
operator|->
name|fixline
operator|=
literal|0
expr_stmt|;
comment|/* remove whitespace from end of commands */
while|while
condition|(
operator|--
name|fd
operator|->
name|_ptr
operator|>=
name|fd
operator|->
name|_base
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|fd
operator|->
name|_ptr
operator|)
operator|!=
name|NL
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
name|fd
operator|->
name|_cnt
operator|=
operator|++
name|fd
operator|->
name|_ptr
operator|-
name|fd
operator|->
name|_base
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|_cnt
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|fixind
operator|--
expr_stmt|;
goto|goto
name|set_count
goto|;
block|}
name|putc
argument_list|(
name|NL
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|set_count
label|:
name|fp
operator|->
name|fixcnt
operator|=
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* start each command on an even byte boundary */
if|if
condition|(
name|fp
operator|->
name|fixcnt
operator|&
literal|01
condition|)
block|{
name|fp
operator|->
name|fixcnt
operator|++
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|(
operator|++
name|fp
operator|->
name|fixind
operator|)
operator|&
name|fixmask
expr_stmt|;
name|fp
operator|->
name|fixcmds
index|[
name|c
index|]
operator|=
name|fp
operator|->
name|fixcnt
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|fp
operator|->
name|fixcmds
index|[
name|c
index|]
operator|)
operator|>
operator|(
name|HISMAX
operator|/
literal|4
operator|)
operator|&&
operator|!
name|heof
condition|)
block|{
comment|/* put line number in file */
name|fp
operator|->
name|fixcnt
operator|+=
literal|6
expr_stmt|;
name|putc
argument_list|(
name|H_CMDNO
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|fp
operator|->
name|fixind
operator|>>
literal|16
operator|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|fp
operator|->
name|fixind
operator|>>
literal|8
operator|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|c
operator|=
name|fp
operator|->
name|fixind
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fixcmds
index|[
name|c
operator|&
name|fixmask
index|]
operator|=
name|fp
operator|->
name|fixcnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * return byte offset in history file for command<n>  */
end_comment

begin_function
name|long
name|hist_position
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
return|return
operator|(
name|fp
operator|->
name|fixcmds
index|[
name|n
operator|&
name|fixmask
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write the command starting at offset<offset> onto file<fd>.  * listing stops when character<last> is encountered or end-of-string.  * each new-line character is replaced with string<nl>.  */
end_comment

begin_function
name|long
name|hist_list
parameter_list|(
name|offset
parameter_list|,
name|last
parameter_list|,
name|nl
parameter_list|)
name|long
name|offset
decl_stmt|;
name|int
name|last
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
block|{
specifier|register
name|int
name|oldc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|p_str
argument_list|(
name|unknown
argument_list|,
name|NL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fd
operator|=
name|fc_fix
operator|->
name|fixfd
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oldc
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|++
init|;
name|oldc
operator|&&
name|oldc
operator|!=
name|last
condition|;
name|oldc
operator|=
name|c
operator|,
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|offset
operator|)
return|;
if|if
condition|(
name|oldc
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
condition|)
block|{
name|fputs
argument_list|(
name|nl
argument_list|,
name|output
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* don't print trailing newline for job control */
elseif|else
if|if
condition|(
name|last
operator|==
literal|'&'
condition|)
return|return
operator|(
name|offset
operator|)
return|;
block|}
name|putc
argument_list|(
name|oldc
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find index for last line with given string  * If flag==0 then line must begin with string  * direction< 1 for backwards search */
end_comment

begin_function
name|histloc
name|hist_find
parameter_list|(
name|string
parameter_list|,
name|index1
parameter_list|,
name|flag
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|index1
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|index2
decl_stmt|;
name|histloc
name|location
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|location
operator|.
name|his_command
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
name|location
operator|)
return|;
name|index2
operator|=
name|fp
operator|->
name|fixind
expr_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
block|{
name|index2
operator|-=
name|fp
operator|->
name|fixmax
expr_stmt|;
if|if
condition|(
name|index2
operator|<
literal|1
condition|)
name|index2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|index1
operator|<=
name|index2
condition|)
return|return
operator|(
name|location
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|index1
operator|>=
name|index2
condition|)
return|return
operator|(
name|location
operator|)
return|;
while|while
condition|(
name|index1
operator|!=
name|index2
condition|)
block|{
name|direction
operator|>
literal|0
condition|?
operator|++
name|index1
else|:
operator|--
name|index1
expr_stmt|;
name|offset
operator|=
name|hist_position
argument_list|(
name|index1
argument_list|)
expr_stmt|;
name|location
operator|.
name|his_line
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|KSHELL
comment|/* allow a search to be aborted */
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KSHELL */
do|do
block|{
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
name|fseek
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
name|offset
expr_stmt|;
block|}
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
comment|/* always position at character boundary */
if|if
condition|(
operator|--
name|nbytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|string
condition|)
block|{
name|cp
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|nbytes
operator|=
name|echarset
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|in_csize
argument_list|(
name|nbytes
argument_list|)
operator|+
operator|(
name|nbytes
operator|>=
literal|2
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|location
operator|.
name|his_line
operator|++
expr_stmt|;
comment|/* save earliest possible matching character */
if|if
condition|(
name|flag
operator|&&
name|c
operator|==
operator|*
name|string
operator|&&
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
name|c
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
comment|/* match found */
block|{
name|location
operator|.
name|his_command
operator|=
name|index1
expr_stmt|;
return|return
operator|(
name|location
operator|)
return|;
block|}
block|}
do|while
condition|(
name|flag
operator|&&
name|c
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
block|}
name|fseek
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|location
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ESH
operator|||
name|VSH
end_if

begin_comment
comment|/*  * copy command<command> from history file to s1  * at most MAXLINE characters copied  * if s1==0 the number of lines for the command is returned  * line=linenumber  for emacs copy and only this line of command will be copied  * line< 0 for full command copy  * -1 returned if there is no history file  */
end_comment

begin_function
name|int
name|hist_copy
parameter_list|(
name|s1
parameter_list|,
name|command
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1max
init|=
name|s1
operator|+
name|MAXLINE
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|offset
operator|=
name|hist_position
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|)
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|count
operator|++
operator|==
name|line
condition|)
break|break;
elseif|else
if|if
condition|(
name|line
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|s1
operator|&&
operator|(
name|line
operator|<
literal|0
operator|||
name|line
operator|==
name|count
operator|)
condition|)
block|{
if|if
condition|(
name|s1
operator|>=
name|s1max
condition|)
block|{
operator|*
operator|--
name|s1
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|s1
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s1
operator|==
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
name|s1
operator|-
literal|1
operator|)
operator|)
operator|==
literal|'\n'
condition|)
name|s1
operator|--
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
name|fseek
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return word number<word> from command number<command>  */
end_comment

begin_function
name|char
modifier|*
name|hist_word
parameter_list|(
name|s1
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|s1
decl_stmt|;
specifier|register
name|int
name|flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fc_fix
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|KSHELL
return|return
operator|(
name|lastarg
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
comment|/* KSHELL */
name|hist_copy
argument_list|(
name|s1
argument_list|,
name|fc_fix
operator|->
name|fixind
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|c
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
name|isspace
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|flag
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|word
operator|==
literal|0
condition|)
break|break;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|flag
operator|==
literal|0
condition|)
block|{
name|s1
operator|=
name|cp
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|s1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ESH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ESH
end_ifdef

begin_comment
comment|/*  * given the current command and line number,  * and number of lines back or foward,  * compute the new command and line number.  */
end_comment

begin_function
name|histloc
name|hist_locate
parameter_list|(
name|command
parameter_list|,
name|line
parameter_list|,
name|lines
parameter_list|)
specifier|register
name|int
name|command
decl_stmt|;
specifier|register
name|int
name|line
decl_stmt|;
name|int
name|lines
decl_stmt|;
block|{
name|histloc
name|next
decl_stmt|;
name|line
operator|+=
name|lines
expr_stmt|;
if|if
condition|(
name|fc_fix
operator|==
name|NULL
condition|)
block|{
name|command
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|lines
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|count
decl_stmt|;
while|while
condition|(
name|command
operator|<=
name|fc_fix
operator|->
name|fixind
condition|)
block|{
name|count
operator|=
name|hist_copy
argument_list|(
name|NIL
argument_list|,
name|command
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|line
condition|)
goto|goto
name|done
goto|;
name|line
operator|-=
name|count
expr_stmt|;
name|command
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|int
name|least
init|=
name|fc_fix
operator|->
name|fixind
operator|-
name|fc_fix
operator|->
name|fixmax
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|line
operator|>=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|--
name|command
operator|<
name|least
condition|)
break|break;
name|line
operator|+=
name|hist_copy
argument_list|(
name|NIL
argument_list|,
name|command
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|command
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|next
operator|.
name|his_command
operator|=
name|command
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
name|done
label|:
name|next
operator|.
name|his_line
operator|=
name|line
expr_stmt|;
name|next
operator|.
name|his_command
operator|=
name|command
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ESH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_comment
comment|/*  * given a file containing a command and a string of the form old=new,  * execute the command with the string old replaced by new  */
end_comment

begin_function
name|void
name|hist_subst
parameter_list|(
name|command
parameter_list|,
name|fd
parameter_list|,
name|replace
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|replace
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|new
init|=
name|replace
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
init|=
name|locstak
argument_list|()
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
while|while
condition|(
operator|*
operator|++
name|new
operator|!=
literal|'='
condition|)
empty_stmt|;
comment|/* skip to '=' */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
name|string
operator|=
name|endstak
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|*
name|new
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|substitute
argument_list|(
name|string
argument_list|,
name|replace
argument_list|,
name|new
argument_list|,
operator|(
name|sp
operator|=
name|locstak
argument_list|()
operator|)
argument_list|)
condition|)
name|endstak
argument_list|(
name|sp
operator|+
name|strlen
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|failed
argument_list|(
name|command
argument_list|,
name|badsub
argument_list|)
expr_stmt|;
operator|*
operator|(
name|new
operator|-
literal|1
operator|)
operator|=
literal|'='
expr_stmt|;
name|fputs
argument_list|(
name|sp
argument_list|,
name|fc_fix
operator|->
name|fixfd
argument_list|)
expr_stmt|;
name|hist_flush
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|sp
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|execexp
argument_list|(
name|sp
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

end_unit

