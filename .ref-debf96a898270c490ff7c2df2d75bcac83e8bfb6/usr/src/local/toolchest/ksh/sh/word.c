begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)word.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
specifier|static
name|jmp_buf
name|readerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nreadc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_decl_stmt
specifier|static
name|int
name|letflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEBLK
name|a_fb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
name|a_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This module defines the following routines */
end_comment

begin_function_decl
name|char
modifier|*
name|match_paren
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|nextc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|readc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|word
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This module references these external routines */
end_comment

begin_function_decl
specifier|extern
name|void
name|arg_clear
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chktrap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chkpr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|findnod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|synbad
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|tilde
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ========	character handling for command lines	========*/
end_comment

begin_comment
comment|/*  * Get the next word and put it on the top of the stak  * Determine the type of word and set wdnum and wdset accordingly  * Returns the token type  */
end_comment

begin_macro
name|word
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|argp
decl_stmt|;
specifier|register
name|char
modifier|*
name|tildp
decl_stmt|;
name|char
name|not_alias
decl_stmt|;
name|char
name|chk_keywd
decl_stmt|;
name|int
name|alpha
init|=
literal|0
decl_stmt|;
name|wdnum
operator|=
literal|0
expr_stmt|;
comment|/* condition needed to check for keywords, name=value */
name|chk_keywd
operator|=
name|reserv
operator|!=
literal|0
operator|||
operator|(
name|wdset
operator|&
name|KEYFLG
operator|)
expr_stmt|;
name|wdset
operator|&=
operator|~
name|KEYFLG
expr_stmt|;
name|wdarg
operator|=
operator|(
name|ARGPTR
operator|)
name|locstak
argument_list|()
expr_stmt|;
name|argp
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
if|if
condition|(
name|letflg
condition|)
block|{
name|letflg
operator|=
literal|0
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
operator|(
name|DQUOTE
operator|)
expr_stmt|;
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
name|LPAREN
argument_list|,
name|RPAREN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|argp
operator|-
literal|1
operator|)
operator|=
operator|(
name|DQUOTE
operator|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
name|wdval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
block|{
name|stakbot
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
name|cpystak
argument_list|(
name|let_syntax
argument_list|)
expr_stmt|;
name|synbad
argument_list|()
expr_stmt|;
block|}
name|endstak
argument_list|(
operator|--
name|argp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tildp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|nextc
argument_list|()
operator|,
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|COMCHAR
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|readc
argument_list|()
operator|)
operator|!=
name|NL
operator|&&
name|c
operator|!=
name|ENDOF
condition|)
empty_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
block|}
else|else
comment|/* out of comment - white isspace loop */
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'~'
condition|)
name|tildp
operator|=
name|argp
expr_stmt|;
name|not_alias
operator|=
operator|(
name|aliflg
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ismeta
argument_list|(
name|c
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
name|c
operator|==
name|LITERAL
condition|)
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|argp
operator|==
name|wdarg
operator|->
name|argval
operator|&&
name|chk_keywd
operator|&&
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|alpha
operator|++
expr_stmt|;
block|}
operator|*
name|argp
operator|++
operator|=
operator|(
name|c
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
operator|*
name|argp
operator|++
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
literal|'['
argument_list|,
literal|']'
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|wdset
operator||=
name|KEYFLG
expr_stmt|;
name|tildp
operator|=
name|argp
expr_stmt|;
name|alpha
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
name|alpha
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qotchar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|DOLLAR
operator|&&
name|c
operator|==
name|LPAREN
condition|)
block|{
name|subflag
operator|++
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
name|c
expr_stmt|;
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
name|LPAREN
argument_list|,
name|RPAREN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tildp
operator|!=
name|NULL
operator|&&
operator|(
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|':'
operator|||
name|ismeta
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
comment|/* check for tilde expansion */
specifier|register
name|char
modifier|*
name|dir
decl_stmt|;
operator|*
name|argp
operator|=
literal|0
expr_stmt|;
name|staktop
operator|=
name|argp
expr_stmt|;
name|dir
operator|=
name|tilde
argument_list|(
name|tildp
argument_list|)
expr_stmt|;
comment|/* This check needed if tilde() uses malloc() */
ifndef|#
directive|ifndef
name|INT16
if|if
condition|(
name|stakbot
operator|!=
operator|(
name|STKPTR
operator|)
name|wdarg
condition|)
block|{
name|tildp
operator|+=
operator|(
operator|(
name|char
operator|*
operator|)
name|staktop
operator|-
name|argp
operator|)
expr_stmt|;
name|argp
operator|=
name|staktop
expr_stmt|;
name|wdarg
operator|=
operator|(
name|ARGPTR
operator|)
name|stakbot
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*INT16 */
if|if
condition|(
name|dir
condition|)
block|{
name|argp
operator|=
name|tildp
expr_stmt|;
name|argp
operator|=
name|movstr
argument_list|(
name|dir
argument_list|,
name|argp
argument_list|)
expr_stmt|;
block|}
else|else
name|tildp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|(
name|wdset
operator|&
name|KEYFLG
operator|)
condition|)
name|tildp
operator|=
name|argp
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ismeta
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|argp
operator|=
name|endstak
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|peekn
operator|=
name|c
operator||
name|MARK
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ARGPTR
operator|)
name|argp
operator|)
operator|->
name|argval
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|(
name|d
operator|=
operator|(
operator|(
name|ARGPTR
operator|)
name|argp
operator|)
operator|->
name|argval
index|[
literal|0
index|]
operator|,
name|isdigit
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'>'
operator|||
name|c
operator|==
literal|'<'
operator|)
condition|)
block|{
name|word
argument_list|()
expr_stmt|;
name|wdnum
operator|=
name|d
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
comment|/*check for reserved words and aliases */
name|wdval
operator|=
operator|(
name|reserv
operator|!=
literal|0
condition|?
name|syslook
argument_list|(
operator|(
operator|(
name|ARGPTR
operator|)
name|argp
operator|)
operator|->
name|argval
argument_list|,
name|reserved
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* for unity database software, allow select to be aliased */
if|if
condition|(
operator|(
name|reserv
operator|!=
literal|0
operator|&&
operator|(
name|wdval
operator|==
literal|0
operator|||
name|wdval
operator|==
name|SELSYM
operator|)
operator|)
operator|||
operator|(
name|wdset
operator|&
name|S_FLAG
operator|)
condition|)
block|{
comment|/* check for aliases */
name|NAMPTR
name|np
decl_stmt|;
name|char
modifier|*
name|alp
init|=
operator|(
operator|(
name|ARGPTR
operator|)
name|argp
operator|)
operator|->
name|argval
decl_stmt|;
if|if
condition|(
name|not_alias
operator|&&
operator|(
name|wdset
operator|&
operator|(
name|E_FLAG
operator||
name|KEYFLG
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|np
operator|=
name|findnod
argument_list|(
name|alp
argument_list|,
name|alias
argument_list|,
name|CHK_FOR
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|T_FLAG
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|alp
operator|=
name|valup
argument_list|(
name|np
argument_list|)
operator|)
condition|)
block|{
name|wdval
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|standin
operator|->
name|flin
expr_stmt|;
name|push
argument_list|(
operator|&
name|a_fb
argument_list|)
expr_stmt|;
name|estabf
argument_list|(
name|alp
argument_list|,
operator|&
name|a_fd
argument_list|)
expr_stmt|;
name|a_fb
operator|.
name|flin
operator|=
name|c
expr_stmt|;
name|aliflg
operator|=
name|peekn
expr_stmt|;
name|peekn
operator|=
literal|0
expr_stmt|;
name|wdset
operator||=
name|KEYFLG
expr_stmt|;
name|c
operator|=
name|word
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|dipchar
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|nextc
argument_list|()
operator|)
operator|==
name|c
condition|)
block|{
name|wdval
operator|=
name|c
operator||
name|SYMREP
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|nextc
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
name|wdnum
operator||=
name|IOSTRIP
expr_stmt|;
else|else
name|peekn
operator|=
name|d
operator||
name|MARK
expr_stmt|;
block|}
comment|/* arithmetic evaluation ((expr)) */
elseif|else
if|if
condition|(
name|c
operator|==
name|LPAREN
operator|&&
name|reserv
operator|!=
literal|0
condition|)
block|{
name|wdval
operator|=
literal|0
expr_stmt|;
name|letflg
operator|=
literal|1
expr_stmt|;
name|argp
operator|=
name|endstak
argument_list|(
name|movstr
argument_list|(
name|blet
argument_list|,
name|argp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'|'
operator|&&
name|d
operator|==
literal|'&'
condition|)
name|wdval
operator|=
name|COOPSYM
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFD
elseif|else
if|if
condition|(
name|d
operator|==
name|LPAREN
operator|&&
operator|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'>'
operator|)
condition|)
name|wdval
operator|=
operator|(
name|c
operator|==
literal|'>'
condition|?
name|OPROC
else|:
name|IPROC
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFD */
else|else
block|{
name|peekn
operator|=
name|d
operator||
name|MARK
expr_stmt|;
name|wdval
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|wdval
operator|=
name|c
operator|)
operator|==
name|ENDOF
condition|)
block|{
name|wdval
operator|=
name|EOFSYM
expr_stmt|;
block|}
if|if
condition|(
name|iopend
operator|&&
name|eolchar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|copy
argument_list|(
name|iopend
argument_list|)
expr_stmt|;
name|iopend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reserv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|wdval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * skip until matching<closed>  * if flag> 0, then newlines and spaces are removed  * if flag< 0, then each newline cause syntax errors  */
end_comment

begin_function
name|char
modifier|*
name|match_paren
parameter_list|(
name|argp
parameter_list|,
name|open
parameter_list|,
name|close
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|char
modifier|*
name|argp
decl_stmt|;
specifier|register
name|int
name|open
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|int
name|was_dollar
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|oldargp
init|=
name|argp
decl_stmt|;
name|int
name|line
init|=
name|standin
operator|->
name|flin
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
comment|/* check for unmatched<open> */
if|if
condition|(
operator|(
name|c
operator|=
operator|(
name|open
operator|==
name|LITERAL
condition|?
name|readc
argument_list|()
else|:
name|nextc
argument_list|()
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* eof before matching quote */
comment|/* This keeps old shell scripts running */
if|if
condition|(
name|fileno
argument_list|(
name|input
argument_list|)
operator|==
name|F_STRING
condition|)
break|break;
name|standin
operator|->
name|flin
operator|=
name|line
expr_stmt|;
name|wdval
operator|=
name|open
operator||
name|EOFSYM
expr_stmt|;
name|synbad
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NL
condition|)
block|{
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
break|break;
name|chkpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|close
condition|)
block|{
if|if
condition|(
operator|!
name|quoted
condition|)
name|count
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|open
operator|&&
operator|!
name|quoted
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|<=
literal|0
operator|||
name|c
operator|!=
name|SP
condition|)
block|{
if|if
condition|(
name|open
operator|==
name|LITERAL
condition|)
operator|*
name|argp
operator|++
operator|=
name|ESCAPE
expr_stmt|;
if|if
condition|(
name|argp
operator|>=
operator|(
name|char
operator|*
operator|)
name|brkend
condition|)
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|open
operator|==
name|LITERAL
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|quoted
operator|&&
name|flag
operator|==
literal|0
condition|)
block|{
comment|/* check for nested '', "", and `` within $() */
if|if
condition|(
name|open
operator|!=
name|close
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|LITERAL
condition|)
name|argp
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|qotchar
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* check for $() within '', "", and `` */
elseif|else
if|if
condition|(
name|was_dollar
operator|&&
name|c
operator|==
name|LPAREN
condition|)
block|{
name|argp
operator|=
name|match_paren
argument_list|(
name|argp
argument_list|,
name|LPAREN
argument_list|,
name|RPAREN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|was_dollar
operator|=
operator|(
name|c
operator|==
name|DOLLAR
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
name|quoted
operator|=
literal|1
operator|-
name|quoted
expr_stmt|;
else|else
name|quoted
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|open
operator|==
name|LITERAL
condition|)
block|{
name|argp
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|argp
operator|==
name|oldargp
condition|)
block|{
comment|/* handle null argument specially */
operator|*
name|argp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
block|}
return|return
operator|(
name|argp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If quote is equal to zero then  * this routine returns the next input character but strips shell  * line continuations and issues prompts at end of line  * Otherwise this routine is the same as readc()  */
end_comment

begin_macro
name|nextc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
specifier|static
name|int
name|oldd
decl_stmt|;
name|retry
label|:
name|d
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|ESCAPE
operator|&&
name|oldd
operator|!=
name|ESCAPE
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|readc
argument_list|()
operator|)
operator|==
name|NL
condition|)
block|{
name|chkpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|peekc
operator|=
name|c
operator||
name|MARK
expr_stmt|;
block|}
name|oldd
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_block

begin_macro
name|readc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|SHFILE
name|f
init|=
name|standin
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
init|=
name|input
decl_stmt|;
name|int
name|maxtry
init|=
literal|20
decl_stmt|;
if|if
condition|(
name|staktop
operator|>=
name|brkend
condition|)
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|peekn
condition|)
block|{
name|c
operator|=
name|peekn
operator|&
operator|~
name|MARK
expr_stmt|;
name|peekn
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|peekc
condition|)
block|{
name|c
operator|=
name|peekc
operator|&
operator|~
name|MARK
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|retry
label|:
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|states
operator|&
name|READC
condition|)
name|nreadc
operator|++
expr_stmt|;
else|else
block|{
name|nreadc
operator|=
literal|1
expr_stmt|;
name|states
operator||=
name|READC
expr_stmt|;
block|}
comment|/* this is needed to implement Bourne shell semantics of traps */
comment|/* reads automatically restart with jobs library */
if|if
condition|(
name|fd
operator|->
name|_cnt
operator|==
literal|0
operator|&&
name|setjmp
argument_list|(
name|readerr
argument_list|)
condition|)
goto|goto
name|trapfound
goto|;
endif|#
directive|endif
comment|/* BSD */
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|feval
operator|&&
name|estabf
argument_list|(
operator|*
name|f
operator|->
name|feval
operator|++
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
name|SP
expr_stmt|;
comment|/* treat the NULL byte as eof for TMPIO */
elseif|else
if|if
condition|(
name|fileno
argument_list|(
name|fd
argument_list|)
operator|==
name|TMPIO
condition|)
block|{
name|setbuf
argument_list|(
name|fd
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|TMPIO
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* skip over null bytes in files */
elseif|else
if|if
condition|(
name|fileno
argument_list|(
name|fd
argument_list|)
operator|!=
name|F_STRING
condition|)
goto|goto
name|retry
goto|;
elseif|else
if|if
condition|(
name|aliflg
condition|)
block|{
name|c
operator|=
operator|(
name|aliflg
operator|&
operator|~
name|MARK
operator|)
expr_stmt|;
name|aliflg
operator|=
literal|0
expr_stmt|;
name|wdset
operator||=
name|S_FLAG
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* end-of-string is end-of-file */
block|{
name|f
operator|->
name|feval
operator|=
literal|0
expr_stmt|;
name|estabf
argument_list|(
name|nullstr
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|->
name|_flag
operator||=
name|_IOEOF
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|f
operator|->
name|fstak
operator|==
literal|0
operator|||
operator|(
name|states
operator|&
name|FIXFLG
operator|)
operator|)
operator|&&
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|states
operator|&
name|READPR
operator|)
operator|&&
name|aliflg
operator|==
literal|0
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
operator|(
name|FIXFLG
operator|)
operator|)
operator|&&
name|fileno
argument_list|(
name|fd
argument_list|)
operator|!=
name|F_STRING
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fc_fix
operator|->
name|fixfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NL
condition|)
name|f
operator|->
name|flin
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|fd
operator|->
name|_flag
operator||=
name|_IOEOF
expr_stmt|;
name|c
operator|=
name|ENDOF
expr_stmt|;
block|}
else|else
block|{
name|clearerr
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
block|{
name|newline
argument_list|()
expr_stmt|;
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|trapnote
operator|&
name|TRAPSET
operator|)
operator|&&
operator|(
name|states
operator|&
name|RWAIT
operator|)
condition|)
block|{
name|trapfound
label|:
name|newline
argument_list|()
expr_stmt|;
name|chktrap
argument_list|()
expr_stmt|;
name|arg_clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|maxtry
operator|>
literal|0
condition|)
goto|goto
name|retry
goto|;
else|else
name|fd
operator|->
name|_flag
operator||=
name|_IOERR
expr_stmt|;
name|c
operator|=
name|ENDOF
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
operator|--
name|nreadc
operator|<=
literal|0
condition|)
name|states
operator|&=
operator|~
name|READC
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
endif|#
directive|endif
comment|/* JOBS */
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_comment
comment|/*  * This routine is here because signals behave differently with sigset  */
end_comment

begin_macro
name|interrupt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fd
init|=
name|input
decl_stmt|;
name|clearerr
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
block|{
name|newline
argument_list|()
expr_stmt|;
name|trapnote
operator|=
literal|0
expr_stmt|;
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|trapnote
operator|&
name|TRAPSET
operator|)
operator|&&
operator|(
name|states
operator|&
name|RWAIT
operator|)
condition|)
name|longjmp
argument_list|(
name|readerr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

end_unit

