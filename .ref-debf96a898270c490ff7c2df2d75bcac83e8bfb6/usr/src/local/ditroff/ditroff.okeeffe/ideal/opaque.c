begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"opaque.c	(CWI)	1.1	85/03/01"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ideal.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_function
name|LINEPTR
name|opqact
parameter_list|(
name|opqstmt
parameter_list|,
name|noadtree
parameter_list|,
name|linelist
parameter_list|)
name|STMTPTR
name|opqstmt
decl_stmt|;
name|NOADPTR
name|noadtree
decl_stmt|;
name|LINEPTR
name|linelist
decl_stmt|;
block|{
name|STMTPTR
name|bdstmt
decl_stmt|;
name|LINEPTR
name|inlines
decl_stmt|,
name|outlines
decl_stmt|,
name|both
decl_stmt|;
name|LINENODE
name|nuline
decl_stmt|;
name|LINEPTR
name|prevline
decl_stmt|;
if|if
condition|(
name|when_bug
operator|&
literal|0100
condition|)
name|bug_on
expr_stmt|;
name|prevline
operator|=
operator|&
name|nuline
expr_stmt|;
name|prevline
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|both
operator|=
name|linelist
expr_stmt|;
if|if
condition|(
operator|(
name|bdstmt
operator|=
name|nextstmt
argument_list|(
name|BDLIST
argument_list|,
name|noadtree
operator|->
name|defnode
operator|->
name|parm
operator|->
name|stmtlist
argument_list|)
operator|)
operator|||
operator|(
name|bdstmt
operator|=
name|nextstmt
argument_list|(
name|BDLIST
argument_list|,
name|findbox
argument_list|(
name|noadtree
operator|->
name|defnode
operator|->
name|parm
operator|->
name|name
argument_list|,
name|FALSE
argument_list|)
operator|->
name|stmtlist
argument_list|)
operator|)
condition|)
block|{
name|EDGENODE
name|edgelist
decl_stmt|;
name|EXPRPTR
name|bdwalk
decl_stmt|,
name|lastbd
decl_stmt|;
name|INTLPTR
name|prevtx
decl_stmt|,
name|curvtx
decl_stmt|,
name|postvtx
decl_stmt|;
name|EDGEPTR
name|edgewalk
decl_stmt|;
name|EDGEPTR
name|forfreeing
decl_stmt|;
name|lastbd
operator|=
operator|(
name|EXPRPTR
operator|)
name|tail
argument_list|(
operator|(
name|BOXPTR
operator|)
name|bdstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|lastbd
operator|->
name|next
operator|=
name|exprgen
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|bdstmt
operator|->
name|stmt
operator|)
operator|->
name|expr
argument_list|)
expr_stmt|;
name|edgewalk
operator|=
operator|&
name|edgelist
expr_stmt|;
name|prevtx
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|bdstmt
operator|->
name|stmt
operator|)
operator|->
name|expr
argument_list|,
name|noadtree
argument_list|)
expr_stmt|;
for|for
control|(
name|bdwalk
operator|=
operator|(
operator|(
name|EXPRPTR
operator|)
name|bdstmt
operator|->
name|stmt
operator|)
operator|->
name|next
init|;
name|bdwalk
condition|;
name|bdwalk
operator|=
name|bdwalk
operator|->
name|next
control|)
block|{
name|curvtx
operator|=
name|expreval
argument_list|(
name|bdwalk
operator|->
name|expr
argument_list|,
name|noadtree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|INTLPTR
operator|)
name|bdwalk
operator|->
name|expr
operator|)
operator|->
name|oper
operator|==
literal|'^'
condition|)
block|{
name|bdwalk
operator|=
name|bdwalk
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|bdwalk
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: arc point may not begin boundary specification\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|linelist
operator|)
return|;
block|}
name|postvtx
operator|=
name|expreval
argument_list|(
name|bdwalk
operator|->
name|expr
argument_list|,
name|noadtree
argument_list|)
expr_stmt|;
name|edgewalk
operator|->
name|next
operator|=
name|edgearc
argument_list|(
name|Re
argument_list|(
name|prevtx
argument_list|)
argument_list|,
name|Im
argument_list|(
name|prevtx
argument_list|)
argument_list|,
name|Re
argument_list|(
name|curvtx
argument_list|)
argument_list|,
name|Im
argument_list|(
name|curvtx
argument_list|)
argument_list|,
name|Re
argument_list|(
name|postvtx
argument_list|)
argument_list|,
name|Im
argument_list|(
name|postvtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|postvtx
operator|=
name|curvtx
expr_stmt|;
name|edgewalk
operator|->
name|next
operator|=
name|edgeline
argument_list|(
name|Re
argument_list|(
name|prevtx
argument_list|)
argument_list|,
name|Im
argument_list|(
name|prevtx
argument_list|)
argument_list|,
name|Re
argument_list|(
name|postvtx
argument_list|)
argument_list|,
name|Im
argument_list|(
name|postvtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prevtx
operator|=
name|postvtx
expr_stmt|;
name|edgewalk
operator|=
name|edgewalk
operator|->
name|next
expr_stmt|;
block|}
name|edgewalk
operator|->
name|next
operator|=
name|edgelist
operator|.
name|next
expr_stmt|;
name|lastbd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|opqpoly
argument_list|(
name|edgelist
operator|.
name|next
operator|->
name|next
argument_list|,
name|linelist
argument_list|,
operator|&
name|inlines
argument_list|,
operator|&
name|outlines
argument_list|,
operator|&
name|both
argument_list|)
expr_stmt|;
name|forfreeing
operator|=
name|edgelist
operator|.
name|next
operator|->
name|next
expr_stmt|;
name|edgelist
operator|.
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|linefree
argument_list|(
name|forfreeing
argument_list|)
expr_stmt|;
comment|/* 	} else if (noadtree->defnode->parm->name == lookup ("circle") 		|| noadtree->defnode->parm->name == lookup ("hole")) { 		z0 = varfind (lookup ("center"), noadtree); 		r = varfind (lookup ("radius"), noadtree); 		if (!known (z0) || !known (r)) { 			fprintf (stderr, "ideal: indeterminate opaque circle\n"); 			return (linelist); 		} 		opqcirc ( 			Re(z0), Im(z0), Re(r), 			linelist,&inlines,&outlines,&both 		); 		intlfree (z0); 		intlfree (r); 	} else if (noadtree->defnode->parm->name == lookup ("sector")) { 		z0 = varfind (lookup ("center"), noadtree); 		r = varfind (lookup ("radius"), noadtree); 		z1 = varfind (lookup("start"), noadtree); 		z2 = varfind (lookup ("end"), noadtree); 		t1 = varfind (lookup ("startang"), noadtree); 		t2 = varfind (lookup ("endang"), noadtree); 		if (!known(z0) || !known(r) || !known(z1) || !known(z2)) { 			fprintf (stderr, "ideal: intederminate opaque sector\n"); 				return (linelist); 		} 		opqsect ( 			Re(z0), Im(z0), Re(r), 			Re(z1), Im(z1), 			Re(z2), Im(z2), 			Re(t1), Re(t2), 			linelist,&inlines,&outlines,&both 		); 		intlfree (z0); 		intlfree (r); 		intlfree (z1); 		intlfree (z2); 		intlfree (t1); 		intlfree (t2); 	} else if (noadtree->defnode->parm->name == lookup ("segment")) { 		z0 = varfind (lookup ("center"), noadtree); 		r = varfind (lookup ("radius"), noadtree); 		z1 = varfind (lookup ("start"), noadtree); 		z2 = varfind (lookup ("end"), noadtree); 		if (!known(z0) || !known(r) || !known(z1) || !known(z2)) { 			fprintf (stderr, "ideal: indeterminate opaque segment\n"); 			return (linelist); 		} 		opqseg ( 			Re(z0), Im(z0), Re(r), 			Re(z1), Im(z1), 			Re(z2), Im(z2), 			linelist,&inlines,&outlines,&both 		); 		intlfree (z0); 		intlfree (r); 		intlfree (z1); 		intlfree (z2); */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: no boundary list\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|MISCPTR
operator|)
name|opqstmt
operator|->
name|stmt
operator|)
operator|->
name|info
operator|==
name|INTERIOR
condition|)
block|{
name|prevline
operator|->
name|next
operator|=
name|outlines
expr_stmt|;
name|linefree
argument_list|(
name|inlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevline
operator|->
name|next
operator|=
name|inlines
expr_stmt|;
name|linefree
argument_list|(
name|outlines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|both
condition|)
block|{
while|while
condition|(
name|prevline
operator|->
name|next
condition|)
name|prevline
operator|=
name|prevline
operator|->
name|next
expr_stmt|;
name|prevline
operator|->
name|next
operator|=
name|both
expr_stmt|;
block|}
name|linelist
operator|=
name|lineclean
argument_list|(
name|nuline
operator|.
name|next
argument_list|)
expr_stmt|;
name|bug_off
expr_stmt|;
return|return
operator|(
name|linelist
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opqact */
end_comment

begin_function
name|void
name|opqinsert
parameter_list|(
name|code
parameter_list|,
name|alpha
parameter_list|,
name|opqlist
parameter_list|)
name|int
name|code
decl_stmt|;
name|float
name|alpha
decl_stmt|;
name|OPQPTR
modifier|*
name|opqlist
decl_stmt|;
block|{
name|OPQNODE
name|head
decl_stmt|;
name|OPQPTR
name|walk
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|walk
operator|=
operator|&
name|head
expr_stmt|;
name|walk
operator|->
name|alpha
operator|=
operator|-
name|INFINITY
expr_stmt|;
name|walk
operator|->
name|next
operator|=
operator|*
name|opqlist
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|walk
operator|->
name|next
operator|&&
name|walk
operator|->
name|next
operator|->
name|alpha
operator|<
name|alpha
operator|+
name|EPSILON
condition|)
block|{
name|prev
operator|=
name|walk
expr_stmt|;
name|walk
operator|=
name|walk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|walk
operator|->
name|alpha
operator|<
name|alpha
operator|-
name|EPSILON
condition|)
block|{
name|new
operator|=
name|opqgen
argument_list|(
name|code
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|walk
operator|->
name|next
expr_stmt|;
name|walk
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|walk
operator|->
name|code
operator|==
name|EXT0
operator|||
name|walk
operator|->
name|code
operator|==
name|INFL0
condition|)
if|if
condition|(
name|code
operator|==
name|EXT1
operator|||
name|code
operator|==
name|INFL1
condition|)
block|{
name|walk
operator|->
name|code
operator|=
name|IGNORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|walk
operator|->
name|code
operator|==
name|EXT1
operator|||
name|walk
operator|->
name|code
operator|==
name|INFL1
condition|)
if|if
condition|(
name|code
operator|==
name|EXT0
operator|||
name|code
operator|==
name|INFL0
condition|)
block|{
name|walk
operator|->
name|code
operator|=
name|IGNORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|walk
operator|->
name|code
operator|==
name|SIMPLE
operator|&&
name|code
operator|!=
name|INHERIT
condition|)
name|walk
operator|->
name|code
operator|=
name|code
expr_stmt|;
block|}
operator|*
name|opqlist
operator|=
name|head
operator|.
name|next
expr_stmt|;
block|}
end_function

begin_function
name|LINEPTR
name|lineclean
parameter_list|(
name|linelist
parameter_list|)
name|LINEPTR
name|linelist
decl_stmt|;
block|{
comment|/* clean short lines from linelist */
name|LINEPTR
name|prevline
decl_stmt|,
name|linewalk
decl_stmt|;
name|LINENODE
name|nuhead
decl_stmt|;
name|prevline
operator|=
operator|&
name|nuhead
expr_stmt|;
name|prevline
operator|->
name|next
operator|=
name|linewalk
operator|=
name|linelist
expr_stmt|;
while|while
condition|(
name|linewalk
condition|)
block|{
if|if
condition|(
operator|(
name|linewalk
operator|->
name|kind
operator|==
name|LINE
operator|)
operator|&&
operator|(
name|fabs
argument_list|(
name|linewalk
operator|->
name|x0
operator|-
name|linewalk
operator|->
name|x1
argument_list|)
operator|<
name|EPSILON
operator|)
operator|&&
operator|(
name|fabs
argument_list|(
name|linewalk
operator|->
name|y0
operator|-
name|linewalk
operator|->
name|y1
argument_list|)
operator|<
name|EPSILON
operator|)
condition|)
block|{
name|dprintf
literal|"Removing chopped line\n"
block|)
empty_stmt|;
name|prevline
operator|->
name|next
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|linewalk
argument_list|)
expr_stmt|;
name|linewalk
operator|=
name|prevline
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prevline
operator|=
name|linewalk
expr_stmt|;
name|linewalk
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|linelist
operator|=
name|nuhead
operator|.
name|next
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|linelist
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* /*void tangent (x, y, dx, dy, x1, y1, x2, y2) /*float x, y, dx, dy; /*float *x1, *y1, *x2, *y2; /*{ /*	*x1 = x + dx; /*	*x2 = x - dx; /*	*y1 = y + dy; /*	*y2 = y - dy; /*} */
end_comment

begin_comment
comment|/* /*void halfplane (x1,y1, x2,y2, linelist, inlines, outlines, both) /*float x1, y1, x2, y2; /*LINEPTR linelist; /*LINEPTR *inlines, *outlines, *both; /*{ /*	LINEPTR edges; /*	float perpx, perpy; /*	float ulx, uly, urx, ury, llx, lly, lrx, lry; /*	dprintf "halfplane (%f,%f) (%f,%f)\n", x1, y1, x2, y2); /*	perpx = 10.0*(y1 - y2)/hypot ((x2 - x1), (y2 - y1)); /*	perpy = 10.0*(x2 - x1)/hypot ((x2 - x1), (y2 - y1)); /*	lrx = x1 - 10.0*(x2 - x1); /*	lry = y1 - 10.0*(y2 - y1); /*	urx = x1 + 10.0*(x2 - x1); /*	ury = y1 + 10.0*(y2 - y1); /*	ulx = urx + perpx; /*	uly = ury + perpy; /*	llx = lrx + perpx; /*	lly = lry + perpy; /*	dprintf "perpx %f perpy %f\n", perpx, perpy); /*	if (dbg) /*		fprintf (stderr, "(%f,%f)\n (%f,%f)\n (%f,%f)\n (%f,%f)\n", /*			lrx, lry, /*			urx, ury, /*			ulx, uly, /*			llx, lly /*		); /*	edges = linegen (lrx, lry, urx, ury); /*	edges->next = linegen (urx, ury, ulx, uly); /*	edges->next->next = linegen (ulx, uly, llx, lly); /*	edges->next->next->next = linegen (llx, lly, lrx, lry); /*	edges->next->next->next->next = edges; /*	opqpoly ( /*		edges, /*		linelist, /*		inlines, /*		outlines, /*		both /*	); /*	edges->next->next->next->next = NULL; /*	linefree (edges); /*} */
end_comment

begin_comment
comment|/* /*void triangle (x1,y1, x2,y2, x3,y3, linelist, inlines, outlines, both) /*float x1, y1, x2, y2, x3, y3; /*LINEPTR linelist; /*LINEPTR *inlines, *outlines, *both; /*{ /*	LINEPTR edges; /*	edges = linegen (x1, y1, x2, y2); /*	edges->next = linegen (x2, y2, x3, y3); /*	edges->next->next = linegen (x3, y3, x1, y1); /*	edges->next->next->next = edges; /*	opqpoly ( /*		edges, /*		linelist, /*		inlines, /*		outlines, /*		both /*	); /*	edges->next->next->next = NULL; /*	linefree (edges); /*} */
end_comment

end_unit

