begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_vwind.c	7.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Routines to adjust the window, showing specified lines  * in certain positions on the screen, and scrolling in both  * directions.  Code here is very dependent on mode (open versus visual).  */
end_comment

begin_comment
comment|/*  * Move in a nonlocal way to line addr.  * If it isn't on screen put it in specified context.  * New position for cursor is curs.  * Like most routines here, we vsave().  */
end_comment

begin_expr_stmt
name|vmoveto
argument_list|(
name|addr
argument_list|,
name|curs
argument_list|,
name|context
argument_list|)
specifier|register
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|context
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|markit
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|vjumpto
argument_list|(
name|addr
argument_list|,
name|curs
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Vjumpto is like vmoveto, but doesn't mark previous  * context or save linebuf as current line.  */
end_comment

begin_expr_stmt
name|vjumpto
argument_list|(
name|addr
argument_list|,
name|curs
argument_list|,
name|context
argument_list|)
specifier|register
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|context
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ignore
argument_list|(
name|noteit
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
name|vcontext
argument_list|(
name|addr
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
name|vshow
argument_list|(
name|addr
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|noteit
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Go up or down cnt (negative is up) to new position curs.  */
end_comment

begin_expr_stmt
name|vupdown
argument_list|(
name|cnt
argument_list|,
name|curs
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|curs
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|vdown
argument_list|(
name|cnt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
name|vup
argument_list|(
operator|-
name|cnt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcnt
operator|==
literal|0
condition|)
name|vrepaint
argument_list|(
name|curs
argument_list|)
expr_stmt|;
else|else
name|vnline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Go up cnt lines, afterwards preferring to be ind  * logical lines from the top of the screen.  * If scroll, then we MUST use a scroll.  * Otherwise clear and redraw if motion is far.  */
end_comment

begin_expr_stmt
name|vup
argument_list|(
name|cnt
argument_list|,
name|ind
argument_list|,
name|scroll
argument_list|)
specifier|register
name|int
name|cnt
operator|,
name|ind
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|scroll
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|tot
decl_stmt|;
if|if
condition|(
name|dot
operator|==
name|one
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|vsave
argument_list|()
expr_stmt|;
name|i
operator|=
name|lineDOT
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|i
condition|)
block|{
name|ind
operator|-=
name|cnt
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
name|ind
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scroll
operator|&&
name|cnt
operator|<=
name|vcline
condition|)
block|{
name|vshow
argument_list|(
name|dot
operator|-
name|cnt
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
return|return;
block|}
name|cnt
operator|-=
name|vcline
operator|,
name|dot
operator|-=
name|vcline
operator|,
name|vcline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hold
operator|&
name|HOLDWIG
condition|)
goto|goto
name|contxt
goto|;
if|if
condition|(
name|state
operator|==
name|VISUAL
operator|&&
operator|!
name|AL
operator|&&
operator|!
name|SR
operator|&&
name|cnt
operator|<=
name|WTOP
operator|-
name|ex_ZERO
operator|&&
name|vfit
argument_list|(
name|dot
operator|-
name|cnt
argument_list|,
name|cnt
argument_list|)
operator|<=
name|WTOP
operator|-
name|ex_ZERO
condition|)
goto|goto
name|okr
goto|;
name|tot
operator|=
name|WECHO
operator|-
name|ex_ZERO
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
operator|||
operator|(
operator|!
name|AL
operator|&&
operator|!
name|SR
operator|)
operator|||
operator|(
operator|!
name|scroll
operator|&&
operator|(
name|cnt
operator|>
name|tot
operator|||
name|vfit
argument_list|(
name|dot
operator|-
name|cnt
argument_list|,
name|cnt
argument_list|)
operator|>
name|tot
operator|/
literal|3
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ind
operator|>
name|basWLINES
operator|/
literal|2
condition|)
name|ind
operator|=
name|basWLINES
operator|/
literal|3
expr_stmt|;
name|contxt
label|:
name|vcontext
argument_list|(
name|dot
operator|+
name|ind
operator|-
name|cnt
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
return|return;
block|}
name|okr
label|:
name|vrollR
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scroll
condition|)
block|{
name|vcline
operator|+=
name|ind
operator|,
name|dot
operator|+=
name|ind
expr_stmt|;
if|if
condition|(
name|vcline
operator|>=
name|vcnt
condition|)
name|dot
operator|-=
name|vcline
operator|-
name|vcnt
operator|+
literal|1
operator|,
name|vcline
operator|=
name|vcnt
operator|-
literal|1
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Like vup, but scrolling down.  */
end_comment

begin_expr_stmt
name|vdown
argument_list|(
name|cnt
argument_list|,
name|ind
argument_list|,
name|scroll
argument_list|)
specifier|register
name|int
name|cnt
operator|,
name|ind
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|scroll
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|tot
decl_stmt|;
if|if
condition|(
name|dot
operator|==
name|dol
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|vsave
argument_list|()
expr_stmt|;
name|i
operator|=
name|dol
operator|-
name|dot
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|i
condition|)
block|{
name|ind
operator|-=
name|cnt
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
name|ind
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|=
name|vcnt
operator|-
name|vcline
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|scroll
operator|&&
name|cnt
operator|<=
name|i
condition|)
block|{
name|vshow
argument_list|(
name|dot
operator|+
name|cnt
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
return|return;
block|}
name|cnt
operator|-=
name|i
operator|,
name|dot
operator|+=
name|i
operator|,
name|vcline
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|hold
operator|&
name|HOLDWIG
condition|)
goto|goto
name|dcontxt
goto|;
if|if
condition|(
operator|!
name|scroll
condition|)
block|{
name|tot
operator|=
name|WECHO
operator|-
name|ex_ZERO
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
operator|||
name|cnt
operator|-
name|tot
operator|>
literal|0
operator|||
name|vfit
argument_list|(
name|dot
argument_list|,
name|cnt
argument_list|)
operator|>
name|tot
operator|/
literal|3
operator|+
literal|1
condition|)
block|{
name|dcontxt
label|:
name|vcontext
argument_list|(
name|dot
operator|+
name|cnt
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|vroll
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|VISUAL
operator|&&
name|scroll
condition|)
block|{
name|vcline
operator|-=
name|ind
operator|,
name|dot
operator|-=
name|ind
expr_stmt|;
if|if
condition|(
name|vcline
operator|<
literal|0
condition|)
name|dot
operator|-=
name|vcline
operator|,
name|vcline
operator|=
literal|0
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Show line addr in context where on the screen.  * Work here is in determining new top line implied by  * this placement of line addr, since we always draw from the top.  */
end_comment

begin_expr_stmt
name|vcontext
argument_list|(
name|addr
argument_list|,
name|where
argument_list|)
specifier|register
name|line
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|top
decl_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|top
operator|=
name|addr
expr_stmt|;
else|else
switch|switch
condition|(
name|where
condition|)
block|{
case|case
literal|'^'
case|:
name|addr
operator|=
name|vback
argument_list|(
name|addr
argument_list|,
name|basWLINES
operator|-
name|vdepth
argument_list|()
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'-'
case|:
name|top
operator|=
name|vback
argument_list|(
name|addr
argument_list|,
name|basWLINES
operator|-
name|vdepth
argument_list|()
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|top
operator|=
name|vback
argument_list|(
name|addr
argument_list|,
name|basWLINES
operator|/
literal|2
operator|-
name|vdepth
argument_list|()
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|top
operator|=
name|addr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|==
name|ONEOPEN
operator|&&
name|LINE
argument_list|(
literal|0
argument_list|)
operator|==
name|WBOT
condition|)
name|vup1
argument_list|()
expr_stmt|;
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|CRTOPEN
condition|)
name|vup1
argument_list|()
expr_stmt|;
name|vshow
argument_list|(
name|addr
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get a clean line.  If we are in a hard open  * we may be able to reuse the line we are on  * if it is blank.  This is a real win.  */
end_comment

begin_macro
name|vclean
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|state
operator|!=
name|VISUAL
operator|&&
name|state
operator|!=
name|CRTOPEN
condition|)
block|{
name|destcol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ateopr
argument_list|()
condition|)
name|vup1
argument_list|()
expr_stmt|;
name|vcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Show line addr with the specified top line on the screen.  * Top may be 0; in this case have vcontext compute the top  * (and call us recursively).  Eventually, we clear the screen  * (or its open mode equivalent) and redraw.  */
end_comment

begin_expr_stmt
name|vshow
argument_list|(
name|addr
argument_list|,
name|top
argument_list|)
name|line
operator|*
name|addr
operator|,
operator|*
name|top
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|CBREAK
specifier|register
name|bool
name|fried
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|cnt
init|=
name|addr
operator|-
name|dot
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|vcline
operator|+
name|cnt
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|HARDOPEN
operator|&&
name|state
operator|!=
name|ONEOPEN
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|vcnt
condition|)
block|{
name|dot
operator|=
name|addr
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|vcline
operator|=
name|i
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
name|dot
operator|=
name|addr
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|WBOT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|vcontext
argument_list|(
name|addr
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
return|return;
block|}
name|dot
operator|=
name|top
expr_stmt|;
ifndef|#
directive|ifndef
name|CBREAK
if|if
condition|(
name|vcookit
argument_list|(
literal|2
argument_list|)
condition|)
name|fried
operator|++
operator|,
name|vcook
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|oldhold
operator|=
name|hold
expr_stmt|;
name|hold
operator||=
name|HOLDAT
expr_stmt|;
name|vclear
argument_list|()
expr_stmt|;
name|vreset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vredraw
argument_list|(
name|WTOP
argument_list|)
expr_stmt|;
comment|/* error if vcline>= vcnt ! */
name|vcline
operator|=
name|addr
operator|-
name|top
expr_stmt|;
name|dot
operator|=
name|addr
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
name|vsync
argument_list|(
name|LASTLINE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CBREAK
if|if
condition|(
name|fried
condition|)
name|flusho
argument_list|()
operator|,
name|vraw
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * reset the state.  * If inecho then leave us at the beginning of the echo  * area;  we are called this way in the middle of a :e escape  * from visual, e.g.  */
end_comment

begin_macro
name|vreset
argument_list|(
argument|inecho
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|inecho
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
name|WTOP
operator|=
name|basWTOP
expr_stmt|;
name|WLINES
operator|=
name|basWLINES
expr_stmt|;
if|if
condition|(
name|inecho
condition|)
name|splitw
operator|=
literal|1
operator|,
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Starting from which line preceding tp uses almost (but not more  * than) cnt physical lines?  */
end_comment

begin_function
name|line
modifier|*
name|vback
parameter_list|(
name|tp
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|line
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|int
name|d
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|tp
operator|>
name|one
condition|;
name|tp
operator|--
control|)
block|{
name|getline
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|vdepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|cnt
condition|)
break|break;
name|cnt
operator|-=
name|d
expr_stmt|;
block|}
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * How much scrolling will it take to roll cnt lines starting at tp?  */
end_comment

begin_expr_stmt
name|vfit
argument_list|(
name|tp
argument_list|,
name|cnt
argument_list|)
specifier|register
name|line
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|cnt
operator|--
expr_stmt|;
name|getline
argument_list|(
name|tp
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|j
operator|+=
name|vdepth
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|>
name|dot
condition|)
name|j
operator|-=
name|WBOT
operator|-
name|LASTLINE
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Roll cnt lines onto the screen.  */
end_comment

begin_expr_stmt
name|vroll
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|CBREAK
specifier|register
name|bool
name|fried
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vroll(%d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|hold
operator||=
name|HOLDAT
operator||
name|HOLDROL
expr_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
block|{
name|vcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ONEOPEN
condition|)
name|vup1
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CBREAK
if|if
condition|(
name|vcookit
argument_list|(
name|cnt
argument_list|)
condition|)
name|fried
operator|++
operator|,
name|vcook
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|cnt
operator|>
literal|0
operator|&&
name|Peek_key
operator|!=
name|ATTN
condition|;
name|cnt
operator|--
control|)
block|{
name|dot
operator|++
operator|,
name|vcline
operator|++
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|LASTLINE
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
block|}
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
name|sethard
argument_list|()
expr_stmt|;
name|vsyncCL
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|CBREAK
if|if
condition|(
name|fried
condition|)
name|flusho
argument_list|()
operator|,
name|vraw
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Roll backwards (scroll up).  */
end_comment

begin_expr_stmt
name|vrollR
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vrollR(%d), dot=%d\n"
argument_list|,
name|cnt
argument_list|,
name|lineDOT
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CBREAK
if|if
condition|(
name|vcookit
argument_list|(
name|cnt
argument_list|)
condition|)
name|fried
operator|++
operator|,
name|vcook
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vcnt
operator|=
literal|0
expr_stmt|;
name|heldech
operator|=
literal|0
expr_stmt|;
name|hold
operator||=
name|HOLDAT
operator||
name|HOLDECH
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
operator|&&
name|Peek_key
operator|!=
name|ATTN
condition|;
name|cnt
operator|--
control|)
block|{
name|dot
operator|--
expr_stmt|;
name|vopen
argument_list|(
name|dot
argument_list|,
name|WTOP
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
block|}
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|heldech
condition|)
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vsync
argument_list|(
name|LINE
argument_list|(
name|vcnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CBREAK
if|if
condition|(
name|fried
condition|)
name|flusho
argument_list|()
operator|,
name|vraw
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Go into cooked mode (allow interrupts) during  * a scroll if we are at less than 1200 baud and not  * a 'vi' command, of if we are in a 'vi' command and the  * scroll is more than 2 full screens.  *  * BUG:		An interrupt during a scroll in this way  *		dumps to command mode.  */
end_comment

begin_expr_stmt
name|vcookit
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|cnt
operator|>
literal|1
operator|&&
operator|(
name|ospeed
operator|<
name|B1200
operator|&&
operator|!
name|initev
operator|||
name|cnt
operator|>
name|LINES
operator|*
literal|2
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Determine displayed depth of current line.  */
end_comment

begin_macro
name|vdepth
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|d
decl_stmt|;
name|d
operator|=
operator|(
name|column
argument_list|(
name|NOSTR
argument_list|)
operator|+
name|WCOLS
operator|-
literal|1
operator|+
operator|(
name|Put_char
operator|==
name|listchar
operator|)
operator|+
name|IN
operator|)
operator|/
name|WCOLS
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vdepth returns %d\n"
argument_list|,
name|d
operator|==
literal|0
condition|?
literal|1
else|:
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|d
operator|==
literal|0
condition|?
literal|1
else|:
name|d
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Move onto a new line, with cursor at position curs.  */
end_comment

begin_macro
name|vnline
argument_list|(
argument|curs
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|curs
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|curs
condition|)
name|wcursor
operator|=
name|curs
expr_stmt|;
elseif|else
if|if
condition|(
name|vmoving
condition|)
name|wcursor
operator|=
name|vfindcol
argument_list|(
name|vmovcol
argument_list|)
expr_stmt|;
else|else
name|wcursor
operator|=
name|vskipwh
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|vmove
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

