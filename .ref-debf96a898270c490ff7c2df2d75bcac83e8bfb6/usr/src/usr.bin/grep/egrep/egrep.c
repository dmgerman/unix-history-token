begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)egrep.c	5.12 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*      Hybrid Boyer/Moore/Gosper-assisted 'grep/egrep/fgrep' search, with delta0      table as in original paper (CACM, October, 1977).  No delta1 or delta2.      According to experiment (Horspool, Soft. Prac. Exp., 1982), delta2 is of      minimal practical value.  However, to improve for worst case input,      integrating the improved Galil strategies (Apostolico/Giancarlo, SIAM. J.      Comput., Feb. 1986) deserves consideration.       Method: 	extract longest metacharacter-free string from expression. 		this is done using a side-effect from henry spencer's regcomp(). 		use boyer-moore to match such, then pass submatching lines 		to either regexp() or standard 'egrep', depending on certain 		criteria within execstrategy() below.  [this tradeoff is due 		to the general slowness of the regexp() nondeterministic 		machine on complex expressions, as well as the startup time 		of standard 'egrep' on short files.]  alternatively, one may 		change the vendor-supplied 'egrep' automaton to include 		boyer-moore directly.  see accompanying writeup for discussion 		of kanji expression treatment.  		late addition:  apply trickbag for fast match of simple 		alternations (sublinear, in common low-cardinality cases). 		trap fgrep into this lair.  		gnu additions:  -f, newline as |, \< and \> [in regexec()], more 				comments.  inspire better dfa exec() strategy. 				serious testing and help with special cases.       Algorithm amalgam summary:  		dfa e?grep 		(aho/thompson) 		ndfa regexp() 		(spencer/aho) 		bmg			(boyer/moore/gosper) 		"superimposed" bmg   	(jaw) 		fgrep			(aho/corrasick)  		sorry, but the knuth/morris/pratt machine, horspool's 		"frequentist" code, and the rabin/karp matcher, however cute, 		just don't cut it for this production.       James A. Woods				Copyright (c) 1986      NASA Ames Research Center */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_comment
comment|/* must be henry spencer's version */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (B) : (A))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SLOWSYS
end_ifdef

begin_define
define|#
directive|define
name|read
value|xread
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BUFSIZE
value|8192
end_define

begin_comment
comment|/* make higher for cray */
end_comment

begin_define
define|#
directive|define
name|PATSIZE
value|6000
end_define

begin_define
define|#
directive|define
name|LARGE
value|BUFSIZE + PATSIZE
end_define

begin_define
define|#
directive|define
name|NALT
value|7
end_define

begin_comment
comment|/* tied to scanf() size in alternate() */
end_comment

begin_define
define|#
directive|define
name|NMUSH
value|6
end_define

begin_comment
comment|/* loosely relates to expected alt length */
end_comment

begin_define
define|#
directive|define
name|FIRSTFEW
value|33
end_define

begin_comment
comment|/* Always do FIRSTFEW matches with regexec() */
end_comment

begin_define
define|#
directive|define
name|PUNTPERCENT
value|10
end_define

begin_comment
comment|/* After FIRSTFEW, if PUNTPERCENT of the input 				 * was processed by regexp(), exec std egrep. */
end_comment

begin_define
define|#
directive|define
name|NL
value|'\n'
end_define

begin_define
define|#
directive|define
name|EOS
value|'\0'
end_define

begin_define
define|#
directive|define
name|NONASCII
value|0200
end_define

begin_comment
comment|/* Bit mask for Kanji non-ascii chars */
end_comment

begin_define
define|#
directive|define
name|META
value|"\n^$.[]()?+*|\\"
end_define

begin_comment
comment|/* egrep meta-characters */
end_comment

begin_define
define|#
directive|define
name|SS2
value|'\216'
end_define

begin_comment
comment|/* EUC Katakana (or Chinese2) prefix */
end_comment

begin_define
define|#
directive|define
name|SS3
value|'\217'
end_define

begin_comment
comment|/* EUC Kanji2 (or Chinese3) prefix */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|eflag
decl_stmt|,
name|fflag
decl_stmt|,
name|lflag
decl_stmt|,
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SVID flags */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|,
name|hflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* v7, v8, bsd */
end_comment

begin_decl_stmt
name|int
name|firstflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop at first match */
end_comment

begin_decl_stmt
name|int
name|grepflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called as "grep" */
end_comment

begin_decl_stmt
name|int
name|fgrepflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called as "fgrep" */
end_comment

begin_decl_stmt
name|int
name|altflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple alternation in pattern */
end_comment

begin_decl_stmt
name|int
name|boyonly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* No regexp needed -- all simple */
end_comment

begin_decl_stmt
name|int
name|flushflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|grepold
decl_stmt|,
name|egrepold
decl_stmt|,
name|fgrepold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nalt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of alternatives */
end_comment

begin_decl_stmt
name|int
name|nsuccess
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for match, 2 for error */
end_comment

begin_decl_stmt
name|int
name|altmin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Minimum length of all the alternate 				 * strings */
end_comment

begin_decl_stmt
name|int
name|firstfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv index of first file argument */
end_comment

begin_decl_stmt
name|int
name|patind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv index of pattern */
end_comment

begin_decl_stmt
name|long
name|nmatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of matches in this file */
end_comment

begin_decl_stmt
name|long
name|incount
decl_stmt|,
name|counted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of input consumed */
end_comment

begin_decl_stmt
name|long
name|rxcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bytes of input processed by regexec() */
end_comment

begin_decl_stmt
name|int
name|boyfound
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated partial matches (tripped by 				 * FIRSTFEW) */
end_comment

begin_decl_stmt
name|int
name|prevmatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next three lines aid fast -n */
end_comment

begin_decl_stmt
name|long
name|nline
decl_stmt|,
name|prevnline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prevloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|regexp
modifier|*
name|rspencer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|patboy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pattern for simple Boyer-Moore */
end_comment

begin_decl_stmt
name|char
modifier|*
name|patfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename containing pattern(s) */
end_comment

begin_decl_stmt
name|int
name|delta0
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Boyer-Moore algorithm core */
end_comment

begin_decl_stmt
name|char
name|cmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Usually 0-255, but if -i, maps upper to 				 * lower case */
end_comment

begin_decl_stmt
name|char
name|str
index|[
name|BUFSIZE
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nleftover
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|linetemp
index|[
name|BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|altpat
index|[
name|NALT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternation component storage */
end_comment

begin_decl_stmt
name|int
name|altlen
index|[
name|NALT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|altset
index|[
name|NMUSH
operator|+
literal|1
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|preamble
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* match prefix (filename, line no.) */
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strncpy
argument_list|()
decl_stmt|,
modifier|*
name|strpbrk
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|grepxlat
argument_list|()
decl_stmt|,
modifier|*
name|fold
argument_list|()
decl_stmt|,
modifier|*
name|pfile
argument_list|()
decl_stmt|,
modifier|*
name|alternate
argument_list|()
decl_stmt|,
modifier|*
name|isolate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gotamatch
argument_list|()
decl_stmt|,
modifier|*
name|kanji
argument_list|()
decl_stmt|,
modifier|*
name|linesave
argument_list|()
decl_stmt|,
modifier|*
name|submatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|oflag
decl_stmt|;
name|int
name|errflag
init|=
literal|0
decl_stmt|;
name|args
operator|=
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"grep"
argument_list|)
operator|==
literal|0
condition|)
name|grepflag
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"fgrep"
argument_list|)
operator|==
literal|0
condition|)
name|fgrepflag
operator|++
expr_stmt|;
name|oflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"bchie:f:lnosvwxy1"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|fflag
operator|++
expr_stmt|;
name|patfile
operator|=
name|optarg
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
case|case
literal|'v'
case|:
name|egrepold
operator|++
expr_stmt|;
comment|/* boyer-moore of little help here */
continue|continue;
case|case
literal|'c'
case|:
name|cflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
name|eflag
operator|++
expr_stmt|;
name|pattern
operator|=
name|optarg
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
name|hflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
name|oflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
comment|/* Stop at very first match */
name|firstflag
operator|++
expr_stmt|;
comment|/* spead freaks only */
continue|continue;
case|case
literal|'i'
case|:
name|iflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|lflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
case|case
literal|'y'
case|:
if|if
condition|(
operator|!
name|grepflag
condition|)
name|errflag
operator|++
expr_stmt|;
name|grepold
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
comment|/* needs more work, like -b above */
if|if
condition|(
operator|!
name|fgrepflag
condition|)
name|errflag
operator|++
expr_stmt|;
name|fgrepold
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'?'
case|:
name|errflag
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errflag
operator|||
operator|(
operator|(
name|argc
operator|<=
name|optind
operator|)
operator|&&
operator|!
name|fflag
operator|&&
operator|!
name|eflag
operator|)
condition|)
block|{
if|if
condition|(
name|grepflag
condition|)
name|oops
argument_list|(
literal|"usage: grep [-bchilnosvwy] [-e] pattern [file ...]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fgrepflag
condition|)
name|oops
argument_list|(
literal|"usage: fgrep [-bchilnosvx] {-f patfile | [-e] strings} [file ...]"
argument_list|)
expr_stmt|;
else|else
comment|/* encourage SVID options, though we provide 				 * others */
name|oops
argument_list|(
literal|"usage: egrep [-bchilnosv] {-f patfile | [-e] pattern} [file ...]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflag
condition|)
name|pattern
operator|=
name|pfile
argument_list|(
name|patfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eflag
condition|)
block|{
name|patind
operator|=
name|optind
expr_stmt|;
name|pattern
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oflag
operator|&&
operator|(
name|argc
operator|-
name|optind
operator|)
operator|<=
literal|1
condition|)
comment|/* Filename invisible given< 2 files */
name|hflag
operator|++
expr_stmt|;
if|if
condition|(
name|pattern
index|[
literal|0
index|]
operator|==
name|EOS
condition|)
name|kernighan
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* same as it ever was */
comment|/* 	 * 'grep/egrep' merger -- "old" grep is called to handle: tagged 	 * exprs \( \), word matches \< and \>, -w and -y options, char 	 * classes with '-' at end (egrep bug?), and patterns beginning with 	 * an asterisk (don't ask why). otherwise, characters meaningful to 	 * 'egrep' but not to 'grep' are escaped; the entire expr is then 	 * passed to 'egrep'.  	 */
if|if
condition|(
name|grepflag
operator|&&
operator|!
name|grepold
condition|)
block|{
if|if
condition|(
name|strindex
argument_list|(
name|pattern
argument_list|,
literal|"\\("
argument_list|)
operator|>=
literal|0
operator|||
name|strindex
argument_list|(
name|pattern
argument_list|,
literal|"\\<"
argument_list|)
operator|>=
literal|0
operator|||
name|strindex
argument_list|(
name|pattern
argument_list|,
literal|"\\>"
argument_list|)
operator|>=
literal|0
operator|||
name|strindex
argument_list|(
name|pattern
argument_list|,
literal|"-]"
argument_list|)
operator|>=
literal|0
operator|||
name|pattern
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
comment|/* grep bug */
name|grepold
operator|++
expr_stmt|;
else|else
name|pattern
operator|=
name|grepxlat
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grepold
operator|||
name|egrepold
operator|||
name|fgrepold
condition|)
name|kernighan
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
name|strcpy
argument_list|(
name|pattern
argument_list|,
name|fold
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the pattern is a plain string, just run boyer-moore. If it 	 * consists of meta-free alternatives, run "superimposed" bmg. 	 * Otherwise, find best string, and compile pattern for regexec().  	 */
if|if
condition|(
name|strpbrk
argument_list|(
name|pattern
argument_list|,
name|META
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* do boyer-moore only */
name|boyonly
operator|++
expr_stmt|;
name|patboy
operator|=
name|pattern
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|patboy
operator|=
name|alternate
argument_list|(
name|pattern
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|boyonly
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|patboy
operator|=
name|isolate
argument_list|(
name|pattern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|kernighan
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* expr too involved */
ifndef|#
directive|ifndef
name|NOKANJI
for|for
control|(
name|c
operator|=
literal|0
init|;
name|pattern
index|[
name|c
index|]
operator|!=
name|EOS
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|pattern
index|[
name|c
index|]
operator|&
name|NONASCII
condition|)
comment|/* kanji + meta */
name|kernighan
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rspencer
operator|=
name|regcomp
argument_list|(
name|pattern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|oops
argument_list|(
literal|"regcomp failure"
argument_list|)
expr_stmt|;
block|}
block|}
name|gosper
argument_list|(
name|patboy
argument_list|)
expr_stmt|;
comment|/* "pre-conditioning is wonderful" 				 * -- v. strassen */
if|if
condition|(
operator|(
name|firstfile
operator|=
name|optind
operator|)
operator|>=
name|argc
condition|)
block|{
comment|/* Grep standard input */
if|if
condition|(
name|lflag
condition|)
comment|/* We don't know its name! */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|egsecute
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|egsecute
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|firstflag
operator|&&
operator|(
name|nsuccess
operator|==
literal|1
operator|)
condition|)
break|break;
block|}
block|}
name|exit
argument_list|(
operator|(
name|nsuccess
operator|==
literal|2
operator|)
condition|?
literal|2
else|:
operator|(
name|nsuccess
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pfile
parameter_list|(
name|pfname
parameter_list|)
comment|/* absorb expression from file */
name|char
modifier|*
name|pfname
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|patstat
decl_stmt|;
specifier|static
name|char
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|pfname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|oops
argument_list|(
literal|"can't read pattern file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|patstat
argument_list|)
operator|!=
literal|0
condition|)
name|oops
argument_list|(
literal|"can't stat pattern file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patstat
operator|.
name|st_size
operator|>
name|PATSIZE
condition|)
block|{
if|if
condition|(
name|fgrepflag
condition|)
block|{
comment|/* defer to unix version */
name|fgrepold
operator|++
expr_stmt|;
return|return
literal|"dummy"
return|;
block|}
else|else
name|oops
argument_list|(
literal|"pattern file too big"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pat
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|patstat
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|oops
argument_list|(
literal|"out of memory to read pattern file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patstat
operator|.
name|st_size
operator|!=
name|read
argument_list|(
name|fd
argument_list|,
name|pat
argument_list|,
operator|(
name|int
operator|)
name|patstat
operator|.
name|st_size
argument_list|)
condition|)
name|oops
argument_list|(
literal|"error reading pattern file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pat
index|[
name|patstat
operator|.
name|st_size
index|]
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
name|pat
index|[
name|patstat
operator|.
name|st_size
operator|-
literal|1
index|]
operator|==
name|NL
condition|)
comment|/* NOP for egrep; helps grep */
name|pat
index|[
name|patstat
operator|.
name|st_size
operator|-
literal|1
index|]
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
name|nlcount
argument_list|(
name|pat
argument_list|,
operator|&
name|pat
index|[
name|patstat
operator|.
name|st_size
index|]
argument_list|)
operator|>
name|NALT
condition|)
block|{
if|if
condition|(
name|fgrepflag
condition|)
name|fgrepold
operator|++
expr_stmt|;
comment|/* "what's it all about, alfie?" */
else|else
name|egrepold
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|pat
operator|)
return|;
block|}
end_function

begin_macro
name|egsecute
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|fd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|nsuccess
operator|=
literal|2
expr_stmt|;
return|return;
block|}
name|chimaera
argument_list|(
name|file
argument_list|,
name|patboy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|boyonly
operator|&&
operator|!
name|flushflag
operator|&&
name|file
operator|!=
name|NULL
condition|)
name|flushmatches
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|chimaera
argument_list|(
argument|file
argument_list|,
argument|pat
argument_list|)
end_macro

begin_comment
comment|/* "reach out and boyer-moore search someone" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|pat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- soon-to-be-popular bumper sticker */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|k
decl_stmt|,
modifier|*
name|strend
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|int
modifier|*
name|deltazero
init|=
name|delta0
decl_stmt|;
name|int
name|patlen
init|=
name|altmin
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|nleftover
operator|=
name|boyfound
operator|=
name|flushflag
operator|=
literal|0
expr_stmt|;
name|nline
operator|=
literal|1L
expr_stmt|;
name|prevmatch
operator|=
literal|0
expr_stmt|;
name|nmatch
operator|=
name|counted
operator|=
name|rxcount
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|str
operator|+
name|nleftover
argument_list|,
name|BUFSIZE
operator|-
name|nleftover
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|counted
operator|+=
name|count
expr_stmt|;
name|strend
operator|=
name|linesave
argument_list|(
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|str
operator|+
name|patlen
operator|-
literal|1
init|;
name|k
operator|<
name|strend
condition|;
control|)
block|{
comment|/* 			 * for a large class of patterns, upwards of 80% of 			 * match time is spent on the next line.  we beat 			 * existing microcode (vax 'matchc') this way.  			 */
while|while
condition|(
operator|(
name|k
operator|+=
name|deltazero
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|k
index|]
operator|)
operator|<
name|strend
condition|)
empty_stmt|;
if|if
condition|(
name|k
operator|<
operator|(
name|str
operator|+
name|LARGE
operator|)
condition|)
break|break;
name|k
operator|-=
name|LARGE
expr_stmt|;
if|if
condition|(
name|altflag
condition|)
block|{
comment|/* 				 * Parallel Boyer-Moore.  Check whether each 				 * of the previous<altmin> chars COULD be 				 * from one of the alternative strings.  				 */
name|s
operator|=
name|k
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|altmin
expr_stmt|;
while|while
condition|(
name|altset
index|[
operator|--
name|j
index|]
index|[
operator|(
name|unsigned
name|char
operator|)
name|cmap
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|--
index|]
index|]
condition|)
empty_stmt|;
comment|/* 				 * quick test fails. in this life, compare 				 * 'em all.  but, a "reverse trie" would 				 * attenuate worst case (linear w/delta2?).  				 */
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
block|{
name|count
operator|=
name|nalt
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
name|k
expr_stmt|;
name|j
operator|=
name|altlen
index|[
name|count
index|]
expr_stmt|;
name|t
operator|=
name|altpat
index|[
name|count
index|]
expr_stmt|;
while|while
condition|(
name|cmap
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|--
index|]
operator|==
name|t
index|[
operator|--
name|j
index|]
condition|)
empty_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|count
operator|--
condition|)
do|;
block|}
block|}
else|else
block|{
comment|/* One string -- check it */
name|j
operator|=
name|patlen
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|k
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cmap
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|--
index|]
operator|==
name|pat
index|[
operator|--
name|j
index|]
condition|)
empty_stmt|;
block|}
comment|/* 			 * delta-less shortcut for literati. short shrift for 			 * genetic engineers?  			 */
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|k
operator|++
expr_stmt|;
comment|/* no match; restart next char */
continue|continue;
block|}
name|k
operator|=
name|submatch
argument_list|(
name|file
argument_list|,
name|pat
argument_list|,
name|str
argument_list|,
name|strend
argument_list|,
name|k
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
name|nflag
condition|)
block|{
if|if
condition|(
name|prevmatch
condition|)
name|nline
operator|=
name|prevnline
operator|+
name|nlcount
argument_list|(
name|prevloc
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|nline
operator|=
name|nline
operator|+
name|nlcount
argument_list|(
name|str
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|prevmatch
operator|=
literal|0
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|str
argument_list|,
name|linetemp
argument_list|,
name|nleftover
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
condition|)
block|{
comment|/* Bug from old grep: -c overrides -h.  We fix the bug. */
if|if
condition|(
operator|!
name|hflag
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|nmatch
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|linesave
parameter_list|(
name|str
parameter_list|,
name|count
parameter_list|)
comment|/* accumulate partial line at end of buffer */
name|char
name|str
index|[]
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|count
operator|+=
name|nleftover
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|BUFSIZE
operator|&&
name|fd
operator|!=
literal|0
condition|)
name|str
index|[
name|count
operator|++
index|]
operator|=
name|NL
expr_stmt|;
comment|/* insurance for broken last line */
name|str
index|[
name|count
index|]
operator|=
name|EOS
expr_stmt|;
for|for
control|(
name|j
operator|=
name|count
operator|-
literal|1
init|;
name|str
index|[
name|j
index|]
operator|!=
name|NL
operator|&&
name|j
operator|>=
literal|0
condition|;
control|)
name|j
operator|--
expr_stmt|;
comment|/* 	 * break up these lines: long line (> BUFSIZE), last line of file, or 	 * short return from read(), as from tee(1) input  	 */
if|if
condition|(
name|j
operator|<
literal|0
operator|&&
operator|(
name|count
operator|==
operator|(
name|BUFSIZE
operator|-
name|nleftover
operator|)
operator|)
condition|)
block|{
name|str
index|[
name|count
operator|++
index|]
operator|=
name|NL
expr_stmt|;
name|str
index|[
name|count
index|]
operator|=
name|EOS
expr_stmt|;
name|linetemp
index|[
literal|0
index|]
operator|=
name|EOS
expr_stmt|;
name|nleftover
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|str
operator|+
name|count
operator|)
return|;
block|}
else|else
block|{
name|nleftover
operator|=
name|count
operator|-
name|j
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|linetemp
argument_list|,
name|str
operator|+
name|j
operator|+
literal|1
argument_list|,
name|nleftover
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|+
name|j
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process partial match. First check for mis-aligned Kanji, then match line  * against full compiled r.e. if statistics do not warrant handing off to  * standard egrep.   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|submatch
argument_list|(
name|file
argument_list|,
name|pat
argument_list|,
name|str
argument_list|,
name|strend
argument_list|,
name|k
argument_list|,
name|altindex
argument_list|)
name|char
name|file
index|[]
decl_stmt|,
name|pat
index|[]
decl_stmt|,
name|str
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|strend
decl_stmt|,
modifier|*
name|k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|altindex
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|;
name|t
operator|=
name|k
expr_stmt|;
name|s
operator|=
operator|(
operator|(
name|altflag
operator|)
condition|?
name|k
operator|-
name|altlen
index|[
name|altindex
index|]
operator|+
literal|1
else|:
name|k
operator|-
name|altmin
operator|+
literal|1
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOKANJI
name|c
operator|=
operator|(
operator|(
name|altflag
operator|)
condition|?
name|altpat
index|[
name|altindex
index|]
index|[
literal|0
index|]
else|:
name|pat
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|NONASCII
condition|)
if|if
condition|(
operator|(
name|s
operator|=
name|kanji
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|k
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|++
name|k
operator|)
return|;
comment|/* reject false kanji */
endif|#
directive|endif
do|do
empty_stmt|;
do|while
condition|(
operator|*
name|s
operator|!=
name|NL
operator|&&
operator|--
name|s
operator|>=
name|str
condition|)
do|;
name|k
operator|=
name|s
operator|+
literal|1
expr_stmt|;
comment|/* now at line start */
if|if
condition|(
name|boyonly
condition|)
return|return
operator|(
name|gotamatch
argument_list|(
name|file
argument_list|,
name|k
argument_list|)
operator|)
return|;
name|incount
operator|=
name|counted
operator|-
operator|(
name|strend
operator|-
name|k
operator|)
expr_stmt|;
if|if
condition|(
name|boyfound
operator|++
operator|==
name|FIRSTFEW
condition|)
name|execstrategy
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
do|do
name|rxcount
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|NL
condition|)
do|;
operator|*
operator|--
name|s
operator|=
name|EOS
expr_stmt|;
comment|/* 	 * "quick henry -- the flit" (after theodor geisel)  	 */
if|if
condition|(
name|regexec
argument_list|(
name|rspencer
argument_list|,
operator|(
operator|(
name|iflag
operator|)
condition|?
name|fold
argument_list|(
name|k
argument_list|)
else|:
name|k
operator|)
argument_list|)
operator|==
literal|1
condition|)
block|{
operator|*
name|s
operator|=
name|NL
expr_stmt|;
if|if
condition|(
name|gotamatch
argument_list|(
name|file
argument_list|,
name|k
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|s
operator|=
name|NL
expr_stmt|;
return|return
operator|(
name|s
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NOKANJI
end_ifndef

begin_comment
comment|/*  * EUC code disambiguation -- scan backwards to first 7-bit code, while  * counting intervening 8-bit codes.  If odd, reject unaligned Kanji pattern.   * SS2/3 checks are for intermixed Japanase Katakana or Kanji2.   */
end_comment

begin_function
name|char
modifier|*
name|kanji
parameter_list|(
name|str
parameter_list|,
name|s
parameter_list|,
name|k
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|s
decl_stmt|,
modifier|*
name|k
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|--
init|;
name|s
operator|>=
name|str
condition|;
name|s
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|SS2
operator|||
operator|*
name|s
operator|==
name|SS3
operator|||
operator|(
operator|*
name|s
operator|&
name|NONASCII
operator|)
operator|==
literal|0
condition|)
break|break;
name|j
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CHINESE
if|if
condition|(
operator|*
name|s
operator|==
name|SS2
condition|)
name|j
operator|-=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|CHINESE
return|return
operator|(
operator|(
name|j
operator|&
literal|01
operator|)
condition|?
name|NULL
else|:
name|k
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compute "Boyer-Moore" delta table -- put skip distance in delta0[c]   */
end_comment

begin_macro
name|gosper
argument_list|(
argument|pattern
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... HAKMEM lives ... */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Make one-string case look like simple alternatives case */
if|if
condition|(
operator|!
name|altflag
condition|)
block|{
name|nalt
operator|=
literal|1
expr_stmt|;
name|altmin
operator|=
name|altlen
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|altpat
index|[
literal|0
index|]
operator|=
name|pattern
expr_stmt|;
block|}
comment|/* For chars that aren't in any string, skip by string length. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|delta0
index|[
name|j
index|]
operator|=
name|altmin
expr_stmt|;
name|cmap
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
comment|/* Sneak in initialization of cmap */
block|}
comment|/* For chars in a string, skip distance from char to end of string. */
comment|/* (If char appears more than once, skip minimum distance.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalt
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|altlen
index|[
name|i
index|]
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
name|altpat
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|delta0
index|[
name|c
index|]
operator|=
name|MIN
argument_list|(
name|delta0
index|[
name|c
index|]
argument_list|,
name|altlen
index|[
name|i
index|]
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
condition|)
name|delta0
index|[
name|toupper
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
index|]
operator|=
name|delta0
index|[
name|c
index|]
expr_stmt|;
block|}
comment|/* For last char of each string, fall out of search loop. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalt
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|altpat
index|[
name|i
index|]
index|[
name|altlen
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|delta0
index|[
name|c
index|]
operator|=
name|LARGE
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
condition|)
name|delta0
index|[
name|toupper
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
index|]
operator|=
name|LARGE
expr_stmt|;
block|}
if|if
condition|(
name|iflag
condition|)
for|for
control|(
name|j
operator|=
literal|'A'
init|;
name|j
operator|<=
literal|'Z'
condition|;
name|j
operator|++
control|)
name|cmap
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
operator|(
name|int
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print, count, or stop on full match. Result is either the location for  * continued search, or NULL to stop.   */
end_comment

begin_function
name|char
modifier|*
name|gotamatch
parameter_list|(
name|file
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|savematch
parameter_list|()
function_decl|;
name|int
name|squirrel
init|=
literal|0
decl_stmt|;
comment|/* nonzero to squirrel away FIRSTFEW matches */
name|nmatch
operator|++
expr_stmt|;
name|nsuccess
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|boyonly
operator|&&
name|boyfound
operator|<=
name|FIRSTFEW
operator|&&
name|file
operator|!=
name|NULL
condition|)
name|squirrel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sflag
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* -s usurps all flags (unlike some versions) */
if|if
condition|(
name|cflag
condition|)
block|{
comment|/* -c overrides -l, we guess */
do|do
empty_stmt|;
do|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|NL
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|lflag
condition|)
block|{
name|puts
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|hflag
condition|)
if|if
condition|(
operator|!
name|squirrel
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|preamble
argument_list|,
literal|"%s:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
block|{
if|if
condition|(
name|prevmatch
condition|)
name|prevnline
operator|=
name|prevnline
operator|+
name|nlcount
argument_list|(
name|prevloc
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|prevnline
operator|=
name|nline
operator|+
name|nlcount
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prevmatch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|squirrel
condition|)
name|printf
argument_list|(
literal|"%ld:"
argument_list|,
name|prevnline
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|preamble
operator|+
name|strlen
argument_list|(
name|preamble
argument_list|)
argument_list|,
literal|"%ld:"
argument_list|,
name|prevnline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|squirrel
condition|)
block|{
do|do
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|NL
condition|)
do|;
block|}
else|else
name|s
operator|=
name|savematch
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|prevloc
operator|=
name|s
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|firstflag
operator|&&
operator|!
name|cflag
operator|)
condition|?
name|NULL
else|:
name|s
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|fold
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
specifier|static
name|char
name|fline
index|[
name|BUFSIZE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
init|=
name|fline
decl_stmt|;
for|for
control|(
name|s
operator|=
name|line
init|;
operator|*
name|s
operator|!=
name|EOS
condition|;
name|s
operator|++
control|)
operator|*
name|t
operator|++
operator|=
operator|(
name|isupper
argument_list|(
operator|(
name|int
operator|)
operator|*
name|s
argument_list|)
condition|?
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|s
argument_list|)
else|:
operator|*
name|s
operator|)
expr_stmt|;
operator|*
name|t
operator|=
name|EOS
expr_stmt|;
return|return
operator|(
name|fline
operator|)
return|;
block|}
end_function

begin_macro
name|strindex
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_comment
comment|/* the easy way, as in K&P, p. 192 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|s
operator|+
name|i
argument_list|,
name|t
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|grepxlat
parameter_list|(
name|pattern
parameter_list|)
comment|/* grep pattern meta conversion */
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|static
name|char
name|newpat
index|[
name|BUFSIZE
index|]
decl_stmt|;
for|for
control|(
name|s
operator|=
name|newpat
operator|,
name|p
operator|=
name|pattern
init|;
operator|*
name|p
operator|!=
name|EOS
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* skip escapes ... */
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
comment|/* ... and char classes */
while|while
condition|(
operator|*
name|p
operator|!=
name|EOS
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"+?|()"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\\'
expr_stmt|;
comment|/* insert protection */
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|EOS
expr_stmt|;
name|grepflag
operator|=
operator|(
operator|(
name|patind
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|newpat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for simple alternation.  Result is NULL if it's not so simple, or is  * a pointer to the first string if it is. Warning:  sscanf size is a  * fixpoint, beyond which the speedup linearity starts to break down.  In the  * wake of the elegant aho/corrasick "trie"-based fgrep, generalizing  * altpat[] to arbitrary size is not useful.   */
end_comment

begin_function
name|char
modifier|*
name|alternate
parameter_list|(
name|regexpr
parameter_list|)
name|char
modifier|*
name|regexpr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|stop
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|fgrepflag
operator|&&
name|strchr
argument_list|(
name|regexpr
argument_list|,
literal|'|'
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * break pattern up into altpat array; delimit on newline, bar, 	 * or EOS.  We know we won't overflow, we've already checked the 	 * number of patterns we're going to find against NALT. 	 * Also, set length of pattern and find minimum pattern length. 	 */
name|nalt
operator|=
literal|0
expr_stmt|;
name|altmin
operator|=
name|NMUSH
expr_stmt|;
for|for
control|(
name|start
operator|=
name|stop
operator|=
name|regexpr
init|;
condition|;
operator|++
name|stop
control|)
if|if
condition|(
operator|!
operator|*
name|stop
operator|||
operator|*
name|stop
operator|==
literal|'|'
operator|||
operator|*
name|stop
operator|==
name|NL
condition|)
block|{
name|altlen
index|[
name|nalt
index|]
operator|=
name|j
operator|=
name|stop
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|altmin
condition|)
name|altmin
operator|=
name|j
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|altpat
index|[
name|nalt
index|]
operator|=
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|j
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|oops
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|start
argument_list|,
name|altpat
index|[
name|nalt
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|altpat
index|[
name|nalt
index|]
index|[
name|j
index|]
operator|=
name|EOS
expr_stmt|;
operator|++
name|nalt
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|stop
condition|)
break|break;
if|if
condition|(
name|nalt
operator|==
name|NALT
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|stop
operator|==
name|NL
condition|)
operator|*
name|stop
operator|=
literal|'|'
expr_stmt|;
name|start
operator|=
name|stop
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fgrepflag
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|regexpr
argument_list|,
literal|'|'
argument_list|)
operator|==
name|NULL
operator|||
name|regexpr
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strpbrk
argument_list|(
name|regexpr
argument_list|,
literal|"^$.[]()?+*\\"
argument_list|)
operator|!=
name|NULL
operator|||
name|strindex
argument_list|(
name|regexpr
argument_list|,
literal|"||"
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|nalt
operator|>
literal|1
condition|)
block|{
comment|/* build superimposed "pre-match" sets per 				 * char */
name|altflag
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nalt
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|altmin
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|altpat
index|[
name|j
index|]
index|[
name|altlen
index|[
name|j
index|]
operator|-
name|altmin
operator|+
name|i
index|]
expr_stmt|;
name|altset
index|[
name|i
operator|+
literal|1
index|]
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
comment|/* offset for sentinel */
block|}
block|}
return|return
operator|(
name|altpat
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grapple with the dfa (std egrep) vs. ndfa (regexp) tradeoff. Criteria to  * determine whether to use dfa-based egrep:  We do FIRSTFEW matches with  * regexec().  If Boyer-Moore up to now matched more than PUNTPERCENT  * of the input, the r.e. is likely to be underspecified, so do old *grep,  * which is faster on complex patterns than regexp().  At FIRSTFEW,  * dump the saved matches collected by savematch(). They are saved  * so that a "PUNT" can "rewind" to ignore them.  Stdin is problematic,  * since it's hard to rewind.   */
end_comment

begin_macro
name|execstrategy
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pctmatch
decl_stmt|;
name|pctmatch
operator|=
operator|(
literal|100
operator|*
name|rxcount
operator|)
operator|/
name|incount
expr_stmt|;
if|if
condition|(
name|pctmatch
operator|>
name|PUNTPERCENT
operator|&&
name|file
operator|!=
name|NULL
condition|)
name|kernighan
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|flushmatches
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|nlcount
argument_list|(
argument|bstart
argument_list|,
argument|bstop
argument_list|)
end_macro

begin_comment
comment|/* flail interval to totalize newlines. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bstart
decl_stmt|,
modifier|*
name|bstop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|bstart
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
init|=
name|bstop
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|/* loop unroll for older architectures */
if|if
condition|(
operator|*
name|t
operator|==
name|NL
condition|)
comment|/* ... ask ames!jaw for sample code */
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|--
operator|>
name|s
condition|)
do|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|isolate
parameter_list|(
name|regexpr
parameter_list|)
comment|/* isolate longest metacharacter-free string */
name|char
modifier|*
name|regexpr
decl_stmt|;
block|{
name|char
modifier|*
name|dummyexpr
decl_stmt|;
comment|/* 	 * We add (.)* because Henry's regcomp only figures regmust if it 	 * sees a leading * pattern.  Foo!  	 */
name|dummyexpr
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|regexpr
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dummyexpr
argument_list|,
literal|"(.)*%s"
argument_list|,
name|regexpr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rspencer
operator|=
name|regcomp
argument_list|(
name|dummyexpr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|kernighan
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|rspencer
operator|->
name|regmust
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|matches
index|[
name|FIRSTFEW
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|savematch
parameter_list|(
name|s
parameter_list|)
comment|/* horde matches during statistics gathering */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|s
decl_stmt|;
name|int
name|msize
init|=
literal|0
decl_stmt|;
name|int
name|psize
init|=
name|strlen
argument_list|(
name|preamble
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|NL
condition|)
name|msize
operator|++
expr_stmt|;
operator|*
operator|--
name|s
operator|=
name|EOS
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|msize
operator|+
literal|1
operator|+
name|psize
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|preamble
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
name|psize
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|matches
index|[
name|mcount
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|preamble
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
name|NL
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|flushmatches
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
name|flushflag
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mcount
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|matches
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|mcount
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|oops
argument_list|(
argument|message
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|progname
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|kernighan
argument_list|(
argument|args
argument_list|)
end_macro

begin_comment
comment|/* "let others do the hard part ..." */
end_comment

begin_decl_stmt
name|char
modifier|*
name|args
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * We may have already run grep on some of the files; remove them 	 * from the arg list we pass on.  Note that we can't delete them 	 * totally because the number of file names affects the output 	 * (automatic -h).  	 */
comment|/* better would be fork/exec per punted file -- jaw */
while|while
condition|(
name|firstfile
operator|&&
name|optind
operator|>
name|firstfile
condition|)
name|args
index|[
name|firstfile
operator|++
index|]
operator|=
name|_PATH_DEVNULL
expr_stmt|;
if|if
condition|(
name|patind
condition|)
name|args
index|[
name|patind
index|]
operator|=
name|pattern
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|grepflag
condition|)
name|execvp
argument_list|(
name|_PATH_GREPSTD
argument_list|,
name|args
argument_list|)
operator|,
name|oops
argument_list|(
literal|"can't exec old 'grep'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fgrepflag
condition|)
name|execvp
argument_list|(
name|_PATH_FGREPSTD
argument_list|,
name|args
argument_list|)
operator|,
name|oops
argument_list|(
literal|"can't exec old 'fgrep'"
argument_list|)
expr_stmt|;
else|else
name|execvp
argument_list|(
name|_PATH_EGREPSTD
argument_list|,
name|args
argument_list|)
operator|,
name|oops
argument_list|(
literal|"can't exec old 'egrep'"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

