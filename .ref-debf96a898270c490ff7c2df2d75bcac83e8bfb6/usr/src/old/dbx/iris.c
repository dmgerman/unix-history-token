begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)iris.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: machine.c,v 1.2 87/03/26 14:54:55 donn Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Target machine dependent stuff.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_include
include|#
directive|include
file|"ops.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Address
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Word
typedef|;
end_typedef

begin_comment
comment|/*  * On the 68000, the pc isn't in a register, but we make believe  * so there's one more register.  *  * Note that there's also no argument pointer, this means code  * involving "ARGP" should always be #ifdef'd.  *  * The address corresponding to the beginning of a function is recorded  * as the address + FUNCOFFSET (skip the link instruction so that  * local information is available).  */
end_comment

begin_define
define|#
directive|define
name|NREG
value|17
end_define

begin_define
define|#
directive|define
name|FRP
value|14
end_define

begin_define
define|#
directive|define
name|STKP
value|15
end_define

begin_define
define|#
directive|define
name|PROGCTR
value|16
end_define

begin_define
define|#
directive|define
name|CALL_RETADDR
value|0x800c
end_define

begin_comment
comment|/* Return address for 'call' command */
end_comment

begin_define
define|#
directive|define
name|FUNCOFFSET
value|4
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_define
define|#
directive|define
name|CODESTART
value|0x8000
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IRIS */
end_comment

begin_define
define|#
directive|define
name|CODESTART
value|0x1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|optab_init
parameter_list|()
end_define

begin_define
define|#
directive|define
name|BITSPERBYTE
value|8
end_define

begin_define
define|#
directive|define
name|BITSPERWORD
value|(BITSPERBYTE * sizeof(Word))
end_define

begin_comment
comment|/*  * This magic macro enables us to look at the process' registers  * in its user structure.  */
end_comment

begin_define
define|#
directive|define
name|regloc
parameter_list|(
name|reg
parameter_list|)
value|(ctob(UPAGES) + (sizeof(Word) * ((reg) - PC)) - 10)
end_define

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|DELETE
end_undef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_decl_stmt
name|Address
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Address
name|prtaddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Indices into u. for use in collecting registers values.  */
end_comment

begin_decl_stmt
name|public
name|int
name|rloc
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|sun
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|AR0
block|,
name|AR1
block|,
name|AR2
block|,
name|AR3
block|,
name|AR4
block|,
name|AR5
block|,
name|AR6
block|,
name|AR7
block|,
name|PC
else|#
directive|else
comment|/* IRIS */
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|AR0
block|,
name|AR1
block|,
name|AR2
block|,
name|AR3
block|,
name|AR4
block|,
name|AR5
block|,
name|AR6
block|,
name|AR7
block|,
literal|16
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|Address
name|printop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Decode and print the instructions within the given address range.  */
end_comment

begin_function
name|public
name|printinst
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
control|)
block|{
name|addr
operator|=
name|printop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Another approach:  print n instructions starting at the given address.  */
end_comment

begin_function
name|public
name|printninst
parameter_list|(
name|count
parameter_list|,
name|addr
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Address
name|newaddr
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newaddr
operator|=
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|newaddr
operator|=
name|printop
argument_list|(
name|newaddr
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|newaddr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the contents of the addresses within the given range  * according to the given format.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|String
name|name
decl_stmt|;
name|String
name|printfstring
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|Format
typedef|;
end_typedef

begin_decl_stmt
name|private
name|Format
name|fmt
index|[]
init|=
block|{
block|{
literal|"d"
block|,
literal|" %d"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"D"
block|,
literal|" %ld"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"o"
block|,
literal|" %o"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"O"
block|,
literal|" %lo"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"x"
block|,
literal|" %04x"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"X"
block|,
literal|" %08x"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"b"
block|,
literal|" \\%o"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"c"
block|,
literal|" '%c'"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"s"
block|,
literal|"%c"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"f"
block|,
literal|" %f"
block|,
expr|sizeof
operator|(
name|float
operator|)
block|}
block|,
block|{
literal|"g"
block|,
literal|" %g"
block|,
expr|sizeof
operator|(
name|double
operator|)
block|}
block|,
block|{
name|nil
block|,
name|nil
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Format
modifier|*
name|findformat
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|&
name|fmt
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|name
operator|!=
name|nil
name|and
name|not
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|s
argument_list|)
condition|)
block|{
operator|++
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|name
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"bad print format \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve and print out the appropriate data in the given format.  * Floats have to be handled specially to allow the compiler to  * convert them to doubles when passing to printf.  */
end_comment

begin_function
name|private
name|printformat
parameter_list|(
name|f
parameter_list|,
name|addr
parameter_list|)
name|Format
modifier|*
name|f
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
union|union
block|{
name|char
name|charv
decl_stmt|;
name|short
name|shortv
decl_stmt|;
name|int
name|intv
decl_stmt|;
name|float
name|floatv
decl_stmt|;
name|double
name|doublev
decl_stmt|;
block|}
name|value
union|;
name|value
operator|.
name|intv
operator|=
literal|0
expr_stmt|;
name|dread
argument_list|(
operator|&
name|value
argument_list|,
name|addr
argument_list|,
name|f
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"f"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
operator|.
name|floatv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|Address
name|printdata
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|,
name|format
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
name|Format
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|lowaddr
operator|>
name|highaddr
condition|)
block|{
name|error
argument_list|(
literal|"first address larger than second"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
name|addr
operator|+=
name|f
operator|->
name|length
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|printformat
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * The other approach is to print n items starting with a given address.  */
end_comment

begin_function
name|public
name|printndata
parameter_list|(
name|count
parameter_list|,
name|startaddr
parameter_list|,
name|format
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Format
modifier|*
name|f
decl_stmt|;
name|Boolean
name|isstring
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|isstring
operator|=
operator|(
name|Boolean
operator|)
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isstring
condition|)
block|{
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|printchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|addr
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|String
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printformat
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|addr
operator|+=
name|f
operator|->
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a value according to the given format.  */
end_comment

begin_function
name|public
name|printvalue
parameter_list|(
name|v
parameter_list|,
name|format
parameter_list|)
name|long
name|v
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|Format
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|v
expr_stmt|;
name|q
operator|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|printchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out an execution time error.  * Assumes the source position of the error has been calculated.  *  * Have to check if the -r option was specified; if so then  * the object file information hasn't been read in yet.  */
end_comment

begin_function
name|public
name|printerror
parameter_list|()
block|{
specifier|extern
name|Integer
name|sys_nsig
decl_stmt|;
specifier|extern
name|String
name|sys_siglist
index|[]
decl_stmt|;
name|integer
name|err
decl_stmt|;
if|if
condition|(
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|err
operator|=
name|exitcode
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\" terminated normally\n"
argument_list|,
name|objname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\"%s\" terminated abnormally (exit code %d)\n"
argument_list|,
name|objname
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
name|err
operator|=
name|errnum
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printsig
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printloc
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
condition|)
block|{
name|printlines
argument_list|(
name|curline
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printinst
argument_list|(
name|pc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a signal.  */
end_comment

begin_decl_stmt
name|private
name|String
name|illinames
index|[]
init|=
block|{
literal|"reserved addressing fault"
block|,
literal|"privileged instruction fault"
block|,
literal|"reserved operand fault"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|String
name|fpenames
index|[]
init|=
block|{
name|nil
block|,
literal|"integer overflow trap"
block|,
literal|"integer divide by zero trap"
block|,
literal|"floating overflow trap"
block|,
literal|"floating/decimal divide by zero trap"
block|,
literal|"floating underflow trap"
block|,
literal|"decimal overflow trap"
block|,
literal|"subscript out of range trap"
block|,
literal|"floating overflow fault"
block|,
literal|"floating divide by zero fault"
block|,
literal|"floating underflow fault"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|printsig
parameter_list|(
name|signo
parameter_list|)
name|integer
name|signo
decl_stmt|;
block|{
name|integer
name|code
decl_stmt|;
if|if
condition|(
name|signo
operator|<
literal|0
name|or
name|signo
operator|>
name|sys_nsig
condition|)
block|{
name|printf
argument_list|(
literal|"[signal %d]"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sys_siglist
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|errcode
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|==
name|SIGILL
condition|)
block|{
if|if
condition|(
name|code
operator|>=
literal|0
name|and
name|code
operator|<
sizeof|sizeof
argument_list|(
name|illinames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|illinames
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|illinames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|signo
operator|==
name|SIGFPE
condition|)
block|{
if|if
condition|(
name|code
operator|>
literal|0
name|and
name|code
operator|<
sizeof|sizeof
argument_list|(
name|fpenames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fpenames
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|fpenames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Note the termination of the program.  We do this so as to avoid  * having the process exit, which would make the values of variables  * inaccessible.  We do want to flush all output buffers here,  * otherwise it'll never get done.  */
end_comment

begin_function
name|public
name|endprogram
parameter_list|()
block|{
name|Integer
name|exitcode
decl_stmt|;
name|stepto
argument_list|(
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|printnews
argument_list|()
expr_stmt|;
name|exitcode
operator|=
name|argn
argument_list|(
literal|1
argument_list|,
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nexecution completed (exit code %d)\n"
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nexecution completed\n"
argument_list|)
expr_stmt|;
block|}
name|getsrcpos
argument_list|()
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Single step the machine a source line (or instruction if "inst_tracing"  * is true).  If "isnext" is true, skip over procedure calls.  */
end_comment

begin_function_decl
name|private
name|Address
name|getcall
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|dostep
parameter_list|(
name|isnext
parameter_list|)
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Lineno
name|line
decl_stmt|;
name|String
name|filename
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|startaddr
operator|=
name|pc
expr_stmt|;
name|addr
operator|=
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|inst_tracing
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|nextaddr
argument_list|(
name|addr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|curline
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
name|curline
operator|=
literal|0
expr_stmt|;
block|}
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|filename
operator|=
name|srcfilename
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|setsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|short
name|Bpinst
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|Bpinst
name|BP_OP
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_asm
asm|asm("_BP_OP: trap #15");
end_asm

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IRIS */
end_comment

begin_asm
asm|asm("_BP_OP: trap #1");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BP_ERRNO
value|SIGTRAP
end_define

begin_comment
comment|/* signal received at a breakpoint */
end_comment

begin_comment
comment|/*  * Setting a breakpoint at a location consists of saving  * the word at the location and poking a BP_OP there.  *  * We save the locations and words on a list for use in unsetting.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|Savelist
modifier|*
name|Savelist
typedef|;
end_typedef

begin_struct
struct|struct
name|Savelist
block|{
name|Address
name|location
decl_stmt|;
name|Bpinst
name|save
decl_stmt|;
name|short
name|refcount
decl_stmt|;
name|Savelist
name|link
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|Savelist
name|savelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a breakpoint at the given address.  Only save the word there  * if it's not already a breakpoint.  */
end_comment

begin_function
name|public
name|setbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Bpinst
name|w
decl_stmt|,
name|save
decl_stmt|;
specifier|register
name|Savelist
name|newsave
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|s
operator|->
name|refcount
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|iread
argument_list|(
operator|&
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|newsave
operator|=
name|new
argument_list|(
name|Savelist
argument_list|)
expr_stmt|;
name|newsave
operator|->
name|location
operator|=
name|addr
expr_stmt|;
name|newsave
operator|->
name|save
operator|=
name|save
expr_stmt|;
name|newsave
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|newsave
operator|->
name|link
operator|=
name|savelist
expr_stmt|;
name|savelist
operator|=
name|newsave
expr_stmt|;
name|w
operator|=
name|BP_OP
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|w
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unset a breakpoint; unfortunately we have to search the SAVELIST  * to find the saved value.  The assumption is that the SAVELIST will  * usually be quite small.  */
end_comment

begin_function
name|public
name|unsetbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Savelist
name|s
decl_stmt|,
name|prev
decl_stmt|;
name|prev
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|iwrite
argument_list|(
operator|&
name|s
operator|->
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|nil
condition|)
block|{
name|savelist
operator|=
name|s
operator|->
name|link
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|link
operator|=
name|s
operator|->
name|link
expr_stmt|;
block|}
name|dispose
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|prev
operator|=
name|s
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"unsetbp: couldn't find address %d"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Instruction decoding routines for 68000, derived from adb.  *  * The shared boolean variable "printing" is true if the decoded  * instruction is to be printed, false if not.  In either case,  * the address of the next instruction after the given one is returned.  */
end_comment

begin_decl_stmt
name|private
name|Boolean
name|printing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|following
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|followcalls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Address
name|instaddr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|instread
parameter_list|(
name|var
parameter_list|)
define|\
value|{ \     iread(&var, instaddr, sizeof(var)); \     instaddr += sizeof(var); \ }
end_define

begin_function
name|private
name|Optab
modifier|*
name|decode
parameter_list|(
name|inst
parameter_list|,
name|addr
parameter_list|)
name|Word
name|inst
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Optab
modifier|*
name|o
decl_stmt|;
name|o
operator|=
operator|&
name|optab
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|o
operator|->
name|mask
operator|!=
literal|0
name|and
argument_list|(
name|inst
operator|&
name|o
operator|->
name|mask
argument_list|)
operator|!=
name|o
operator|->
name|match
condition|)
block|{
operator|++
name|o
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|private
name|Address
name|printop
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Optab
modifier|*
name|o
decl_stmt|;
name|short
name|inst
decl_stmt|;
name|printf
argument_list|(
literal|"%08x  "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|inst
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|decode
argument_list|(
name|inst
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|mask
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\tbadop"
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printing
operator|=
name|true
expr_stmt|;
name|following
operator|=
name|false
expr_stmt|;
name|instaddr
operator|=
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
expr_stmt|;
call|(
modifier|*
name|o
operator|->
name|opfun
call|)
argument_list|(
name|inst
argument_list|,
name|o
operator|->
name|farg
argument_list|)
expr_stmt|;
name|printing
operator|=
name|false
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|instaddr
return|;
block|}
end_function

begin_comment
comment|/*  * Quickly find the return address of the current procedure or function  * while single stepping.  Just get the word pointed at by sp.  */
end_comment

begin_function
name|private
name|Address
name|currtnaddr
parameter_list|()
block|{
name|Address
name|retaddr
decl_stmt|;
name|dread
argument_list|(
operator|&
name|retaddr
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|retaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retaddr
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the effective address for the given parameters.  */
end_comment

begin_function
name|private
name|printea
parameter_list|(
name|mode
parameter_list|,
name|reg
parameter_list|,
name|size
parameter_list|)
name|long
name|mode
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|long
name|index
decl_stmt|,
name|disp
decl_stmt|;
specifier|static
name|char
modifier|*
name|aregs
index|[]
init|=
block|{
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"a6"
block|,
literal|"sp"
block|}
decl_stmt|;
name|Byte
name|b
decl_stmt|;
name|short
name|w
decl_stmt|;
name|long
name|l
decl_stmt|;
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"d%D"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|aregs
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"%s@"
argument_list|,
name|aregs
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"%s@+"
argument_list|,
name|aregs
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"%s@-"
argument_list|,
name|aregs
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"%s@(%D)"
argument_list|,
name|aregs
index|[
name|reg
index|]
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|index
operator|=
name|w
expr_stmt|;
name|disp
operator|=
call|(
name|char
call|)
argument_list|(
name|index
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s@(%d,%c%D:%c)"
argument_list|,
name|aregs
index|[
name|reg
index|]
argument_list|,
name|disp
argument_list|,
operator|(
name|index
operator|&
literal|0100000
operator|)
condition|?
literal|'a'
else|:
literal|'d'
argument_list|,
operator|(
name|index
operator|>>
literal|12
operator|)
operator|&
literal|07
argument_list|,
operator|(
name|index
operator|&
literal|04000
operator|)
condition|?
literal|'l'
else|:
literal|'w'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|reg
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|index
operator|=
name|w
expr_stmt|;
name|psymoff
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|instread
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|index
operator|=
name|l
expr_stmt|;
name|psymoff
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|disp
operator|=
name|w
expr_stmt|;
name|psymoff
argument_list|(
name|disp
operator|+
name|instaddr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|index
operator|=
name|w
expr_stmt|;
name|disp
operator|=
call|(
name|char
call|)
argument_list|(
name|index
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pc@(%D,%c%D:%c)"
argument_list|,
name|disp
argument_list|,
operator|(
name|index
operator|&
literal|0100000
operator|)
condition|?
literal|'a'
else|:
literal|'d'
argument_list|,
operator|(
name|index
operator|>>
literal|12
operator|)
operator|&
literal|07
argument_list|,
operator|(
name|index
operator|&
literal|04000
operator|)
condition|?
literal|'l'
else|:
literal|'w'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|b
argument_list|)
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|w
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|w
argument_list|)
case|:
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|index
operator|=
name|w
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|l
argument_list|)
case|:
name|instread
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|index
operator|=
name|l
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected size %d in printea\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|instread
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|index
operator|=
name|l
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
name|IMDF
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|private
name|printEA
parameter_list|(
name|ea
parameter_list|,
name|size
parameter_list|)
name|long
name|ea
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|printea
argument_list|(
operator|(
name|ea
operator|>>
literal|3
operator|)
operator|&
literal|07
argument_list|,
name|ea
operator|&
literal|07
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|mapsize
parameter_list|(
name|inst
parameter_list|)
specifier|register
name|long
name|inst
decl_stmt|;
block|{
name|int
name|m
decl_stmt|;
name|inst
operator|>>=
literal|6
expr_stmt|;
name|inst
operator|&=
literal|03
expr_stmt|;
switch|switch
condition|(
name|inst
condition|)
block|{
case|case
literal|0
case|:
name|m
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|m
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|m
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|m
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
name|private
name|char
name|suffix
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|c
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|c
operator|=
literal|'w'
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|c
operator|=
literal|'l'
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad size %d in suffix"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Print an address offset.  Eventually this should attempt to be symbolic,  * but for now its just printed in hex.  */
end_comment

begin_function
name|private
name|psymoff
parameter_list|(
name|off
parameter_list|)
name|Word
name|off
decl_stmt|;
block|{
name|Symbol
name|f
decl_stmt|;
name|f
operator|=
name|whatblock
argument_list|(
call|(
name|Address
call|)
argument_list|(
name|off
operator|+
name|FUNCOFFSET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeloc
argument_list|(
name|f
argument_list|)
operator|==
name|off
operator|+
name|FUNCOFFSET
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Instruction class specific routines.  */
end_comment

begin_function
name|public
name|omove
parameter_list|(
name|inst
parameter_list|,
name|s
parameter_list|)
name|long
name|inst
decl_stmt|;
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|size
decl_stmt|;
name|c
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tmov%c\t"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
operator|(
operator|(
name|c
operator|==
literal|'b'
operator|)
condition|?
literal|1
else|:
operator|(
name|c
operator|==
literal|'w'
operator|)
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|printea
argument_list|(
operator|(
name|inst
operator|>>
literal|3
operator|)
operator|&
literal|07
argument_list|,
name|inst
operator|&
literal|07
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|printea
argument_list|(
operator|(
name|inst
operator|>>
literal|6
operator|)
operator|&
literal|07
argument_list|,
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Two types: bsr (4 bytes) and bsrs (2 bytes)  */
end_comment

begin_function
name|public
name|obranch
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
block|{
name|long
name|disp
decl_stmt|;
name|String
name|s
decl_stmt|;
name|short
name|w
decl_stmt|;
name|Address
name|startingaddr
decl_stmt|;
comment|/* address of branch instruction */
name|int
name|branchtype
decl_stmt|;
comment|/* type of branch (0 = unconditional) */
name|Address
name|dest
decl_stmt|;
name|Address
name|retaddr
decl_stmt|;
comment|/* for bsr instruction */
name|startingaddr
operator|=
name|instaddr
operator|-
literal|2
expr_stmt|;
name|disp
operator|=
name|inst
operator|&
literal|0377
expr_stmt|;
name|s
operator|=
literal|"s "
expr_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
block|{
name|retaddr
operator|=
name|startingaddr
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|retaddr
operator|=
name|startingaddr
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|>
literal|127
condition|)
block|{
name|disp
operator||=
operator|~
literal|0377
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|" "
expr_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|disp
operator|=
name|w
expr_stmt|;
block|}
name|branchtype
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|8
operator|)
operator|&
literal|017
argument_list|)
expr_stmt|;
name|dest
operator|=
name|startingaddr
operator|+
literal|2
operator|+
name|disp
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tb%s%s\t"
argument_list|,
name|bname
index|[
name|branchtype
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|following
condition|)
block|{
comment|/* 	 * If we're to follow the dynamic flow of instructions, 	 * we must see where the branch leads.  A branchtype of 0 	 * indicates an unconditional branch which we simply take 	 * as the new instruction address.  For a conditional branch, 	 * we continue execution up to the current address, single step, 	 * and keep going. 	 */
if|if
condition|(
name|branchtype
operator|==
literal|0
condition|)
block|{
name|instaddr
operator|=
name|dest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|branchtype
operator|==
literal|01
condition|)
block|{
comment|/* bsr */
if|if
condition|(
name|followcalls
condition|)
block|{
name|steppast
argument_list|(
name|startingaddr
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|whatblock
argument_list|(
name|pc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|bpact
argument_list|()
expr_stmt|;
if|if
condition|(
name|nosource
argument_list|(
argument|curfunc
argument_list|)
name|and
name|canskip
argument_list|(
argument|curfunc
argument_list|)
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|stepto
argument_list|(
name|retaddr
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|pc
expr_stmt|;
name|bpact
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callnews
argument_list|(
comment|/* iscall = */
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|steppast
argument_list|(
name|startingaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|odbcc
parameter_list|(
name|inst
parameter_list|,
name|form
parameter_list|)
name|long
name|inst
decl_stmt|;
name|String
name|form
decl_stmt|;
block|{
name|long
name|disp
decl_stmt|;
name|short
name|w
decl_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
name|form
argument_list|,
name|dbname
index|[
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|8
operator|)
operator|&
literal|017
argument_list|)
index|]
argument_list|,
name|inst
operator|&
literal|07
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
name|w
operator|+
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|oscc
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
name|long
name|dummy
decl_stmt|;
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\ts%s\t"
argument_list|,
name|cname
index|[
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|8
operator|)
operator|&
literal|017
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|printea
argument_list|(
operator|(
name|inst
operator|>>
literal|3
operator|)
operator|&
literal|07
argument_list|,
name|inst
operator|&
literal|07
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|biti
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
name|long
name|dummy
decl_stmt|;
block|{
name|short
name|w
decl_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s\t"
argument_list|,
name|bit
index|[
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|6
operator|)
operator|&
literal|03
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|&
literal|0x0100
condition|)
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"d%D,"
argument_list|,
name|inst
operator|>>
literal|9
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
name|IMDF
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|opmode
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
name|long
name|opcode
decl_stmt|;
block|{
specifier|register
name|int
name|opmode
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|;
name|int
name|size
decl_stmt|;
name|opmode
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|6
operator|)
operator|&
literal|07
argument_list|)
expr_stmt|;
name|reg
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|0
name|or
name|opmode
operator|==
literal|4
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opmode
operator|==
literal|1
name|or
name|opmode
operator|==
literal|3
name|or
name|opmode
operator|==
literal|5
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|suffix
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opmode
operator|>=
literal|4
name|and
name|opmode
operator|<=
literal|6
condition|)
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"d%d,"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|printea
argument_list|(
operator|(
name|inst
operator|>>
literal|3
operator|)
operator|&
literal|07
argument_list|,
name|inst
operator|&
literal|07
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printea
argument_list|(
operator|(
name|inst
operator|>>
literal|3
operator|)
operator|&
literal|07
argument_list|,
name|inst
operator|&
literal|07
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|",%c%d"
argument_list|,
operator|(
name|opmode
operator|<=
literal|2
operator|)
condition|?
literal|'d'
else|:
literal|'a'
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|shroi
parameter_list|(
name|inst
parameter_list|,
name|ds
parameter_list|)
name|long
name|inst
decl_stmt|;
name|String
name|ds
decl_stmt|;
block|{
name|int
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|String
name|opcode
decl_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xC0
operator|)
operator|==
literal|0xC0
condition|)
block|{
name|opcode
operator|=
name|shro
index|[
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|03
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s%s\t"
argument_list|,
name|opcode
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|opcode
operator|=
name|shro
index|[
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|3
operator|)
operator|&
literal|03
argument_list|)
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|ds
argument_list|,
name|suffix
argument_list|(
name|mapsize
argument_list|(
name|inst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rx
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
argument_list|)
expr_stmt|;
name|ry
operator|=
call|(
name|int
call|)
argument_list|(
name|inst
operator|&
literal|07
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|>>
literal|5
operator|)
operator|&
literal|01
condition|)
block|{
name|printf
argument_list|(
literal|"d%d,d%d"
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|IMDF
argument_list|,
operator|(
name|rx
condition|?
name|rx
else|:
literal|8
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",d%d"
argument_list|,
name|ry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|public
name|oimmed
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
specifier|register
name|int
name|size
decl_stmt|;
name|long
specifier|const
expr_stmt|;
name|short
name|w
decl_stmt|;
name|size
operator|=
name|mapsize
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|instread
argument_list|(
specifier|const
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
specifier|const
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|suffix
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|IMDF
argument_list|,
specifier|const
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tbadop"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|oreg
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
name|opcode
argument_list|,
operator|(
name|inst
operator|&
literal|07
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|extend
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
name|String
name|opcode
decl_stmt|;
block|{
specifier|register
name|int
name|size
decl_stmt|;
name|int
name|ry
decl_stmt|,
name|rx
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|size
operator|=
name|mapsize
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|ry
operator|=
operator|(
name|inst
operator|&
literal|07
operator|)
expr_stmt|;
name|rx
operator|=
operator|(
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
operator|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|inst
operator|&
literal|0x1000
operator|)
condition|?
name|suffix
argument_list|(
name|size
argument_list|)
else|:
literal|' '
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|inst
operator|&
literal|0x0080
condition|)
block|{
name|printf
argument_list|(
literal|"d%D,a%D"
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|&
literal|0x0008
condition|)
block|{
name|printf
argument_list|(
literal|"a%D,a%D"
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"d%D,d%D"
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xF000
operator|)
operator|==
literal|0xB000
condition|)
block|{
name|printf
argument_list|(
literal|"a%D@+,a%D@+"
argument_list|,
name|ry
argument_list|,
name|rx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|&
literal|0x8
condition|)
block|{
name|printf
argument_list|(
literal|"a%D@-,a%D@-"
argument_list|,
name|ry
argument_list|,
name|rx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"d%D,d%D"
argument_list|,
name|ry
argument_list|,
name|rx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|olink
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
name|long
name|dummy
decl_stmt|;
block|{
name|short
name|w
decl_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tlink\ta%D,"
argument_list|,
name|inst
operator|&
literal|07
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|IMDF
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|otrap
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\ttrap\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|IMDF
argument_list|,
name|inst
operator|&
literal|017
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|oneop
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|jsrop
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
name|Address
name|startingaddr
decl_stmt|;
comment|/* beginning of jsr instruction */
name|Address
name|retaddr
decl_stmt|;
comment|/* can't call return_addr (frame not set up yet) */
name|startingaddr
operator|=
name|instaddr
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
operator|(
name|inst
operator|>>
literal|3
operator|)
operator|&
literal|07
condition|)
block|{
case|case
literal|2
case|:
name|retaddr
operator|=
name|instaddr
expr_stmt|;
comment|/* two byte instruction */
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
name|retaddr
operator|=
name|instaddr
operator|+
literal|2
expr_stmt|;
comment|/* four byte instruction */
break|break;
case|case
literal|7
case|:
default|default:
switch|switch
condition|(
name|inst
operator|&
literal|07
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
name|retaddr
operator|=
name|instaddr
operator|+
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
default|default:
name|retaddr
operator|=
name|instaddr
operator|+
literal|4
expr_stmt|;
comment|/* six byte instruction */
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|following
name|and
name|followcalls
condition|)
block|{
name|steppast
argument_list|(
name|startingaddr
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|whatblock
argument_list|(
name|pc
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|bpact
argument_list|()
expr_stmt|;
if|if
condition|(
name|nosource
argument_list|(
argument|curfunc
argument_list|)
name|and
name|canskip
argument_list|(
argument|curfunc
argument_list|)
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|stepto
argument_list|(
name|retaddr
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|pc
expr_stmt|;
name|bpact
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callnews
argument_list|(
comment|/* iscall = */
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|jmpop
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
name|Address
name|startingaddr
decl_stmt|;
comment|/* beginning of jump instruction */
name|startingaddr
operator|=
name|instaddr
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|following
condition|)
block|{
name|steppast
argument_list|(
name|startingaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|pregmask
parameter_list|(
name|mask
parameter_list|)
specifier|register
name|int
name|mask
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"#<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|flag
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%c%d"
argument_list|,
operator|(
name|i
operator|<
literal|8
operator|)
condition|?
literal|'d'
else|:
literal|'a'
argument_list|,
name|i
operator|&
literal|07
argument_list|)
expr_stmt|;
block|}
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|omovem
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
name|long
name|dummy
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|list
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|int
name|reglist
decl_stmt|;
name|short
name|w
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|list
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0100000
expr_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|reglist
operator|=
name|w
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|070
operator|)
operator|==
literal|040
condition|)
block|{
comment|/* predecrement */
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|2
control|)
block|{
name|list
operator||=
operator|(
operator|(
name|mask
operator|&
name|reglist
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|list
operator||=
operator|(
operator|(
name|mask
operator|&
name|reglist
operator|)
operator|<<
name|i
operator|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|reglist
operator|=
name|list
expr_stmt|;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tmovem%c\t"
argument_list|,
operator|(
name|inst
operator|&
literal|100
operator|)
condition|?
literal|'l'
else|:
literal|'w'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|&
literal|02000
condition|)
block|{
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|pregmask
argument_list|(
name|reglist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pregmask
argument_list|(
name|reglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|ochk
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s\t"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
name|Byte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|",%c%D"
argument_list|,
operator|(
name|opcode
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
condition|?
literal|'a'
else|:
literal|'d'
argument_list|,
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|soneop
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
specifier|register
name|int
name|size
decl_stmt|;
name|size
operator|=
name|mapsize
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|suffix
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tbadop"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|oquick
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|int
name|data
decl_stmt|;
name|size
operator|=
name|mapsize
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|data
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
literal|0
condition|)
block|{
name|data
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|suffix
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|IMDF
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\tbadop"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|omoveq
parameter_list|(
name|inst
parameter_list|,
name|dummy
parameter_list|)
name|long
name|inst
decl_stmt|;
name|long
name|dummy
decl_stmt|;
block|{
specifier|register
name|int
name|data
decl_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|data
operator|=
call|(
name|int
call|)
argument_list|(
name|inst
operator|&
literal|0377
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|>
literal|127
condition|)
block|{
name|data
operator||=
operator|~
literal|0377
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\tmoveq\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|IMDF
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",d%D"
argument_list|,
operator|(
name|inst
operator|>>
literal|9
operator|)
operator|&
literal|07
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|oprint
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|ostop
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
name|short
name|w
decl_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
name|opcode
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|orts
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
if|if
condition|(
name|following
condition|)
block|{
name|callnews
argument_list|(
comment|/* iscall = */
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_tracing
condition|)
block|{
name|addr
operator|=
name|currtnaddr
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|stepto
argument_list|(
name|instaddr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|addr
operator|=
name|currtnaddr
argument_list|()
expr_stmt|;
block|}
block|}
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|pc
expr_stmt|;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Not used by C compiler; does an rts but before doing so, pops  * arg bytes from the stack.  */
end_comment

begin_function
name|public
name|ortspop
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
specifier|register
name|String
name|opcode
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|short
name|w
decl_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|following
condition|)
block|{
name|callnews
argument_list|(
comment|/* iscall = */
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_tracing
condition|)
block|{
name|addr
operator|=
name|currtnaddr
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
block|}
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|pc
expr_stmt|;
block|}
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
name|opcode
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|omovs
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
name|String
name|opcode
decl_stmt|;
block|{
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|unsigned
name|int
name|controlword
decl_stmt|;
name|short
name|w
decl_stmt|;
name|size
operator|=
name|mapsize
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|controlword
operator|=
name|w
operator|>>
literal|11
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s%c\t"
argument_list|,
name|opcode
argument_list|,
name|suffix
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|controlword
operator|&
literal|1
condition|)
block|{
name|controlword
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
operator|(
name|controlword
operator|&
literal|0x8
operator|)
condition|?
literal|"a%D,"
else|:
literal|"d%D,"
argument_list|,
name|controlword
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
name|printEA
argument_list|(
name|inst
operator|&
literal|0xff
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|controlword
operator|>>=
literal|1
expr_stmt|;
name|printEA
argument_list|(
name|inst
operator|&
literal|0xff
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|printf
argument_list|(
operator|(
name|controlword
operator|&
literal|0x8
operator|)
condition|?
literal|",a%D"
else|:
literal|",d%D"
argument_list|,
name|controlword
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|public
name|omovc
parameter_list|(
name|inst
parameter_list|,
name|opcode
parameter_list|)
name|long
name|inst
decl_stmt|;
name|String
name|opcode
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|controlword
decl_stmt|;
name|String
name|creg
decl_stmt|;
name|short
name|w
decl_stmt|;
name|instread
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|printing
condition|)
block|{
name|controlword
operator|=
name|w
expr_stmt|;
switch|switch
condition|(
name|controlword
operator|&
literal|0xfff
condition|)
block|{
case|case
literal|0
case|:
name|creg
operator|=
literal|"sfc"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|creg
operator|=
literal|"dfc"
expr_stmt|;
break|break;
case|case
literal|0x800
case|:
name|creg
operator|=
literal|"usp"
expr_stmt|;
break|break;
case|case
literal|0x801
case|:
name|creg
operator|=
literal|"vbr"
expr_stmt|;
break|break;
default|default:
name|creg
operator|=
literal|"???"
expr_stmt|;
break|break;
block|}
name|controlword
operator|>>=
literal|12
expr_stmt|;
if|if
condition|(
name|inst
operator|&
literal|1
condition|)
block|{
name|printf
argument_list|(
operator|(
name|controlword
operator|&
literal|0x8
operator|)
condition|?
literal|"%sa%D,%s"
else|:
literal|"%sd%D,%s"
argument_list|,
name|opcode
argument_list|,
name|controlword
operator|&
literal|7
argument_list|,
name|creg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
operator|(
name|controlword
operator|&
literal|0x8
operator|)
condition|?
literal|"%s%s,a%D"
else|:
literal|"%s%s,d%D"
argument_list|,
name|opcode
argument_list|,
name|creg
argument_list|,
name|controlword
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the next address that will be executed from the given one.  * If "isnext" is true then consider a procedure call as straight line code.  *  * Unconditional branches we just follow, for conditional branches  * we continue execution to the current location and then single step  * the machine.  */
end_comment

begin_function
name|public
name|Address
name|nextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|Boolean
name|isnext
decl_stmt|;
block|{
name|Optab
modifier|*
name|o
decl_stmt|;
name|short
name|inst
decl_stmt|;
name|instaddr
operator|=
name|usignal
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|instaddr
operator|==
literal|0
name|or
name|instaddr
operator|==
literal|1
condition|)
block|{
name|following
operator|=
name|true
expr_stmt|;
name|followcalls
operator|=
operator|(
name|Boolean
operator|)
operator|(
name|not
name|isnext
operator|)
expr_stmt|;
name|printing
operator|=
name|false
expr_stmt|;
name|iread
argument_list|(
operator|&
name|inst
argument_list|,
name|startaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|startaddr
operator|+
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|o
operator|=
name|decode
argument_list|(
name|inst
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|mask
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[internal error: undecodable op at 0x%x]\n"
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|o
operator|->
name|opfun
call|)
argument_list|(
name|inst
argument_list|,
name|o
operator|->
name|farg
argument_list|)
expr_stmt|;
block|}
name|following
operator|=
name|false
expr_stmt|;
block|}
return|return
name|instaddr
return|;
block|}
end_function

begin_comment
comment|/*  * Step to the given address and then execute one instruction past it.  * Set instaddr to the new instruction address.  */
end_comment

begin_function
name|private
name|steppast
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|instaddr
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a procedure by creating and executing a call instruction.  */
end_comment

begin_define
define|#
directive|define
name|CALLSIZE
value|6
end_define

begin_comment
comment|/* size of call instruction */
end_comment

begin_function
name|public
name|beginproc
parameter_list|(
name|p
parameter_list|)
name|Symbol
name|p
decl_stmt|;
block|{
name|char
name|save
index|[
name|CALLSIZE
index|]
decl_stmt|;
struct|struct
block|{
name|short
name|op
decl_stmt|;
name|char
name|addr
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
comment|/* unaligned long */
block|}
name|call
struct|;
name|long
name|dest
decl_stmt|;
name|pc
operator|=
name|CODESTART
operator|+
literal|6
expr_stmt|;
name|iread
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|.
name|op
operator|=
literal|0x4eb9
expr_stmt|;
comment|/* jsr */
name|dest
operator|=
name|codeloc
argument_list|(
name|p
argument_list|)
operator|-
name|FUNCOFFSET
expr_stmt|;
name|mov
argument_list|(
operator|&
name|dest
argument_list|,
name|call
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|call
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|call
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
comment|/*      * Execute link instruction so the return addr is visible.      */
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Special variables for debugging the kernel.  */
end_comment

begin_decl_stmt
name|public
name|integer
name|masterpcbb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|integer
name|slr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|struct
name|pte
modifier|*
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|getpcb
parameter_list|()
block|{
name|integer
name|i
decl_stmt|;
name|fseek
argument_list|(
name|corefile
argument_list|,
name|masterpcbb
operator|&
operator|~
literal|0x80000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get
argument_list|(
name|corefile
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|.
name|pcb_p0lr
operator|&=
operator|~
name|AST_CLR
expr_stmt|;
name|printf
argument_list|(
literal|"p0br %lx p0lr %lx p1br %lx p1lr %lx\n"
argument_list|,
name|pcb
operator|.
name|pcb_p0br
argument_list|,
name|pcb
operator|.
name|pcb_p0lr
argument_list|,
name|pcb
operator|.
name|pcb_p1br
argument_list|,
name|pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
block|{
name|setreg
argument_list|(
name|i
argument_list|,
name|pcb
operator|.
name|pcb_regs
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* IRIS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
block|{
name|setreg
argument_list|(
name|i
argument_list|,
name|pcb
operator|.
name|pcb_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|public
name|copyregs
argument_list|(
name|savreg
argument_list|,
name|reg
argument_list|)
name|Word
name|savreg
index|[]
decl_stmt|,
name|reg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
index|[
literal|0
index|]
operator|=
name|savreg
index|[
name|R0
index|]
expr_stmt|;
name|reg
index|[
literal|1
index|]
operator|=
name|savreg
index|[
name|R1
index|]
expr_stmt|;
name|reg
index|[
literal|2
index|]
operator|=
name|savreg
index|[
name|R2
index|]
expr_stmt|;
name|reg
index|[
literal|3
index|]
operator|=
name|savreg
index|[
name|R3
index|]
expr_stmt|;
name|reg
index|[
literal|4
index|]
operator|=
name|savreg
index|[
name|R4
index|]
expr_stmt|;
name|reg
index|[
literal|5
index|]
operator|=
name|savreg
index|[
name|R5
index|]
expr_stmt|;
name|reg
index|[
literal|6
index|]
operator|=
name|savreg
index|[
name|R6
index|]
expr_stmt|;
name|reg
index|[
literal|7
index|]
operator|=
name|savreg
index|[
name|R7
index|]
expr_stmt|;
name|reg
index|[
literal|8
index|]
operator|=
name|savreg
index|[
name|AR0
index|]
expr_stmt|;
name|reg
index|[
literal|9
index|]
operator|=
name|savreg
index|[
name|AR1
index|]
expr_stmt|;
name|reg
index|[
literal|10
index|]
operator|=
name|savreg
index|[
name|AR2
index|]
expr_stmt|;
name|reg
index|[
literal|11
index|]
operator|=
name|savreg
index|[
name|AR3
index|]
expr_stmt|;
name|reg
index|[
literal|12
index|]
operator|=
name|savreg
index|[
name|AR4
index|]
expr_stmt|;
name|reg
index|[
literal|13
index|]
operator|=
name|savreg
index|[
name|AR5
index|]
expr_stmt|;
name|reg
index|[
literal|14
index|]
operator|=
name|savreg
index|[
name|AR6
index|]
expr_stmt|;
name|reg
index|[
literal|15
index|]
operator|=
name|savreg
index|[
name|AR7
index|]
expr_stmt|;
name|reg
index|[
name|PROGCTR
index|]
operator|=
name|savreg
index|[
name|PC
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map a virtual address to a physical address.  * XXX THIS CAN'T BE RIGHT... XXX  */
end_comment

begin_function
name|public
name|Address
name|vmap
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Address
name|r
decl_stmt|;
name|integer
name|v
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
name|r
operator|=
name|addr
operator|&
operator|~
literal|0xc0000000
expr_stmt|;
name|v
operator|=
name|btop
argument_list|(
name|r
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addr
operator|&
literal|0xc0000000
condition|)
block|{
case|case
literal|0xc0000000
case|:
case|case
literal|0x80000000
case|:
comment|/* 	     * In system space, so get system pte. 	     * If it is valid or reclaimable then the physical address 	     * is the combination of its page number and the page offset 	     * of the original address. 	     */
if|if
condition|(
name|v
operator|>=
name|slr
condition|)
block|{
name|error
argument_list|(
literal|"address %x out of segment"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|sbr
operator|+
name|v
argument_list|)
operator|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
goto|goto
name|simple
goto|;
case|case
literal|0x40000000
case|:
comment|/* 	     * In p1 space, must not be in shadow region. 	     */
if|if
condition|(
name|v
operator|<
name|pcb
operator|.
name|pcb_p1lr
condition|)
block|{
name|error
argument_list|(
literal|"address %x out of segment"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
call|(
name|Address
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p1br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00000000
case|:
comment|/* 	     * In p0 space, must not be off end of region. 	     */
if|if
condition|(
name|v
operator|>=
name|pcb
operator|.
name|pcb_p0lr
condition|)
block|{
name|error
argument_list|(
literal|"address %x out of segment"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
call|(
name|Address
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p0br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
comment|/*      * For p0/p1 address, user-level page table should be in      * kernel virtual memory.  Do second-level indirect by recursing.      */
if|if
condition|(
operator|(
name|r
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"bad p0br or p1br in pcb"
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|vmap
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|simple
label|:
comment|/*      * "r" is now the address of the pte of the page      * we are interested in; get the pte and paste up the physical address.      */
name|fseek
argument_list|(
name|corefile
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|fread
argument_list|(
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|corefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"page table botch (fread at %x returns %d)"
argument_list|,
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pte
operator|.
name|pg_v
operator|==
literal|0
name|and
argument_list|(
argument|pte.pg_fod !=
literal|0
argument|or pte.pg_pfnum ==
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"page no valid or reclamable"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
operator|+
operator|(
operator|(
name|Address
operator|)
name|ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract a bit field from an integer.  */
end_comment

begin_function
name|public
name|integer
name|extractField
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|integer
name|nbytes
decl_stmt|,
name|nbits
decl_stmt|,
name|n
decl_stmt|,
name|r
decl_stmt|,
name|off
decl_stmt|,
name|len
decl_stmt|;
name|off
operator|=
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
expr_stmt|;
name|len
operator|=
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
expr_stmt|;
name|nbytes
operator|=
name|size
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[bad size in extractField -- word assumed]\n"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|popn
argument_list|(
name|nbytes
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|n
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|-
name|nbytes
operator|)
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|nbytes
operator|*
name|BITSPERBYTE
expr_stmt|;
name|r
operator|=
name|n
operator|>>
operator|(
name|nbits
operator|-
operator|(
operator|(
name|off
name|mod
name|nbits
operator|)
operator|+
name|len
operator|)
operator|)
expr_stmt|;
name|r
operator|&=
operator|(
operator|(
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Change the length of a value in memory according to a given difference  * in the lengths of its new and old types.  */
end_comment

begin_function
name|public
name|loophole
parameter_list|(
name|oldlen
parameter_list|,
name|newlen
parameter_list|)
name|integer
name|oldlen
decl_stmt|,
name|newlen
decl_stmt|;
block|{
name|integer
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Stack
modifier|*
name|oldsp
decl_stmt|;
name|n
operator|=
name|newlen
operator|-
name|oldlen
expr_stmt|;
name|oldsp
operator|=
name|sp
operator|-
name|oldlen
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|oldlen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|oldsp
index|[
name|n
operator|+
name|i
index|]
operator|=
name|oldsp
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|oldsp
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newlen
condition|;
name|i
operator|++
control|)
block|{
name|oldsp
index|[
name|i
index|]
operator|=
name|oldsp
index|[
name|i
operator|-
name|n
index|]
expr_stmt|;
block|}
block|}
name|sp
operator|+=
name|n
expr_stmt|;
block|}
end_function

end_unit

