begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)machdep.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - miscellaneous machine dependent routines.  */
end_comment

begin_define
define|#
directive|define
name|RLOCALS
end_define

begin_comment
comment|/* enable alternate $C stack trace */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bkpt.h"
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmac.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_decl_stmt
name|struct
name|pte
modifier|*
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|masterpcbb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Activation records.  */
end_comment

begin_comment
comment|/*  * Set up a stack frame based on the registers in the core image  * (or in the kernel core file ... not yet!).  */
end_comment

begin_expr_stmt
name|a_init
argument_list|(
name|ap
argument_list|)
specifier|register
expr|struct
name|activation
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|ap
operator|->
name|a_valid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|kcore
condition|)
block|{
name|ap
operator|->
name|a_fp
operator|=
name|pcb
operator|.
name|pcb_fp
expr_stmt|;
name|ap
operator|->
name|a_pc
operator|=
name|pcb
operator|.
name|pcb_pc
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|a_fp
operator|=
name|u
operator|.
name|u_ar0
index|[
name|FP
index|]
expr_stmt|;
name|ap
operator|->
name|a_pc
operator|=
name|u
operator|.
name|u_ar0
index|[
name|PC
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Back up one stack frame in the call stack.  * ap points to the activation record from the previous frame.  * Clear a_valid field if we ran out of frames.  */
end_comment

begin_expr_stmt
name|a_back
argument_list|(
name|ap
argument_list|)
specifier|register
expr|struct
name|activation
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|frame
name|fr
decl_stmt|;
if|if
condition|(
name|adbread
argument_list|(
name|SP_DATA
argument_list|,
name|ap
operator|->
name|a_fp
operator|-
name|FRAMEOFF
argument_list|,
operator|&
name|fr
argument_list|,
sizeof|sizeof
name|fr
argument_list|)
operator|!=
sizeof|sizeof
name|fr
condition|)
name|ap
operator|->
name|a_valid
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ap
operator|->
name|a_fp
operator|=
name|fr
operator|.
name|fr_savfp
expr_stmt|;
name|ap
operator|->
name|a_pc
operator|=
name|fr
operator|.
name|fr_savpc
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_fp
operator|==
literal|0
condition|)
name|ap
operator|->
name|a_valid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Evaluate a local symbol (N_LSYM or N_PSYM) using the activation  * record pointed to by ap.  */
end_comment

begin_function
name|addr_t
name|eval_localsym
parameter_list|(
name|sp
parameter_list|,
name|ap
parameter_list|)
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|activation
modifier|*
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|sp
operator|->
name|n_type
condition|)
block|{
case|case
name|N_LSYM
case|:
return|return
operator|(
name|ap
operator|->
name|a_fp
operator|-
name|sp
operator|->
name|n_value
operator|)
return|;
case|case
name|N_PSYM
case|:
return|return
operator|(
name|ap
operator|->
name|a_fp
operator|+
name|sp
operator|->
name|n_value
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"eval_localsym"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* true iff address a is in instruction space */
end_comment

begin_define
define|#
directive|define
name|ispace
parameter_list|(
name|a
parameter_list|)
value|((a)< txtmap.m1.e)
end_define

begin_comment
comment|/*  * Delete a (single) breakpoint.  Return 0 on success.  */
end_comment

begin_function
name|int
name|clr_bpt
parameter_list|(
name|b
parameter_list|)
name|struct
name|bkpt
modifier|*
name|b
decl_stmt|;
block|{
name|addr_t
name|a
init|=
name|b
operator|->
name|loc
decl_stmt|;
return|return
operator|(
name|adbwrite
argument_list|(
name|ispace
argument_list|(
name|a
argument_list|)
condition|?
name|SP_INSTR
else|:
name|SP_DATA
argument_list|,
name|a
argument_list|,
operator|&
name|b
operator|->
name|ins
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a (single) breakpoint.  Return 0 on success.  */
end_comment

begin_macro
name|set_bpt
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|bkpt
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|addr_t
name|a
init|=
name|b
operator|->
name|loc
decl_stmt|;
name|int
name|space
decl_stmt|;
name|char
name|bpt
init|=
literal|0x30
decl_stmt|;
comment|/* breakpoint instruction */
name|space
operator|=
name|ispace
argument_list|(
name|a
argument_list|)
condition|?
name|SP_INSTR
else|:
name|SP_DATA
expr_stmt|;
return|return
operator|(
name|adbread
argument_list|(
name|space
argument_list|,
name|a
argument_list|,
operator|&
name|b
operator|->
name|ins
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|||
name|adbwrite
argument_list|(
name|space
argument_list|,
name|a
argument_list|,
operator|&
name|bpt
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check a float for `correctness' (reserved patterns, etc).  Return  * a pointer to a character string to be printed instead of the float,  * or NULL to print the float as-is.  *  * The string returned, if any, should be no longer than 16 characters.  *  * On the Tahoe, we can simply check the second two bytes.  Byte two  * contains one bit of the exponent, and byte 3 has the remaining 7  * exponent bits and the sign bit.  If the sign bit is set and the  * exponent is zero, the value is reserved.  *  * PLEASE CHECK THE ABOVE, IT IS PROBABLY WRONG  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
name|checkfloat
parameter_list|(
name|fp
parameter_list|,
name|isdouble
parameter_list|)
name|caddr_t
name|fp
decl_stmt|;
name|int
name|isdouble
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|fp
operator|)
index|[
literal|1
index|]
operator|&
literal|0xff80
operator|)
operator|==
literal|0x8000
condition|?
literal|"(reserved oprnd)"
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a value in `expr_t' format to float or double.  */
end_comment

begin_macro
name|etofloat
argument_list|(
argument|e
argument_list|,
argument|fp
argument_list|,
argument|isdouble
argument_list|)
end_macro

begin_decl_stmt
name|expr_t
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isdouble
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|isdouble
condition|)
operator|(
operator|(
name|int
operator|*
operator|)
name|fp
operator|)
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|fp
operator|=
name|e
expr_stmt|;
block|}
end_block

begin_macro
name|mch_init
argument_list|()
end_macro

begin_block
block|{
name|mkioptab
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* quietly read object obj from address addr */
end_comment

begin_define
define|#
directive|define
name|GET
parameter_list|(
name|obj
parameter_list|,
name|addr
parameter_list|)
value|(void) adbread(SP_DATA, addr,&(obj), sizeof(obj))
end_define

begin_comment
comment|/* set `current process' pcb */
end_comment

begin_macro
name|setpcb
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|addr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pte
decl_stmt|;
name|GET
argument_list|(
name|pte
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|masterpcbb
operator|=
operator|(
name|pte
operator|&
name|PG_PFNUM
operator|)
operator|*
name|NBPG
expr_stmt|;
block|}
end_block

begin_macro
name|getpcb
argument_list|()
end_macro

begin_block
block|{
comment|/* maybe use adbread() here ... */
operator|(
name|void
operator|)
name|readcore
argument_list|(
operator|(
name|off_t
operator|)
name|masterpcbb
operator|&
operator|~
name|KERNBASE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcb
argument_list|)
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|"p0br %R p0lr %R p2br %R p2lr %R\n"
argument_list|,
name|pcb
operator|.
name|pcb_p0br
argument_list|,
name|pcb
operator|.
name|pcb_p0lr
argument_list|,
name|pcb
operator|.
name|pcb_p2br
argument_list|,
name|pcb
operator|.
name|pcb_p2lr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert a kernel virtual address to a physical address,  * a la the Tahoe hardware.  Set *err if the resulting address  * is invalid.  */
end_comment

begin_function
name|addr_t
name|vtophys
parameter_list|(
name|addr
parameter_list|,
name|err
parameter_list|)
name|addr_t
name|addr
decl_stmt|;
name|char
modifier|*
modifier|*
name|err
decl_stmt|;
block|{
specifier|register
name|unsigned
name|v
init|=
name|btop
argument_list|(
name|addr
operator|&
operator|~
name|KERNBASE
argument_list|)
decl_stmt|;
specifier|register
name|addr_t
name|pteaddr
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|30
argument_list|)
condition|)
block|{
comment|/* select space */
case|case
literal|3
case|:
comment|/* system space: get system pte */
if|if
condition|(
name|v
operator|>=
name|slr
condition|)
goto|goto
name|oor
goto|;
name|pteaddr
operator|=
call|(
name|addr_t
call|)
argument_list|(
name|sbr
operator|+
name|v
argument_list|)
operator|&
operator|~
name|KERNBASE
expr_stmt|;
goto|goto
name|direct
goto|;
case|case
literal|2
case|:
comment|/* P2 space: must not be in shadow region */
if|if
condition|(
name|v
operator|<
name|pcb
operator|.
name|pcb_p2lr
condition|)
goto|goto
name|oor
goto|;
name|pteaddr
operator|=
call|(
name|addr_t
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p2br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* P1 space: verboten (for now) */
goto|goto
name|oor
goto|;
case|case
literal|0
case|:
comment|/* P0 space: must not be off end of region */
if|if
condition|(
name|v
operator|>=
name|pcb
operator|.
name|pcb_p0lr
condition|)
goto|goto
name|oor
goto|;
name|pteaddr
operator|=
call|(
name|addr_t
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p0br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
name|oor
label|:
operator|*
name|err
operator|=
literal|"address out of segment"
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* in P0/P1/P2 space, pte should be in kernel virtual space */
if|if
condition|(
operator|(
name|pteaddr
operator|&
name|KERNBASE
operator|)
operator|!=
name|KERNBASE
condition|)
block|{
operator|*
name|err
operator|=
literal|"bad p0br, p1br, or p2br in pcb"
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pteaddr
operator|=
name|vtophys
argument_list|(
name|pteaddr
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|direct
label|:
comment|/* 	 * Read system pte.  If valid or reclaimable, 	 * physical address is combination of its page number and 	 * the page offset of the original address. 	 */
if|if
condition|(
name|readcore
argument_list|(
operator|(
name|off_t
operator|)
name|pteaddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pte
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
block|{
operator|*
name|err
operator|=
literal|"page table botch"
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* SHOULD CHECK NOT I/O ADDRESS; NEED CPU TYPE! */
if|if
condition|(
name|pte
operator|.
name|pg_v
operator|==
literal|0
operator|&&
operator|(
name|pte
operator|.
name|pg_fod
operator|||
name|pte
operator|.
name|pg_pfnum
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|err
operator|=
literal|"page not valid/reclaimable"
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
call|(
name|addr_t
call|)
argument_list|(
name|ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a stack trace ($c, $C).  Trace backwards through nback  * frames; if locals is set, print local variables.  */
end_comment

begin_macro
name|printstack
argument_list|(
argument|locals
argument_list|,
argument|nback
argument_list|)
end_macro

begin_decl_stmt
name|int
name|locals
decl_stmt|,
name|nback
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|addr_t
name|a
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|addr_t
name|callpc
decl_stmt|;
comment|/* pc that called this frame */
name|int
name|narg
decl_stmt|;
comment|/* number of arguments to this frame */
name|struct
name|activation
name|cur
decl_stmt|;
comment|/* this frame itself */
name|struct
name|frame
name|fr
decl_stmt|;
comment|/* the frame above this frame */
name|addr_t
name|dummy
decl_stmt|;
comment|/* a variable to scribble on */
define|#
directive|define
name|UNKNOWN
value|-1
ifdef|#
directive|ifdef
name|RLOCALS
comment|/* if locals variables are broken, use an alternate strategy */
specifier|register
name|int
name|r
decl_stmt|;
name|addr_t
name|sp
decl_stmt|,
name|prev_sp
decl_stmt|;
name|int
name|regs
index|[
literal|13
index|]
decl_stmt|;
specifier|static
name|char
name|unknown
index|[]
init|=
literal|"<unknown>"
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLOCALS
comment|/* grab registers */
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|kcore
condition|?
operator|&
name|pcb
operator|.
name|pcb_r0
else|:
operator|&
name|u
operator|.
name|u_ar0
index|[
name|R0
index|]
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|regs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set up the current stack frame */
if|if
condition|(
name|gavedot
condition|)
block|{
name|cur
operator|.
name|a_fp
operator|=
name|dot
expr_stmt|;
name|cur
operator|.
name|a_pc
operator|=
name|UNKNOWN
expr_stmt|;
ifdef|#
directive|ifdef
name|RLOCALS
name|sp
operator|=
name|UNKNOWN
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|kcore
condition|)
block|{
name|cur
operator|.
name|a_fp
operator|=
name|pcb
operator|.
name|pcb_fp
expr_stmt|;
name|cur
operator|.
name|a_pc
operator|=
name|pcb
operator|.
name|pcb_pc
expr_stmt|;
ifdef|#
directive|ifdef
name|RLOCALS
name|sp
operator|=
name|pcb
operator|.
name|pcb_ksp
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|cur
operator|.
name|a_fp
operator|=
name|u
operator|.
name|u_ar0
index|[
name|FP
index|]
expr_stmt|;
name|cur
operator|.
name|a_pc
operator|=
name|u
operator|.
name|u_ar0
index|[
name|PC
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|RLOCALS
name|sp
operator|=
name|u
operator|.
name|u_ar0
index|[
name|SP
index|]
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* now back up through the stack */
while|while
condition|(
name|nback
operator|--
operator|&&
name|cur
operator|.
name|a_fp
operator|!=
literal|0
condition|)
block|{
comment|/* read this frame, but defer error check */
name|GET
argument_list|(
name|fr
argument_list|,
name|cur
operator|.
name|a_fp
operator|-
name|FRAMEOFF
argument_list|)
expr_stmt|;
comment|/* where are we? ... if u. area, signal trampoline code */
if|if
condition|(
name|cur
operator|.
name|a_pc
operator|>=
name|USRSTACK
operator|&&
name|cur
operator|.
name|a_pc
operator|<
name|KERNBASE
condition|)
block|{
name|narg
operator|=
literal|0
expr_stmt|;
name|GET
argument_list|(
name|callpc
argument_list|,
name|cur
operator|.
name|a_fp
operator|+
literal|44
argument_list|)
expr_stmt|;
comment|/* XXX magic 44 */
name|s
operator|=
literal|"sigtramp"
expr_stmt|;
block|}
else|else
block|{
name|narg
operator|=
operator|(
name|fr
operator|.
name|fr_removed
operator|>>
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
name|callpc
operator|=
name|fr
operator|.
name|fr_savpc
expr_stmt|;
if|if
condition|(
name|cur
operator|.
name|a_pc
operator|!=
name|UNKNOWN
operator|&&
operator|(
name|sym
operator|=
name|findsym
argument_list|(
name|cur
operator|.
name|a_pc
argument_list|,
name|SP_INSTR
argument_list|,
operator|&
name|dummy
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|sym
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
name|eqstr
argument_list|(
name|s
argument_list|,
literal|"start"
argument_list|)
condition|)
block|{
name|errflag
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|s
operator|=
literal|"?"
expr_stmt|;
block|}
comment|/* safe at last to check for error reading frame */
name|checkerr
argument_list|()
expr_stmt|;
comment|/* arguments */
name|adbprintf
argument_list|(
literal|"%s("
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|a
operator|=
name|cur
operator|.
name|a_fp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|narg
init|;
name|i
condition|;
control|)
block|{
name|prfrom
argument_list|(
name|a
operator|+=
literal|4
argument_list|,
operator|--
name|i
condition|?
literal|','
else|:
literal|0
argument_list|)
expr_stmt|;
name|checkerr
argument_list|()
expr_stmt|;
block|}
name|printc
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|.
name|a_pc
operator|!=
name|UNKNOWN
condition|)
block|{
name|prints
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
literal|"%R"
argument_list|,
name|cur
operator|.
name|a_pc
argument_list|,
name|SP_INSTR
argument_list|,
operator|-
operator|(
name|addr_t
operator|)
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* local variables */
if|if
condition|(
name|locals
condition|)
block|{
ifdef|#
directive|ifdef
name|busted
if|if
condition|(
name|cur
operator|.
name|a_pc
operator|!=
name|UNKNOWN
condition|)
block|{
name|sym
operator|=
name|findsym
argument_list|(
name|cur
operator|.
name|a_pc
argument_list|,
name|SP_INSTR
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sym
operator|=
name|nextlocal
argument_list|(
name|sym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|adbprintf
argument_list|(
literal|"%8t"
argument_list|)
expr_stmt|;
name|printlsym
argument_list|(
name|sym
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|":%12t"
argument_list|)
expr_stmt|;
name|prfrom
argument_list|(
name|eval_localsym
argument_list|(
name|sym
argument_list|,
operator|&
name|cur
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLOCALS
name|adbprintf
argument_list|(
literal|"\ fp: %R\%16tsp:  %?s%?R%32tpc:  %?s%?R%48tr0:  %R\n\ r1: %R\%16tr2:  %R\%32tr3:  %R\%48tr4:  %R\n\ r5: %R\%16tr6:  %R\%32tr7:  %R\%48tr8:  %R\n\ r9: %R\%16tr10: %R\%32tr11: %R\%48tr12: %R\n"
argument_list|,
define|#
directive|define
name|q
parameter_list|(
name|s
parameter_list|)
value|s == UNKNOWN, unknown, s != UNKNOWN, s
name|cur
operator|.
name|a_fp
argument_list|,
name|q
argument_list|(
name|sp
argument_list|)
argument_list|,
name|q
argument_list|(
name|cur
operator|.
name|a_pc
argument_list|)
argument_list|,
name|regs
index|[
literal|0
index|]
argument_list|,
undef|#
directive|undef
name|q
name|regs
index|[
literal|1
index|]
argument_list|,
name|regs
index|[
literal|2
index|]
argument_list|,
name|regs
index|[
literal|3
index|]
argument_list|,
name|regs
index|[
literal|4
index|]
argument_list|,
name|regs
index|[
literal|5
index|]
argument_list|,
name|regs
index|[
literal|6
index|]
argument_list|,
name|regs
index|[
literal|7
index|]
argument_list|,
name|regs
index|[
literal|8
index|]
argument_list|,
name|regs
index|[
literal|9
index|]
argument_list|,
name|regs
index|[
literal|10
index|]
argument_list|,
name|regs
index|[
literal|11
index|]
argument_list|,
name|regs
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* update registers, and find previous frame's sp */
name|a
operator|=
name|cur
operator|.
name|a_fp
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
operator|,
name|i
operator|=
name|fr
operator|.
name|fr_mask
init|;
name|i
operator|!=
literal|0
condition|;
name|r
operator|++
operator|,
name|i
operator|>>=
literal|1
control|)
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|GET
argument_list|(
name|regs
index|[
name|r
index|]
argument_list|,
name|a
operator|+=
literal|4
argument_list|)
expr_stmt|;
name|a
operator|+=
name|narg
operator|*
literal|4
expr_stmt|;
name|prev_sp
operator|=
name|a
expr_stmt|;
comment|/* now print automatics */
if|if
condition|(
name|sp
operator|!=
name|UNKNOWN
condition|)
block|{
define|#
directive|define
name|MAXPRINT
value|30
comment|/* max # words to print */
comment|/* XXX should be settable */
name|i
operator|=
operator|(
name|cur
operator|.
name|a_fp
operator|-
name|sp
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MAXPRINT
condition|)
name|i
operator|=
name|MAXPRINT
expr_stmt|;
for|for
control|(
name|a
operator|=
name|cur
operator|.
name|a_fp
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|a
operator|-=
literal|4
expr_stmt|;
name|adbprintf
argument_list|(
literal|"%R: %V(fp):%24t"
argument_list|,
name|a
argument_list|,
name|a
operator|-
name|cur
operator|.
name|a_fp
argument_list|)
expr_stmt|;
name|prfrom
argument_list|(
name|a
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|>
name|sp
condition|)
name|adbprintf
argument_list|(
literal|"\ %R: %V(fp) .. %R: %V(fp) not displayed\n"
argument_list|,
name|a
argument_list|,
name|a
operator|-
name|cur
operator|.
name|a_fp
argument_list|,
name|sp
argument_list|,
name|sp
operator|-
name|cur
operator|.
name|a_fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLOCALS */
block|}
name|errflag
operator|=
name|NULL
expr_stmt|;
comment|/* clobber any read errors */
comment|/* back up one frame */
if|if
condition|(
name|fr
operator|.
name|fr_savfp
operator|==
literal|0
condition|)
break|break;
name|cur
operator|.
name|a_fp
operator|=
name|fr
operator|.
name|fr_savfp
expr_stmt|;
ifdef|#
directive|ifdef
name|RLOCALS
name|sp
operator|=
name|prev_sp
expr_stmt|;
endif|#
directive|endif
name|cur
operator|.
name|a_pc
operator|=
name|callpc
expr_stmt|;
if|if
condition|(
operator|!
name|gavedot
operator|&&
operator|!
name|INSTACK
argument_list|(
name|cur
operator|.
name|a_fp
argument_list|)
operator|&&
operator|!
name|kcore
condition|)
break|break;
comment|/* make sure we returned somewhere... */
operator|(
name|void
operator|)
name|adbread
argument_list|(
name|kcore
condition|?
name|SP_DATA
else|:
name|SP_INSTR
argument_list|,
name|cur
operator|.
name|a_pc
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkerr
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Register offset to u. pointer, and register offset to ptrace value  */
end_comment

begin_define
define|#
directive|define
name|otoua
parameter_list|(
name|o
parameter_list|)
define|\
value|((int *)(((o)< 0 ? (int)u.u_ar0 : (int)&u.u_pcb) + (o)))
end_define

begin_define
define|#
directive|define
name|otopt
parameter_list|(
name|o
parameter_list|)
define|\
value|((int *)((o)< 0 ? (o) + ctob(UPAGES) : (o)))
end_define

begin_comment
comment|/*  * Return the value of some register.  */
end_comment

begin_function
name|expr_t
name|getreg
parameter_list|(
name|reg
parameter_list|)
specifier|register
name|struct
name|reglist
modifier|*
name|reg
decl_stmt|;
block|{
return|return
operator|(
name|kcore
condition|?
operator|*
name|reg
operator|->
name|r_pcbaddr
else|:
operator|*
name|otoua
argument_list|(
name|reg
operator|->
name|r_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the value of some register.  Return 0 if all goes well.  */
end_comment

begin_expr_stmt
name|setreg
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
specifier|register
expr|struct
name|reglist
operator|*
name|reg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|expr_t
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|kcore
condition|)
operator|*
name|reg
operator|->
name|r_pcbaddr
operator|=
name|val
expr_stmt|;
else|else
block|{
operator|*
name|otoua
argument_list|(
name|reg
operator|->
name|r_offset
argument_list|)
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|pid
argument_list|,
name|otopt
argument_list|(
name|reg
operator|->
name|r_offset
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read registers from current process.  */
end_comment

begin_macro
name|readregs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|reglist
modifier|*
name|reg
decl_stmt|;
specifier|extern
name|struct
name|reglist
name|reglist
index|[]
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|reglist
init|;
name|reg
operator|->
name|r_name
operator|!=
name|NULL
condition|;
name|reg
operator|++
control|)
operator|*
name|otoua
argument_list|(
name|reg
operator|->
name|r_offset
argument_list|)
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|pid
argument_list|,
name|otopt
argument_list|(
name|reg
operator|->
name|r_offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|addr_t
name|getpc
parameter_list|()
block|{
return|return
operator|(
name|kcore
condition|?
name|pcb
operator|.
name|pcb_pc
else|:
name|u
operator|.
name|u_ar0
index|[
name|PC
index|]
operator|)
return|;
block|}
end_function

begin_macro
name|setpc
argument_list|(
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|addr_t
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|kcore
condition|)
name|pcb
operator|.
name|pcb_pc
operator|=
name|where
expr_stmt|;
else|else
name|u
operator|.
name|u_ar0
index|[
name|PC
index|]
operator|=
name|where
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * udot returns true if u.u_pcb appears correct.  More extensive  * checking is possible....  */
end_comment

begin_macro
name|udot
argument_list|()
end_macro

begin_block
block|{
comment|/* user stack should be in stack segment */
if|if
condition|(
operator|!
name|INSTACK
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_usp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* kernel stack should be in u. area */
if|if
condition|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_ksp
operator|<
name|USRSTACK
operator|||
name|u
operator|.
name|u_pcb
operator|.
name|pcb_ksp
operator|>=
name|KERNBASE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* looks good to us... */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|sigprint
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|illinames
index|[]
decl_stmt|,
modifier|*
name|fpenames
index|[]
decl_stmt|;
specifier|extern
name|int
name|nillinames
decl_stmt|,
name|nfpenames
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|signo
operator|-
literal|1
operator|<
name|NSIG
operator|-
literal|1
condition|)
name|prints
argument_list|(
name|sys_siglist
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGFPE
case|:
if|if
condition|(
operator|(
name|u_int
operator|)
name|sigcode
operator|<
name|nfpenames
condition|)
name|prints
argument_list|(
name|fpenames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGILL
case|:
if|if
condition|(
operator|(
name|u_int
operator|)
name|sigcode
operator|<
name|nillinames
condition|)
name|prints
argument_list|(
name|illinames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

