begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)move.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"back.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|FILE
modifier|*
name|trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tests
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|BOARD
block|{
comment|/* structure of game position */
name|int
name|b_board
index|[
literal|26
index|]
decl_stmt|;
comment|/* board position */
name|int
name|b_in
index|[
literal|2
index|]
decl_stmt|;
comment|/* men in */
name|int
name|b_off
index|[
literal|2
index|]
decl_stmt|;
comment|/* men off */
name|int
name|b_st
index|[
literal|4
index|]
decl_stmt|,
name|b_fn
index|[
literal|4
index|]
decl_stmt|;
comment|/* moves */
name|struct
name|BOARD
modifier|*
name|b_next
decl_stmt|;
comment|/* forward queue pointer */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|BOARD
modifier|*
name|freeq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|BOARD
modifier|*
name|checkq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|BOARD
modifier|*
name|bsave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|BOARD
modifier|*
name|nextfree
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* these variables are values for the 					 * candidate move */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chance of being hit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* computer's open men */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* comp's protected points */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* farthest man back */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chance to free comp's men */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chance to free pl's men */
end_comment

begin_comment
comment|/* these values are the values for the 					 * move chosen (so far) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chance
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chance of being hit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|openmen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* computer's open men */
end_comment

begin_decl_stmt
specifier|static
name|int
name|points
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* comp's protected points */
end_comment

begin_decl_stmt
specifier|static
name|int
name|endman
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* farthest man back */
end_comment

begin_decl_stmt
specifier|static
name|int
name|barmen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* men on bar */
end_comment

begin_decl_stmt
specifier|static
name|int
name|menin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* men in inner table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|menoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* men off board */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldfrc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chance to free comp's men */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldfrp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chance to free pl's men */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cp
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* candidate start position */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cg
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* candidate finish position */
end_comment

begin_decl_stmt
specifier|static
name|int
name|race
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* game reduced to a race */
end_comment

begin_escape
end_escape

begin_macro
name|move
argument_list|(
argument|okay
argument_list|)
end_macro

begin_decl_stmt
name|int
name|okay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero if first move */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* index */
specifier|register
name|int
name|l
decl_stmt|;
comment|/* last man */
if|if
condition|(
name|okay
condition|)
block|{
comment|/* see if comp should double */
if|if
condition|(
name|gvalue
operator|<
literal|64
operator|&&
name|dlast
operator|!=
name|cturn
operator|&&
name|dblgood
argument_list|()
condition|)
block|{
name|writel
argument_list|(
operator|*
name|Colorptr
argument_list|)
expr_stmt|;
name|dble
argument_list|()
expr_stmt|;
comment|/* double */
comment|/* return if declined */
if|if
condition|(
name|cturn
operator|!=
literal|1
operator|&&
name|cturn
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
name|roll
argument_list|()
expr_stmt|;
block|}
name|race
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|board
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|l
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|board
index|[
name|i
index|]
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|l
condition|)
name|race
operator|=
literal|1
expr_stmt|;
comment|/* print roll */
if|if
condition|(
name|tflag
condition|)
name|curmove
argument_list|(
name|cturn
operator|==
operator|-
literal|1
condition|?
literal|18
else|:
literal|19
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|*
name|Colorptr
argument_list|)
expr_stmt|;
name|writel
argument_list|(
literal|" rolls "
argument_list|)
expr_stmt|;
name|writec
argument_list|(
name|D0
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|writec
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|writec
argument_list|(
name|D1
operator|+
literal|'0'
argument_list|)
expr_stmt|;
comment|/* make tty interruptable 						 * while thinking */
if|if
condition|(
name|tflag
condition|)
name|cline
argument_list|()
expr_stmt|;
name|fixtty
argument_list|(
name|noech
argument_list|)
expr_stmt|;
comment|/* find out how many moves */
name|mvlim
operator|=
name|movallow
argument_list|()
expr_stmt|;
if|if
condition|(
name|mvlim
operator|==
literal|0
condition|)
block|{
name|writel
argument_list|(
literal|" but cannot use it.\n"
argument_list|)
expr_stmt|;
name|nexturn
argument_list|()
expr_stmt|;
name|fixtty
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* initialize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|cp
index|[
name|i
index|]
operator|=
name|cg
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* strategize */
name|trymove
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pickmove
argument_list|()
expr_stmt|;
comment|/* print move */
name|writel
argument_list|(
literal|" and moves "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|writec
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|wrint
argument_list|(
name|p
index|[
name|i
index|]
operator|=
name|cp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|writec
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|wrint
argument_list|(
name|g
index|[
name|i
index|]
operator|=
name|cg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|makmove
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|writec
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
comment|/* print blots hit */
if|if
condition|(
name|tflag
condition|)
name|curmove
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|writec
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h
index|[
name|i
index|]
condition|)
name|wrhit
argument_list|(
name|g
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* get ready for next move */
name|nexturn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|okay
condition|)
block|{
name|buflush
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|fixtty
argument_list|(
name|raw
argument_list|)
expr_stmt|;
comment|/* no more tty interrupt */
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|trymove
argument_list|(
name|mvnum
argument_list|,
name|swapped
argument_list|)
specifier|register
name|int
name|mvnum
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* number of move (rel zero) */
end_comment

begin_decl_stmt
name|int
name|swapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see if swapped also tested */
end_comment

begin_block
block|{
specifier|register
name|int
name|pos
decl_stmt|;
comment|/* position on board */
specifier|register
name|int
name|rval
decl_stmt|;
comment|/* value of roll */
comment|/* if recursed through all dice 						 * values, compare move */
if|if
condition|(
name|mvnum
operator|==
name|mvlim
condition|)
block|{
name|binsert
argument_list|(
name|bsave
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure dice in always 						 * same order */
if|if
condition|(
name|d0
operator|==
name|swapped
condition|)
name|swap
expr_stmt|;
comment|/* choose value for this move */
name|rval
operator|=
name|dice
index|[
name|mvnum
operator|!=
literal|0
index|]
expr_stmt|;
comment|/* find all legitimate moves */
for|for
control|(
name|pos
operator|=
name|bar
init|;
name|pos
operator|!=
name|home
condition|;
name|pos
operator|+=
name|cturn
control|)
block|{
comment|/* fix order of dice */
if|if
condition|(
name|d0
operator|==
name|swapped
condition|)
name|swap
expr_stmt|;
comment|/* break if stuck on bar */
if|if
condition|(
name|board
index|[
name|bar
index|]
operator|!=
literal|0
operator|&&
name|pos
operator|!=
name|bar
condition|)
break|break;
comment|/* on to next if not occupied */
if|if
condition|(
name|board
index|[
name|pos
index|]
operator|*
name|cturn
operator|<=
literal|0
condition|)
continue|continue;
comment|/* set up arrays for move */
name|p
index|[
name|mvnum
index|]
operator|=
name|pos
expr_stmt|;
name|g
index|[
name|mvnum
index|]
operator|=
name|pos
operator|+
name|rval
operator|*
name|cturn
expr_stmt|;
if|if
condition|(
name|g
index|[
name|mvnum
index|]
operator|*
name|cturn
operator|>=
name|home
condition|)
block|{
if|if
condition|(
operator|*
name|offptr
operator|<
literal|0
condition|)
break|break;
name|g
index|[
name|mvnum
index|]
operator|=
name|home
expr_stmt|;
block|}
comment|/* try to move */
if|if
condition|(
name|makmove
argument_list|(
name|mvnum
argument_list|)
condition|)
continue|continue;
else|else
name|trymove
argument_list|(
name|mvnum
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* undo move to try another */
name|backone
argument_list|(
name|mvnum
argument_list|)
expr_stmt|;
block|}
comment|/* swap dice and try again */
if|if
condition|(
operator|(
operator|!
name|swapped
operator|)
operator|&&
name|D0
operator|!=
name|D1
condition|)
name|trymove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|struct
name|BOARD
modifier|*
name|bsave
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* index */
name|struct
name|BOARD
modifier|*
name|now
decl_stmt|;
comment|/* current position */
name|now
operator|=
name|nextfree
argument_list|()
expr_stmt|;
comment|/* get free BOARD */
comment|/* store position */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|now
operator|->
name|b_board
index|[
name|i
index|]
operator|=
name|board
index|[
name|i
index|]
expr_stmt|;
name|now
operator|->
name|b_in
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|now
operator|->
name|b_in
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|now
operator|->
name|b_off
index|[
literal|0
index|]
operator|=
name|off
index|[
literal|0
index|]
expr_stmt|;
name|now
operator|->
name|b_off
index|[
literal|1
index|]
operator|=
name|off
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
block|{
name|now
operator|->
name|b_st
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|now
operator|->
name|b_fn
index|[
name|i
index|]
operator|=
name|g
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|now
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|binsert
argument_list|(
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BOARD
modifier|*
name|new
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* item to insert */
end_comment

begin_block
block|{
specifier|register
name|struct
name|BOARD
modifier|*
name|p
init|=
name|checkq
decl_stmt|;
comment|/* queue pointer */
specifier|register
name|int
name|result
decl_stmt|;
comment|/* comparison result */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/* check if queue empty */
name|checkq
operator|=
name|p
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|b_next
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|result
operator|=
name|bcomp
argument_list|(
name|new
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* compare to first element */
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* insert in front */
name|new
operator|->
name|b_next
operator|=
name|p
expr_stmt|;
name|checkq
operator|=
name|new
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* duplicate entry */
name|mvcheck
argument_list|(
name|p
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|makefree
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|p
operator|->
name|b_next
operator|!=
literal|0
condition|)
block|{
comment|/* traverse queue */
name|result
operator|=
name|bcomp
argument_list|(
name|new
argument_list|,
name|p
operator|->
name|b_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* found place */
name|new
operator|->
name|b_next
operator|=
name|p
operator|->
name|b_next
expr_stmt|;
name|p
operator|->
name|b_next
operator|=
name|new
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* duplicate entry */
name|mvcheck
argument_list|(
name|p
operator|->
name|b_next
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|makefree
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|p
operator|->
name|b_next
expr_stmt|;
block|}
comment|/* place at end of queue */
name|p
operator|->
name|b_next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|b_next
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|bcomp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BOARD
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|BOARD
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|aloc
init|=
name|a
operator|->
name|b_board
decl_stmt|;
comment|/* pointer to board a */
specifier|register
name|int
modifier|*
name|bloc
init|=
name|b
operator|->
name|b_board
decl_stmt|;
comment|/* pointer to board b */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* index */
name|int
name|result
decl_stmt|;
comment|/* comparison result */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
comment|/* compare boards */
name|result
operator|=
name|cturn
operator|*
operator|(
name|aloc
index|[
name|i
index|]
operator|-
name|bloc
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* found inequality */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* same position */
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|mvcheck
argument_list|(
name|incumbent
argument_list|,
name|candidate
argument_list|)
specifier|register
expr|struct
name|BOARD
operator|*
name|incumbent
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|BOARD
modifier|*
name|candidate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|cturn
operator|*
operator|(
name|candidate
operator|->
name|b_st
index|[
name|i
index|]
operator|-
name|incumbent
operator|->
name|b_st
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|mvlim
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
block|{
name|incumbent
operator|->
name|b_st
index|[
name|i
index|]
operator|=
name|candidate
operator|->
name|b_st
index|[
name|i
index|]
expr_stmt|;
name|incumbent
operator|->
name|b_fn
index|[
name|i
index|]
operator|=
name|candidate
operator|->
name|b_fn
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|makefree
argument_list|(
argument|dead
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BOARD
modifier|*
name|dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dead position */
end_comment

begin_block
block|{
name|dead
operator|->
name|b_next
operator|=
name|freeq
expr_stmt|;
comment|/* add to freeq */
name|freeq
operator|=
name|dead
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|BOARD
modifier|*
name|nextfree
parameter_list|()
block|{
name|struct
name|BOARD
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|freeq
operator|==
literal|0
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|BOARD
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BOARD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|writel
argument_list|(
literal|"\nOut of memory\n"
argument_list|)
expr_stmt|;
name|getout
argument_list|()
expr_stmt|;
block|}
name|new
operator|->
name|b_next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
name|new
operator|=
name|freeq
expr_stmt|;
name|freeq
operator|=
name|freeq
operator|->
name|b_next
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|pickmove
argument_list|()
end_macro

begin_block
block|{
comment|/* current game position */
specifier|register
name|struct
name|BOARD
modifier|*
name|now
init|=
name|bsave
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|BOARD
modifier|*
name|next
decl_stmt|;
comment|/* next move */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|trace
operator|==
name|NULL
condition|)
name|trace
operator|=
name|fopen
argument_list|(
literal|"bgtrace"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\nRoll:  %d %d%s\n"
argument_list|,
name|D0
argument_list|,
name|D1
argument_list|,
name|race
condition|?
literal|" (race)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* compare moves */
name|bcopy
argument_list|(
name|checkq
argument_list|)
expr_stmt|;
name|next
operator|=
name|checkq
operator|->
name|b_next
expr_stmt|;
name|makefree
argument_list|(
name|checkq
argument_list|)
expr_stmt|;
name|checkq
operator|=
name|next
expr_stmt|;
name|movcmp
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|checkq
operator|!=
literal|0
condition|)
do|;
name|bcopy
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|bcopy
argument_list|(
name|s
argument_list|)
specifier|register
expr|struct
name|BOARD
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* game situation */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* index */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|board
index|[
name|i
index|]
operator|=
name|s
operator|->
name|b_board
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|in
index|[
name|i
index|]
operator|=
name|s
operator|->
name|b_in
index|[
name|i
index|]
expr_stmt|;
name|off
index|[
name|i
index|]
operator|=
name|s
operator|->
name|b_off
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|s
operator|->
name|b_st
index|[
name|i
index|]
expr_stmt|;
name|g
index|[
name|i
index|]
operator|=
name|s
operator|->
name|b_fn
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|movcmp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|trace
operator|==
name|NULL
condition|)
name|trace
operator|=
name|fopen
argument_list|(
literal|"bgtrace"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|odds
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|race
condition|)
block|{
name|ch
operator|=
name|op
operator|=
name|pt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|board
index|[
name|i
index|]
operator|==
name|cturn
condition|)
name|ch
operator|=
name|canhit
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|+=
name|abs
argument_list|(
name|bar
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|bar
operator|+
name|cturn
init|;
name|i
operator|!=
name|home
condition|;
name|i
operator|+=
name|cturn
control|)
if|if
condition|(
name|board
index|[
name|i
index|]
operator|*
name|cturn
operator|>
literal|1
condition|)
name|pt
operator|+=
name|abs
argument_list|(
name|bar
operator|-
name|i
argument_list|)
expr_stmt|;
name|frc
operator|=
name|freemen
argument_list|(
name|bar
argument_list|)
operator|+
name|trapped
argument_list|(
name|bar
argument_list|,
name|cturn
argument_list|)
expr_stmt|;
name|frp
operator|=
name|freemen
argument_list|(
name|home
argument_list|)
operator|+
name|trapped
argument_list|(
name|home
argument_list|,
operator|-
name|cturn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|em
operator|=
name|bar
init|;
name|em
operator|!=
name|home
condition|;
name|em
operator|+=
name|cturn
control|)
if|if
condition|(
name|board
index|[
name|em
index|]
operator|*
name|cturn
operator|>
literal|0
condition|)
break|break;
name|em
operator|=
name|abs
argument_list|(
name|home
operator|-
name|em
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fputs
argument_list|(
literal|"Board: "
argument_list|,
name|trace
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|" %d"
argument_list|,
name|board
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|race
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n\tem = %d\n"
argument_list|,
name|em
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n\tch = %d, pt = %d, em = %d, frc = %d, frp = %d\n"
argument_list|,
name|ch
argument_list|,
name|pt
argument_list|,
name|em
argument_list|,
name|frc
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tMove: "
argument_list|,
name|trace
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|" %d-%d"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|g
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|trace
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tests
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|cg
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|||
name|movegood
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\t[%s] ... wins.\n"
argument_list|,
name|tests
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mvlim
condition|;
name|i
operator|++
control|)
block|{
name|cp
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|cg
index|[
name|i
index|]
operator|=
name|g
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|race
condition|)
block|{
name|chance
operator|=
name|ch
expr_stmt|;
name|openmen
operator|=
name|op
expr_stmt|;
name|points
operator|=
name|pt
expr_stmt|;
name|endman
operator|=
name|em
expr_stmt|;
name|barmen
operator|=
name|abs
argument_list|(
name|board
index|[
name|home
index|]
argument_list|)
expr_stmt|;
name|oldfrc
operator|=
name|frc
expr_stmt|;
name|oldfrp
operator|=
name|frp
expr_stmt|;
block|}
name|menin
operator|=
operator|*
name|inptr
expr_stmt|;
name|menoff
operator|=
operator|*
name|offptr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\t[%s] ... loses.\n"
argument_list|,
name|tests
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_macro
name|movegood
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|offptr
operator|==
literal|15
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|menoff
operator|==
literal|15
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|race
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|offptr
operator|-
name|menoff
condition|)
return|return
operator|(
operator|*
name|offptr
operator|>
name|menoff
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|endman
operator|-
name|em
condition|)
return|return
operator|(
name|endman
operator|>
name|em
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|menin
operator|==
literal|15
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|inptr
operator|==
literal|15
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|inptr
operator|-
name|menin
condition|)
return|return
operator|(
operator|*
name|inptr
operator|>
name|menin
operator|)
return|;
return|return
operator|(
name|rnum
argument_list|(
literal|2
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|n
operator|=
name|barmen
operator|-
name|abs
argument_list|(
name|board
index|[
name|home
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"c"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abs
argument_list|(
name|chance
operator|-
name|ch
argument_list|)
operator|+
literal|25
operator|*
name|n
operator|>
name|rnum
argument_list|(
literal|150
argument_list|)
condition|)
return|return
operator|(
name|n
condition|?
operator|(
name|n
operator|<
literal|0
operator|)
else|:
operator|(
name|ch
operator|<
name|chance
operator|)
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|offptr
operator|-
name|menoff
condition|)
return|return
operator|(
operator|*
name|offptr
operator|>
name|menoff
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abs
argument_list|(
name|openmen
operator|-
name|op
argument_list|)
operator|>
literal|7
operator|+
name|rnum
argument_list|(
literal|12
argument_list|)
condition|)
return|return
operator|(
name|openmen
operator|>
name|op
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
condition|)
return|return
operator|(
name|n
operator|<
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abs
argument_list|(
name|endman
operator|-
name|em
argument_list|)
operator|>
name|rnum
argument_list|(
literal|2
argument_list|)
condition|)
return|return
operator|(
name|endman
operator|>
name|em
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abs
argument_list|(
name|frc
operator|-
name|oldfrc
argument_list|)
operator|>
name|rnum
argument_list|(
literal|2
argument_list|)
condition|)
return|return
operator|(
name|frc
operator|<
name|oldfrc
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abs
argument_list|(
name|n
operator|=
name|pt
operator|-
name|points
argument_list|)
operator|>
name|rnum
argument_list|(
literal|4
argument_list|)
condition|)
return|return
operator|(
name|n
operator|>
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|inptr
operator|-
name|menin
condition|)
return|return
operator|(
operator|*
name|inptr
operator|>
name|menin
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|strcat
argument_list|(
name|tests
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abs
argument_list|(
name|frp
operator|-
name|oldfrp
argument_list|)
operator|>
name|rnum
argument_list|(
literal|2
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|>
name|oldfrp
operator|)
return|;
return|return
operator|(
name|rnum
argument_list|(
literal|2
argument_list|)
operator|)
return|;
block|}
block|}
end_block

end_unit

