begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: if_lpb.c,v 4.2 88/06/29 14:59:38 hagens Exp $  * $Source: /usr/argo/sys/netiso/RCS/if_lpb.c,v $  *  *	LOOPBACK driver that mimics the  *	Eicon x.25 board for use by CONS  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: if_lpb.c,v 4.2 88/06/29 14:59:38 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"machine/io.h"
end_include

begin_include
include|#
directive|include
file|"../machineio/ioccvar.h"
end_include

begin_include
include|#
directive|include
file|"ecn.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"../caif/eicon.h"
end_include

begin_include
include|#
directive|include
file|"iso_errno.h"
end_include

begin_define
define|#
directive|define
name|LPB_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LPB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|MT_LPB_OPEN
value|0x55
end_define

begin_define
define|#
directive|define
name|MT_LPB_ACK
value|0x56
end_define

begin_else
else|#
directive|else
else|LPB_DEBUG
end_else

begin_define
define|#
directive|define
name|MT_LPB_DATA
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_LPB_ACK
value|MT_DATA
end_define

begin_endif
endif|#
directive|endif
endif|LPB_DEBUG
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|ifqueue
name|consintrq
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|lpboutput
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* These next 2 declarations are for Logical Unit Numbers - i.e. VC # -  * the 2I assigns and frees them; we have to fake it  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|free_luns
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|next_lun
init|=
name|free_luns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize all LUNs as available for use.  */
end_comment

begin_macro
name|init_lpb
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|free_luns
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|next_lun
operator|=
name|free_luns
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Allocate new logical unit number.  *  Allocating number n means that both n and -n are allocated& used.  *  NOTE: next_lun always points to an UNALLOCATED lun, hence  *	 take a lun then increment, or decrement then stash the lun.  */
end_comment

begin_function
name|u_char
name|getlun
parameter_list|()
block|{
if|if
condition|(
operator|(
operator|(
name|next_lun
operator|)
operator|-
name|free_luns
operator|)
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"PANIC: if_lpb: too many channels! \n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"getlun: returns 0x%x\n"
argument_list|,
operator|*
name|next_lun
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
operator|*
name|next_lun
operator|!=
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|next_lun
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"PANIC IN lpb: free_luns 0x%x next_len 0x%x *next_lun 0x%x\n"
argument_list|,
name|free_luns
argument_list|,
name|next_lun
argument_list|,
operator|*
name|next_lun
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"free_luns[ 0x%x ] = 0x%x\n"
argument_list|,
name|i
argument_list|,
name|free_luns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|*
operator|(
name|next_lun
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * When you free one you free its neg   */
end_comment

begin_macro
name|freelun
argument_list|(
argument|lun
argument_list|)
end_macro

begin_decl_stmt
name|u_char
name|lun
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"freelun(0x%x)\n"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|lun
operator|>
literal|32
condition|)
return|return;
name|ASSERT
argument_list|(
operator|(
name|lun
operator|&
literal|0xc0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lun
operator|<=
literal|32
argument_list|)
expr_stmt|;
comment|/* check for lun already in the list */
block|{
specifier|register
name|u_char
modifier|*
name|r
init|=
name|next_lun
decl_stmt|;
while|while
condition|(
call|(
name|int
call|)
argument_list|(
name|r
operator|-
name|free_luns
argument_list|)
operator|<=
literal|32
condition|)
block|{
if|if
condition|(
operator|*
name|r
operator|==
name|lun
condition|)
block|{
return|return;
block|}
name|r
operator|++
expr_stmt|;
block|}
block|}
name|next_lun
operator|--
expr_stmt|;
operator|*
name|next_lun
operator|=
name|lun
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		lpboutput  *  * PURPOSE:			Process an eicon x.25 request from a higher layer  *					protocol.  * ARGUMENTS:	 	(ifp) is points to the ifnet structure for this unit/device  *					(m)  is an mbuf *, *m is an eicon request structure  *  * RETURNS:			unix error code  *  * NOTES:			Mimics the eicon driver.  *  */
end_comment

begin_expr_stmt
name|lpboutput
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request */
end_comment

begin_block
block|{
name|int
name|s
decl_stmt|;
name|struct
name|eicon_request
modifier|*
name|req
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Do this even if (ifp->if_flags& IFF_LOOPBACK) == 0 	 * because whether or not a vc is on loopback is determined 	 * at the time of connection establishement. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CDUMP_REQ
argument_list|)
name|dump_buf
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|req
operator|->
name|e_cmd
condition|)
block|{
case|case
name|ECN_CALL
case|:
block|{
comment|/* 			 *	ECN_CALL	->	ECN_ACCEPT (for orig CONNECT) 			 *				->	ECN_CONNECT	(other side's connect indication) 			 */
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mopen
decl_stmt|;
name|struct
name|eicon_request
modifier|*
name|open
decl_stmt|;
name|MGET
argument_list|(
name|mopen
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_LPB_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mopen
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No mbufs for copy\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|mopen
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
expr_stmt|;
name|open
operator|=
name|mtod
argument_list|(
name|mopen
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|req
argument_list|,
name|open
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get mbuf for the connect data */
name|MGET
argument_list|(
name|mdata
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_LPB_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdata
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No mbufs for copy\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|mdata
operator|->
name|m_len
operator|=
operator|(
name|e_data
argument_list|(
name|req
argument_list|)
operator|)
operator|->
name|m_len
expr_stmt|;
name|e_data
argument_list|(
name|open
argument_list|)
operator|=
name|mdata
expr_stmt|;
comment|/* e_data is really mtod(open)->m_next */
comment|/* make a copy of the connect data */
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"bcopy( 0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|mtod
argument_list|(
name|e_data
argument_list|(
name|req
argument_list|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|mdata
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|e_data
argument_list|(
name|req
argument_list|)
operator|)
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|e_data
argument_list|(
name|req
argument_list|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|mdata
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|e_data
argument_list|(
name|req
argument_list|)
operator|)
operator|->
name|m_len
argument_list|)
decl_stmt|;
comment|/* setup call */
name|open
operator|->
name|e_cmd
operator|=
name|ECN_CONNECT
expr_stmt|;
name|open
operator|->
name|e_vc
operator|=
name|getlun
argument_list|()
expr_stmt|;
comment|/* setup call confirm */
name|req
operator|->
name|e_cmd
operator|=
name|ECN_ACCEPT
expr_stmt|;
name|req
operator|->
name|e_vc
operator|=
operator|-
operator|(
name|open
operator|->
name|e_vc
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CDUMP_REQ
argument_list|)
name|printf
argument_list|(
literal|"lpboutput CALL middle \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|consintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|consintrq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mopen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lpboutput: response dropped\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* connect */
name|IFDEBUG
argument_list|(
name|D_CCONS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CONNECT 0x%x --> X25INTRQ\n"
argument_list|,
name|mopen
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IF_ENQUEUE
argument_list|(
operator|&
name|consintrq
argument_list|,
name|mopen
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
name|D_CDUMP_REQ
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|open
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* confirm */
name|IFDEBUG
parameter_list|(
name|D_CCONS
parameter_list|)
function_decl|;
name|printf
argument_list|(
literal|"CONFIRM 0x%x (data 0x%x =?= 0x%x) --> X25INTRQ\n"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_next
argument_list|,
name|e_data
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IF_ENQUEUE
argument_list|(
operator|&
name|consintrq
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
name|D_CDUMP_REQ
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
break|break;
case|case
name|ECN_RESET
case|:
case|case
name|ECN_CLEAR
case|:
block|{
comment|/* 			 *	ECN_RESET	->	ECN_RESET	(other side's reset indication) 			 *	ECN_CLEAR	->	ECN_CLEAR	(other side's close indication) 			 * TODO: MAY HAVE DATA PACKET!  			 * TODO: Have to be able to handle a 2nd CLEAR on on vc! 			 */
name|freelun
argument_list|(
name|req
operator|->
name|e_vc
argument_list|)
expr_stmt|;
name|freelun
argument_list|(
operator|(
operator|-
name|req
operator|->
name|e_vc
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|req
operator|->
name|e_vc
operator|=
operator|-
name|req
operator|->
name|e_vc
expr_stmt|;
comment|/* other side */
name|req
operator|->
name|e_reason
operator|=
name|E_CO_PDNCLRESET
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|consintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|consintrq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lpboutput: respose dropped\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
name|IFDEBUG
argument_list|(
name|D_CCONS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CLOSE 0x%x --> X25INTRQ\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IF_ENQUEUE
argument_list|(
operator|&
name|consintrq
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
name|D_CDUMP_REQ
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
break|break;
case|case
name|ECN_SEND
case|:
block|{
comment|/* 			 *	ECN_SEND 	->	ECN_RECEIVE	(data send becomes data recvd) 			 */
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|eicon_request
modifier|*
name|ack
decl_stmt|;
name|MGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_LPB_ACK
argument_list|)
expr_stmt|;
comment|/* sets type, next, off */
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"PANIC No mbufs for copy\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|m0
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
expr_stmt|;
name|ack
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|eicon_request
operator|*
argument_list|)
expr_stmt|;
comment|/* setup ack */
name|ack
operator|->
name|e_cmd
operator|=
name|ECN_ACK
expr_stmt|;
name|ack
operator|->
name|e_vc
operator|=
name|req
operator|->
name|e_vc
expr_stmt|;
name|req
operator|->
name|e_vc
operator|=
operator|-
name|req
operator|->
name|e_vc
expr_stmt|;
name|req
operator|->
name|e_cmd
operator|=
name|ECN_RECEIVE
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|consintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|consintrq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lpboutput: ADR_ACK DROPPED\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNABORTED
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|consintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
name|D_CCONS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DATA 0x%x --> X25INTRQ\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFDEBUG
parameter_list|(
name|D_CDUMP_REQ
parameter_list|)
function_decl|;
name|dump_buf
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFDEBUG
parameter_list|(
name|D_CCONS
parameter_list|)
function_decl|;
name|printf
argument_list|(
literal|"ACK 0x%x --> X25INTRQ\n"
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IF_ENQUEUE
argument_list|(
operator|&
name|consintrq
argument_list|,
name|m0
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
name|D_CDUMP_REQ
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eicon_request
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad loopback request 0x%x\n"
argument_list|,
name|req
operator|->
name|e_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|schednetisr
argument_list|(
name|NETISR_X25
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_if
if|#
directive|if
name|NECN
operator|>
literal|0
end_if

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* KLUDGE: when no ecn board config-ed in, we need a routing  * ecnifp to return null.  We want to be able to configure with  * sw loopback only.  */
end_comment

begin_function
name|struct
name|ifnet
modifier|*
name|ecnifp
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|ecnoutput
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"ecnoutput: ecn not configured\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
end_function

begin_macro
name|ecnshutdown
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"ecnshutdown: ecn not configured\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ecnrestart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"ecnrestart: ecn not configured\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NECN>0
end_endif

end_unit

