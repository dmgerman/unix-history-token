begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_uba.c	7.12 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../vax/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"if_uba.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_comment
comment|/*  * Routines supporting UNIBUS network interfaces.  *  * TODO:  *	Support interfaces using only one BDP statically.  */
end_comment

begin_comment
comment|/*  * Init UNIBUS for interface on uban whose headers of size hlen are to  * end on a page boundary.  We allocate a UNIBUS map register for the page  * with the header, and nmr more UNIBUS map registers for i/o on the adapter,  * doing this once for each read and once for each write buffer.  We also  * allocate page frames in the mbuffer pool for these pages.  */
end_comment

begin_expr_stmt
name|if_ubaminit
argument_list|(
name|ifu
argument_list|,
name|uban
argument_list|,
name|hlen
argument_list|,
name|nmr
argument_list|,
name|ifr
argument_list|,
name|nr
argument_list|,
name|ifw
argument_list|,
name|nw
argument_list|)
specifier|register
expr|struct
name|ifubinfo
operator|*
name|ifu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|uban
decl_stmt|,
name|hlen
decl_stmt|,
name|nmr
decl_stmt|,
name|nr
decl_stmt|,
name|nw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ifrw
modifier|*
name|ifr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ifxmt
modifier|*
name|ifw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|p
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nclbytes
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|hlen
condition|)
name|off
operator|=
name|MCLBYTES
operator|-
name|hlen
expr_stmt|;
else|else
name|off
operator|=
literal|0
expr_stmt|;
name|nclbytes
operator|=
name|roundup
argument_list|(
name|nmr
operator|*
name|NBPG
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
condition|)
name|nclbytes
operator|+=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|ifr
index|[
literal|0
index|]
operator|.
name|ifrw_addr
condition|)
name|cp
operator|=
name|ifr
index|[
literal|0
index|]
operator|.
name|ifrw_addr
operator|-
name|off
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|ifr
index|[
name|i
index|]
operator|.
name|ifrw_addr
operator|=
name|p
operator|+
name|off
expr_stmt|;
name|p
operator|+=
name|nclbytes
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nw
condition|;
name|i
operator|++
control|)
block|{
name|ifw
index|[
name|i
index|]
operator|.
name|ifw_base
operator|=
name|p
expr_stmt|;
name|ifw
index|[
name|i
index|]
operator|.
name|ifw_addr
operator|=
name|p
operator|+
name|off
expr_stmt|;
name|p
operator|+=
name|nclbytes
expr_stmt|;
block|}
name|ifu
operator|->
name|iff_hlen
operator|=
name|hlen
expr_stmt|;
name|ifu
operator|->
name|iff_uban
operator|=
name|uban
expr_stmt|;
name|ifu
operator|->
name|iff_uba
operator|=
name|uba_hd
index|[
name|uban
index|]
operator|.
name|uh_uba
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|if_ubaalloc
argument_list|(
name|ifu
argument_list|,
operator|&
name|ifr
index|[
name|i
index|]
argument_list|,
name|nmr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nr
operator|=
name|i
expr_stmt|;
name|nw
operator|=
literal|0
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nw
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|if_ubaalloc
argument_list|(
name|ifu
argument_list|,
operator|&
name|ifw
index|[
name|i
index|]
operator|.
name|ifrw
argument_list|,
name|nmr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nw
operator|=
name|i
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
while|while
condition|(
operator|--
name|nw
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmr
condition|;
name|i
operator|++
control|)
name|ifw
index|[
name|nw
index|]
operator|.
name|ifw_wmap
index|[
name|i
index|]
operator|=
name|ifw
index|[
name|nw
index|]
operator|.
name|ifw_mr
index|[
name|i
index|]
expr_stmt|;
name|ifw
index|[
name|nw
index|]
operator|.
name|ifw_xswapd
operator|=
literal|0
expr_stmt|;
name|ifw
index|[
name|nw
index|]
operator|.
name|ifw_flags
operator|=
name|IFRW_W
expr_stmt|;
name|ifw
index|[
name|nw
index|]
operator|.
name|ifw_nmr
operator|=
name|nmr
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
while|while
condition|(
operator|--
name|nw
operator|>=
literal|0
condition|)
name|ubarelse
argument_list|(
name|ifu
operator|->
name|iff_uban
argument_list|,
operator|&
name|ifw
index|[
name|nw
index|]
operator|.
name|ifw_info
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|ubarelse
argument_list|(
name|ifu
operator|->
name|iff_uban
argument_list|,
operator|&
name|ifr
index|[
name|nr
index|]
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ifr
index|[
literal|0
index|]
operator|.
name|ifrw_addr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Setup an ifrw structure by allocating UNIBUS map registers,  * possibly a buffered data path, and initializing the fields of  * the ifrw structure to minimize run-time overhead.  */
end_comment

begin_expr_stmt
specifier|static
name|if_ubaalloc
argument_list|(
argument|ifu
argument_list|,
argument|ifrw
argument_list|,
argument|nmr
argument_list|)
expr|struct
name|ifubinfo
operator|*
name|ifu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ifrw
modifier|*
name|ifrw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|info
decl_stmt|;
name|info
operator|=
name|uballoc
argument_list|(
name|ifu
operator|->
name|iff_uban
argument_list|,
name|ifrw
operator|->
name|ifrw_addr
argument_list|,
name|nmr
operator|*
name|NBPG
operator|+
name|ifu
operator|->
name|iff_hlen
argument_list|,
name|ifu
operator|->
name|iff_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifrw
operator|->
name|ifrw_info
operator|=
name|info
expr_stmt|;
name|ifrw
operator|->
name|ifrw_bdp
operator|=
name|UBAI_BDP
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ifrw
operator|->
name|ifrw_proto
operator|=
name|UBAMR_MRV
operator||
operator|(
name|UBAI_BDP
argument_list|(
name|info
argument_list|)
operator|<<
name|UBAMR_DPSHIFT
operator|)
expr_stmt|;
name|ifrw
operator|->
name|ifrw_mr
operator|=
operator|&
name|ifu
operator|->
name|iff_uba
operator|->
name|uba_map
index|[
name|UBAI_MR
argument_list|(
name|info
argument_list|)
operator|+
operator|(
name|ifu
operator|->
name|iff_hlen
condition|?
literal|1
else|:
literal|0
operator|)
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Pull read data off a interface.  * Len is length of data, with local net header stripped.  * Off is non-zero if a trailer protocol was used, and  * gives the offset of the trailer information.  * We copy the trailer information and then all the normal  * data into mbufs.  When full cluster sized units are present  * on the interface on cluster boundaries we can get them more  * easily by remapping, and take advantage of this here.  * Prepend a pointer to the interface structure,  * so that protocols can determine where incoming packets arrived.  * Note: we may be called to receive from a transmit buffer by some  * devices.  In that case, we must force normal mapping of the buffer,  * so that the correct data will appear (only unibus maps are   * changed when remapping the transmit buffers).  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|if_ubaget
parameter_list|(
name|ifu
parameter_list|,
name|ifr
parameter_list|,
name|totlen
parameter_list|,
name|off0
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|ifubinfo
modifier|*
name|ifu
decl_stmt|;
specifier|register
name|struct
name|ifrw
modifier|*
name|ifr
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|caddr_t
name|cp
init|=
name|ifr
operator|->
name|ifrw_addr
operator|+
name|ifu
operator|->
name|iff_hlen
decl_stmt|,
name|pp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|off
init|=
name|off0
decl_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifrw_flags
operator|&
name|IFRW_W
condition|)
name|rcv_xmtbuf
argument_list|(
operator|(
expr|struct
name|ifxmt
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|off
condition|)
block|{
name|len
operator|=
name|totlen
operator|-
name|off
expr_stmt|;
name|cp
operator|=
name|ifr
operator|->
name|ifrw_addr
operator|+
name|ifu
operator|->
name|iff_hlen
operator|+
name|off
expr_stmt|;
block|}
else|else
name|len
operator|=
name|totlen
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
comment|/* should subtract trailer */
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|struct
name|pte
modifier|*
name|cpte
decl_stmt|,
modifier|*
name|ppte
decl_stmt|;
name|int
name|x
decl_stmt|,
modifier|*
name|ip
decl_stmt|,
name|i
decl_stmt|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nopage
goto|;
name|len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|claligned
argument_list|(
name|cp
argument_list|)
condition|)
goto|goto
name|copy
goto|;
comment|/* 			 * Switch pages mapped to UNIBUS with new page pp, 			 * as quick form of copy.  Remap UNIBUS and invalidate. 			 */
name|pp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|cpte
operator|=
name|kvtopte
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ppte
operator|=
name|kvtopte
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|x
operator|=
name|btop
argument_list|(
name|cp
operator|-
name|ifr
operator|->
name|ifrw_addr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifrw_mr
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MCLBYTES
operator|/
name|NBPG
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pte
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|ppte
expr_stmt|;
operator|*
name|ppte
operator|++
operator|=
operator|*
name|cpte
expr_stmt|;
operator|*
name|cpte
operator|=
name|t
expr_stmt|;
operator|*
name|ip
operator|++
operator|=
name|cpte
operator|++
operator|->
name|pg_pfnum
operator||
name|ifr
operator|->
name|ifrw_proto
expr_stmt|;
comment|/*	mtpr(TBIS, cp); */
name|cp
operator|+=
name|NBPG
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|NBPG
expr_stmt|;
block|}
goto|goto
name|nocopy
goto|;
block|}
name|nopage
label|:
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
comment|/* 			 * Place initial small packet/header at end of mbuf. 			 */
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|len
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|copy
label|:
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
name|nocopy
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
comment|/* sort of an ALGOL-W style for statement... */
name|off
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|totlen
condition|)
block|{
name|cp
operator|=
name|ifr
operator|->
name|ifrw_addr
operator|+
name|ifu
operator|->
name|iff_hlen
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|totlen
operator|=
name|off0
expr_stmt|;
block|}
block|}
else|else
name|totlen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|off0
condition|)
block|{
name|m
operator|=
name|top
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ifr
operator|->
name|ifrw_flags
operator|&
name|IFRW_W
condition|)
name|restor_xmtbuf
argument_list|(
operator|(
expr|struct
name|ifxmt
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change the mapping on a transmit buffer so that if_ubaget may  * receive from that buffer.  Copy data from any pages mapped to Unibus  * into the pages mapped to normal kernel virtual memory, so that  * they can be accessed and swapped as usual.  We take advantage  * of the fact that clusters are placed on the xtofree list  * in inverse order, finding the last one.  */
end_comment

begin_expr_stmt
specifier|static
name|rcv_xmtbuf
argument_list|(
name|ifw
argument_list|)
specifier|register
expr|struct
name|ifxmt
operator|*
name|ifw
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mprev
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
while|while
condition|(
name|i
operator|=
name|ffs
argument_list|(
operator|(
name|long
operator|)
name|ifw
operator|->
name|ifw_xswapd
argument_list|)
condition|)
block|{
name|cp
operator|=
name|ifw
operator|->
name|ifw_base
operator|+
name|i
operator|*
name|MCLBYTES
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|ifw
operator|->
name|ifw_xswapd
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|mprev
operator|=
operator|&
name|ifw
operator|->
name|ifw_xtofree
expr_stmt|;
for|for
control|(
name|m
operator|=
name|ifw
operator|->
name|ifw_xtofree
init|;
name|m
operator|&&
name|m
operator|->
name|m_next
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|mprev
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|mprev
operator|=
name|NULL
expr_stmt|;
block|}
name|ifw
operator|->
name|ifw_xswapd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ifw
operator|->
name|ifw_nmr
condition|;
name|i
operator|++
control|)
name|ifw
operator|->
name|ifw_mr
index|[
name|i
index|]
operator|=
name|ifw
operator|->
name|ifw_wmap
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put a transmit buffer back together after doing an if_ubaget on it,  * which may have swapped pages.  */
end_comment

begin_expr_stmt
specifier|static
name|restor_xmtbuf
argument_list|(
name|ifw
argument_list|)
specifier|register
expr|struct
name|ifxmt
operator|*
name|ifw
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ifw
operator|->
name|ifw_nmr
condition|;
name|i
operator|++
control|)
name|ifw
operator|->
name|ifw_wmap
index|[
name|i
index|]
operator|=
name|ifw
operator|->
name|ifw_mr
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map a chain of mbufs onto a network interface  * in preparation for an i/o operation.  * The argument chain of mbufs includes the local network  * header which is copied to be in the mapped, aligned  * i/o space.  */
end_comment

begin_macro
name|if_ubaput
argument_list|(
argument|ifu
argument_list|,
argument|ifw
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifubinfo
modifier|*
name|ifu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ifxmt
modifier|*
name|ifw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|,
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|xswapd
init|=
literal|0
decl_stmt|;
name|int
name|x
decl_stmt|,
name|cc
decl_stmt|,
name|t
decl_stmt|;
name|cp
operator|=
name|ifw
operator|->
name|ifw_addr
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|dp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|claligned
argument_list|(
name|cp
argument_list|)
operator|&&
name|claligned
argument_list|(
name|dp
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|m_len
operator|==
name|MCLBYTES
operator|||
name|m
operator|->
name|m_next
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
name|pte
operator|=
name|kvtopte
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|x
operator|=
name|btop
argument_list|(
name|cp
operator|-
name|ifw
operator|->
name|ifw_addr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|ifw
operator|->
name|ifw_mr
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MCLBYTES
operator|/
name|NBPG
condition|;
name|i
operator|++
control|)
operator|*
name|ip
operator|++
operator|=
name|ifw
operator|->
name|ifw_proto
operator||
name|pte
operator|++
operator|->
name|pg_pfnum
expr_stmt|;
name|xswapd
operator||=
literal|1
operator|<<
operator|(
name|x
operator|>>
operator|(
name|MCLSHIFT
operator|-
name|PGSHIFT
operator|)
operator|)
expr_stmt|;
name|mp
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|ifw
operator|->
name|ifw_xtofree
expr_stmt|;
name|ifw
operator|->
name|ifw_xtofree
operator|=
name|m
expr_stmt|;
name|cp
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
operator|(
name|unsigned
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|mp
expr_stmt|;
block|}
comment|/* 	 * Xswapd is the set of clusters we just mapped out.  Ifu->iff_xswapd 	 * is the set of clusters mapped out from before.  We compute 	 * the number of clusters involved in this operation in x. 	 * Clusters mapped out before and involved in this operation 	 * should be unmapped so original pages will be accessed by the device. 	 */
name|cc
operator|=
name|cp
operator|-
name|ifw
operator|->
name|ifw_addr
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|cc
operator|-
name|ifu
operator|->
name|iff_hlen
operator|)
operator|+
name|MCLBYTES
operator|-
literal|1
operator|)
operator|>>
name|MCLSHIFT
expr_stmt|;
name|ifw
operator|->
name|ifw_xswapd
operator|&=
operator|~
name|xswapd
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|ffs
argument_list|(
operator|(
name|long
operator|)
name|ifw
operator|->
name|ifw_xswapd
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|x
condition|)
break|break;
name|ifw
operator|->
name|ifw_xswapd
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|i
operator|*=
name|MCLBYTES
operator|/
name|NBPG
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MCLBYTES
operator|/
name|NBPG
condition|;
name|t
operator|++
control|)
block|{
name|ifw
operator|->
name|ifw_mr
index|[
name|i
index|]
operator|=
name|ifw
operator|->
name|ifw_wmap
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|ifw
operator|->
name|ifw_xswapd
operator||=
name|xswapd
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_block

end_unit

