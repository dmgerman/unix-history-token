begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: tcp_states.c,v 1.21 85/07/31 09:42:53 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/seq.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/macros.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/sws.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HMPTRAPS
end_ifdef

begin_include
include|#
directive|include
file|"../bbnnet/hmp_traps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|struct
name|rtentry
modifier|*
name|ip_route
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * These are the action routines of the TCP finite state machine.  They are  * called from the TCP fsm dispatcher action().  These routines call   * on the routines in tcp_procs.c to do the actual segment processing.  */
end_comment

begin_comment
comment|/*  * UNOPENED x IUOPENA == passive open == listen()  */
end_comment

begin_macro
name|lis_cls
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
comment|/* listen() system call */
comment|/*      * Don't know who we're talking to yet, so we don't have a route      * or mtu yet.      */
name|tp
operator|->
name|t_maxseg
operator|=
name|TCPMAXSND
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TINIT
index|]
operator|=
name|tp
operator|->
name|t_itimeo
expr_stmt|;
return|return
operator|(
name|LISTEN
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * UNOPENED x IUOPENR == active open == connect()  */
end_comment

begin_expr_stmt
name|sys_cls
argument_list|(
name|wp
argument_list|)
specifier|register
expr|struct
name|work
operator|*
name|wp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* connect() system call */
name|tp
operator|=
name|wp
operator|->
name|w_tcb
expr_stmt|;
name|inp
operator|=
name|tp
operator|->
name|t_in_pcb
expr_stmt|;
comment|/*      * Know foreign host and have a route to there.      */
ifdef|#
directive|ifdef
name|NOTCPOPTS
name|tp
operator|->
name|t_maxseg
operator|=
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|TCPIPMAX
expr_stmt|;
else|#
directive|else
comment|/*      * Best can do until other guy tells us otherwise.      */
name|tp
operator|->
name|t_maxseg
operator|=
name|MIN
argument_list|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|TCPIPMAX
argument_list|,
name|TCPMAXSND
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|t_maxseg
operator|-=
name|inp
operator|->
name|inp_optlen
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TINIT
index|]
operator|=
operator|(
name|tp
operator|->
name|t_itimeo
condition|?
name|tp
operator|->
name|t_itimeo
else|:
name|TCP_tvINIT
operator|)
expr_stmt|;
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
comment|/* send SYN */
return|return
operator|(
name|SYN_SENT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * UNOPENED x IUCLOSE  * LISTEN   x IUCLOSE  * SYN_SENT x IUCLOSE  *  * User close request before receiving foreign SYN  */
end_comment

begin_macro
name|cls_opn
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|t_close
argument_list|(
name|wp
operator|->
name|w_tcb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * SYN_RCVD   x IUCLOSE  * L_SYN_RCVD x IUCLOSE  * ESTAB      x IUCLOSE  *   * close request on synched connection  */
end_comment

begin_macro
name|fw1_syr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|tp
operator|->
name|snd_fin
operator|=
name|TRUE
expr_stmt|;
comment|/* send FIN */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|usr_closed
operator|=
name|TRUE
expr_stmt|;
name|tp
operator|->
name|t_noact
operator|=
name|TCP_tvNOACT
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|TCP_tvNOACT
expr_stmt|;
return|return
operator|(
name|FIN_W1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CLOSE_WAIT x IUCLOSE  *  * close request after received foreign FIN  */
end_comment

begin_macro
name|cl2_clw
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|tp
operator|->
name|snd_fin
operator|=
name|TRUE
expr_stmt|;
comment|/* send our own FIN */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|usr_closed
operator|=
name|TRUE
expr_stmt|;
name|tp
operator|->
name|t_noact
operator|=
name|TCP_tvNOACT
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|TCP_tvNOACT
expr_stmt|;
return|return
operator|(
name|CLOSING2
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * UNOPENED   x IUABORT  * LISTEN     x IUABORT  * SYN_SENT   x IUABORT  * SYN_RCVD   x IUABORT  * L_SYN_RCVD x IUABORT  *  * User abort request on unsynched connection  */
end_comment

begin_macro
name|cls_nsy
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|t_close
argument_list|(
name|wp
operator|->
name|w_tcb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ESTAB      x IUABORT  * FIN_WAIT_1 x IUABORT  * FIN_WAIT_2 x IUABORT  * TIME_WAIT  x IUABORT  * CLOSE_WAIT x IUABORT  * CLOSING_1  x IUABORT  * CLOSING_2  x IUABORT  * RCV_WAIT   x IUABORT  *  * User abort request on synched connection  */
end_comment

begin_macro
name|cls_syn
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|tp
operator|->
name|snd_rst
operator|=
name|TRUE
expr_stmt|;
comment|/* send reset */
operator|(
name|void
operator|)
name|send_pkt
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* tp->ack_due = FALSE; don't since about to throw tcpcb away */
name|t_close
argument_list|(
name|tp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * LISTEN x INRECV  *  * From tcp_input/netprepr, we know the packet is a well formed SYN  */
end_comment

begin_macro
name|lis_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|,
modifier|*
name|newso
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|newtp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|newinp
decl_stmt|;
name|struct
name|in_addr
name|firsthop
decl_stmt|;
specifier|extern
name|int
name|ip_nhops
decl_stmt|;
specifier|extern
name|struct
name|in_addr
name|ip_hops
index|[]
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
expr_stmt|;
comment|/*      * Need to route on basis of IP destination -- see ip_send()      * ### What if loose routing and 1st hop not on local net and reroute?      */
if|if
condition|(
name|ip_nhops
operator|==
literal|0
condition|)
name|firsthop
operator|=
name|n
operator|->
name|t_s
expr_stmt|;
else|else
comment|/* source routed SYN packet */
name|firsthop
operator|=
name|ip_hops
index|[
name|ip_nhops
index|]
expr_stmt|;
comment|/*      * O.k., let's get a route back to him      */
if|if
condition|(
operator|!
operator|(
name|rt
operator|=
name|ip_route
argument_list|(
operator|&
name|n
operator|->
name|t_d
argument_list|,
operator|&
name|firsthop
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * Can't talk to him.  Leave socket in receive state 	 * so we can connect to someone else, since we haven't 	 * been committed to anything yet anyway. 	 * ### Drop his info on the floor. 	 * Let the other machine just figure out on it's own that 	 * it can't reach us that way. 	 */
name|no_route
argument_list|(
literal|"tcp"
argument_list|,
name|n
operator|->
name|t_d
argument_list|,
name|firsthop
argument_list|)
expr_stmt|;
return|return
operator|(
name|LISTEN
operator|)
return|;
block|}
name|tp
operator|=
name|wp
operator|->
name|w_tcb
expr_stmt|;
name|inp
operator|=
name|tp
operator|->
name|t_in_pcb
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
comment|/*      * This socket is in the listen state, so the socket should have      * so_options& SO_ACCEPTCONN set (solisten()).      *      * The order of sonewconn() and soisconnected() is      * important, in order for the process to be woken up      * at a time when the sleep condition is fulfilled.      * sonewconn() is done here on the original socket, and      * soisconnected() is done later in syr_netr() on the new      * socket.      */
if|if
condition|(
name|newso
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|newinp
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|newso
operator|->
name|so_pcb
expr_stmt|;
name|newtp
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|newinp
operator|->
name|inp_ppcb
expr_stmt|;
comment|/* 	 * Remember our peer for this connection. 	 */
name|newinp
operator|->
name|inp_faddr
operator|=
name|n
operator|->
name|t_s
expr_stmt|;
name|newinp
operator|->
name|inp_fport
operator|=
name|n
operator|->
name|t_src
expr_stmt|;
name|newinp
operator|->
name|inp_laddr
operator|=
name|n
operator|->
name|t_d
expr_stmt|;
if|if
condition|(
name|ip_nhops
operator|>
literal|0
condition|)
block|{
comment|/* 	     * optlen includes the source route to be copied 	     * to the outgoing IP header, not the firsthop 	     * which replaces ip_dst. 	     */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip_hops
argument_list|,
name|newinp
operator|->
name|inp_options
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|ip_nhops
operator|+
literal|1
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|newinp
operator|->
name|inp_optlen
operator|=
name|ip_nhops
operator|*
literal|4
expr_stmt|;
block|}
comment|/* 	 * and copy fields into the new inpcb 	 */
name|newinp
operator|->
name|inp_lport
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|newinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|rt
expr_stmt|;
comment|/* 	 * and copy fields to the new tcpcb 	 */
name|newtp
operator|->
name|t_maxfrag
operator|=
name|tp
operator|->
name|t_maxfrag
expr_stmt|;
comment|/* set in tcp_input() */
name|newtp
operator|->
name|t_itimeo
operator|=
name|tp
operator|->
name|t_itimeo
expr_stmt|;
name|newtp
operator|->
name|t_noact
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
name|newtp
operator|->
name|t_push
operator|=
name|tp
operator|->
name|t_push
expr_stmt|;
name|newtp
operator|->
name|t_noactsig
operator|=
name|tp
operator|->
name|t_noactsig
expr_stmt|;
name|newtp
operator|->
name|t_noactprobe
operator|=
name|tp
operator|->
name|t_noactprobe
expr_stmt|;
comment|/* 	 * and initialize others with new info 	 * Upward negotiation of t_maxseg in tcp_opt() done 	 * on socket in LISTEN. 	 */
name|newtp
operator|->
name|t_maxseg
operator|=
name|MIN
argument_list|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|TCPIPMAX
argument_list|,
name|tp
operator|->
name|t_maxseg
argument_list|)
expr_stmt|;
name|newtp
operator|->
name|t_maxseg
operator|-=
name|newinp
operator|->
name|inp_optlen
expr_stmt|;
comment|/* 	 * In case next client doesn't negotiate maxseg. 	 */
name|tp
operator|->
name|t_maxseg
operator|=
name|TCPMAXSND
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|newtp
operator|->
name|t_template
operator|=
name|tcp_template
argument_list|(
name|newtp
argument_list|)
operator|)
condition|)
block|{
name|soabort
argument_list|(
name|newso
argument_list|)
expr_stmt|;
return|return
operator|(
name|LISTEN
operator|)
return|;
block|}
name|newtp
operator|->
name|sws_qff
operator|=
name|SWS_QFF_DEF
expr_stmt|;
comment|/* 	 * So can debug connection problems without having to change 	 * every program or apply debugging flag to each program every 	 * time run it. 	 */
name|dowedebug
argument_list|(
name|newinp
argument_list|,
name|newso
argument_list|,
operator|&
name|tcp_dfilter
argument_list|)
expr_stmt|;
comment|/* 	 * rcv_tcp may set fin_rcvd.  If so, We went up and down or 	 * we got a garbage/misrouted packet.  If it's set, it's 	 * meant for some other socket or some other instantiation 	 * of it.  In any case, ignore it and listen for other 	 * talkers. 	 */
name|rcv_tcp
argument_list|(
name|newtp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtp
operator|->
name|fin_rcvd
condition|)
name|soabort
argument_list|(
name|newso
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 	     * no FIN (4) 	     * start init timer now that we have foreign host. 	     * Parent socket might have init timer as zero to 	     * avoid getting ETIMEDOUT, but we do want this 	     * child socket to time out on synchronization 	     * just in case other host just went down. 	     */
name|newtp
operator|->
name|t_timers
index|[
name|TINIT
index|]
operator|=
operator|(
name|newtp
operator|->
name|t_itimeo
operator|!=
literal|0
condition|?
name|newtp
operator|->
name|t_itimeo
else|:
name|TCP_tvINIT
operator|/
literal|2
operator|)
expr_stmt|;
name|newtp
operator|->
name|t_state
operator|=
name|L_SYN_RCVD
expr_stmt|;
block|}
block|}
else|else
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|LISTEN
operator|)
return|;
comment|/* original file descriptor stays in LISTEN state */
block|}
end_block

begin_comment
comment|/*  * SYN_SENT x INRECV  *  * from tcp_input/netprepr, we know its a SYN, with perhaps a well formed ACK  */
end_comment

begin_macro
name|sys_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
block|{
comment|/* got a FIN */
comment|/* if good ACK, present any data */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|n
operator|->
name|t_ackno
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
condition|)
comment|/* 32 */
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 9 */
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
block|}
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
return|return
operator|(
name|CLOSE_WAIT
operator|)
return|;
block|}
elseif|else
comment|/* no FIN */
comment|/* if good ACK, open connection, otherwise wait for one */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
condition|)
block|{
comment|/* 11 */
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
name|soisconnected
argument_list|(
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTAB
operator|)
return|;
block|}
return|return
operator|(
name|SYN_RCVD
operator|)
return|;
comment|/* 8 */
block|}
end_block

begin_comment
comment|/*  * SYN_RCVD   x INRECV  * L_SYN_RCVD x INRECV  *  * from tcp_input/netprepr, we know its an ACK of our SYN  */
end_comment

begin_macro
name|syr_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* if no FIN, open connection, otherwise wait for user close */
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
comment|/* 33 */
return|return
operator|(
name|CLOSE_WAIT
operator|)
return|;
else|else
block|{
comment|/* 5 */
name|soisconnected
argument_list|(
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTAB
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * ESTAB x INRECV  */
end_comment

begin_macro
name|est_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|PRESENT_DATA
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* if no FIN, remain open, otherwise wait for user close */
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
comment|/* 12 */
return|return
operator|(
name|CLOSE_WAIT
operator|)
return|;
else|else
comment|/* 39 */
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FIN_WAIT_1 x INRECV  *  * incoming segment after user has closed  */
end_comment

begin_macro
name|fw1_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
comment|/* process any incoming data, since we closed but they didn't */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* send any data remaining on send buffer */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_fin
argument_list|(
name|tp
argument_list|,
name|n
argument_list|)
condition|)
block|{
comment|/* our FIN got ACKed */
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
block|{
comment|/* got for FIN (28) */
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|TIME_WAIT
operator|)
return|;
block|}
else|else
comment|/* no FIN, wait (27) */
return|return
operator|(
name|FIN_W2
operator|)
return|;
block|}
else|else
block|{
comment|/* no ACK of FIN */
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
block|{
comment|/* got for FIN (26) */
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|CLOSING1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SAME
operator|)
return|;
comment|/* 39 */
block|}
end_block

begin_comment
comment|/*  * FIN_WAIT_2 x INRECV  *  * incoming segment while waiting for foreign FIN  */
end_comment

begin_macro
name|fw2_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
comment|/* process data since we closed, but they may not have */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* if we get the FIN, start the finack timer, else keep waiting */
if|if
condition|(
name|tp
operator|->
name|fin_rcvd
condition|)
block|{
comment|/* got for FIN (29) */
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|TIME_WAIT
operator|)
return|;
block|}
else|else
comment|/* 39 */
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * TIME_WAIT x INRECV  *  * The close protocol (exchange of FINs) has progressed as far as it can.  * We do not enter CLOSED immediately, but use TIME_WAIT so that if our ack  * of other guys FIN didn't reach him, he can retransmit and we'll ack his  * fin rather than respond with an rst.  *  * Since we received a packet, apparently our ack of his fin didn't get  * there and we'll have to try again.  Restart finack timer in case this  * one fails too.  */
end_comment

begin_macro
name|sss_syn
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CLOSE_WAIT x INRECV  *  * incoming segment after receipt of foreign FIN (local end still open)  */
end_comment

begin_macro
name|cwt_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
comment|/* either duplicate FIN or data */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_FIN
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
operator|&&
name|SEQ_LEQ
argument_list|(
name|n
operator|->
name|t_ackno
argument_list|,
name|tp
operator|->
name|seq_fin
argument_list|)
condition|)
block|{
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
comment|/* 31 */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* duplicate data (39) */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CLOSING_1 x INRECV  *  * incoming segment after we closed  */
end_comment

begin_macro
name|cl1_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
if|if
condition|(
name|ack_fin
argument_list|(
name|tp
argument_list|,
name|n
argument_list|)
condition|)
block|{
comment|/* got ACK of our FIN */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_FIN
condition|)
block|{
comment|/* got for FIN (23) */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|TIME_WAIT
operator|)
return|;
block|}
else|else
block|{
comment|/* if wait done, see if any data left for user */
if|if
condition|(
name|tp
operator|->
name|waited_2_ml
condition|)
if|if
condition|(
name|rcv_empty
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* 15 */
name|t_close
argument_list|(
name|tp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
else|else
return|return
operator|(
name|RCV_WAIT
operator|)
return|;
comment|/* 18 */
else|else
return|return
operator|(
name|TIME_WAIT
operator|)
return|;
comment|/* 22 */
block|}
block|}
else|else
block|{
comment|/* our FIN not ACKed yet */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_FIN
condition|)
block|{
comment|/* rcvd for FIN (30) */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* no FIN, just proc new data (39) */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CLOSING_2 x INRECV  *  * incoming segment after both of us have started closing  */
end_comment

begin_macro
name|cl2_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
if|if
condition|(
name|ack_fin
argument_list|(
name|tp
argument_list|,
name|n
argument_list|)
condition|)
block|{
comment|/* this is ACK of our fin */
comment|/* if no data left for user, close; otherwise wait */
if|if
condition|(
name|rcv_empty
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* 16 */
name|t_close
argument_list|(
name|tp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
else|else
comment|/* 19 */
return|return
operator|(
name|RCV_WAIT
operator|)
return|;
block|}
else|else
block|{
comment|/* no ACK of our FIN */
comment|/* duplicate FIN or data */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_FIN
condition|)
comment|/* 31 */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
comment|/* ACK duplicate FIN */
else|else
block|{
comment|/* 39 */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * RCV_WAIT x INRECV  */
end_comment

begin_macro
name|rwt_netr
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* incoming seg while waiting for user rcv (30,21) */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|n
init|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
decl_stmt|;
comment|/* handle duplicate ACK of our FIN */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_FIN
operator|&&
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
operator|&&
name|SEQ_LEQ
argument_list|(
name|n
operator|->
name|t_ackno
argument_list|,
name|tp
operator|->
name|seq_fin
argument_list|)
condition|)
block|{
comment|/* 30 */
name|rcv_tcp
argument_list|(
name|tp
argument_list|,
name|n
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TFINACK
index|]
operator|=
name|TCP_tv2ML
expr_stmt|;
name|tp
operator|->
name|waited_2_ml
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	ESTAB      x IURECV  *	CLOSE_WAIT x IURECV  *  * and allowing for shutdown()  *  *	FIN_WAIT_1 x IURECV  *	FIN_WAIT_2 x IURECV  *	TIME_WAIT  x IURECV  *	CLOSING_1  x IURECV  *	CLOSING_2  x IURECV  */
end_comment

begin_macro
name|sss_rcv
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* rcv request on open connection (42) */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|PRESENT_DATA
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* if last window sent was zero, send an ACK to update window */
if|if
condition|(
name|tp
operator|->
name|sent_zero
condition|)
block|{
name|tp
operator|->
name|force_ack
operator|=
name|TRUE
expr_stmt|;
comment|/* don't delay ACK here */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * RCV_WAIT x IURECV  */
end_comment

begin_macro
name|cls_rwt
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* rcv request after foreign close (20) */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
name|present_data
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* present any remaining data */
if|if
condition|(
name|rcv_empty
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|t_close
argument_list|(
name|tp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
else|else
return|return
operator|(
name|RCV_WAIT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * SYN_SENT   x IUSEND  * SYN_RCVD   x IUSEND  * ESTAB      x IUSEND  * CLOSE_WAIT x IUSEND  *  * For SYN_SENT and SYN_RCVD, just want to buffer data until connected.  */
end_comment

begin_macro
name|sss_snd
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* send request on open connection (40,41) */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tcp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tcp
operator|->
name|t_in_pcb
decl_stmt|;
name|sequence
name|last
decl_stmt|;
name|sbappend
argument_list|(
operator|&
name|inp
operator|->
name|inp_socket
operator|->
name|so_snd
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|wp
operator|->
name|w_dat
argument_list|)
expr_stmt|;
name|last
operator|=
name|tcp
operator|->
name|snd_una
operator|+
name|inp
operator|->
name|inp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|t_push
condition|)
name|tcp
operator|->
name|snd_end
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|t_urg
condition|)
block|{
name|tcp
operator|->
name|snd_urp
operator|=
name|last
expr_stmt|;
comment|/* this byte is not urgent */
name|tcp
operator|->
name|snd_urg
operator|=
name|TRUE
expr_stmt|;
block|}
name|send_tcp
argument_list|(
name|tcp
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_macro
name|cls_act
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* net closing open connection (47) */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|t_close
argument_list|(
name|wp
operator|->
name|w_tcb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
end_block

begin_macro
name|cls_err
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* invalid user request in closing states */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise_user
argument_list|(
name|tcpcbtoso
argument_list|(
name|wp
operator|->
name|w_tcb
argument_list|)
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

begin_macro
name|timers
argument_list|(
argument|wp
argument_list|)
end_macro

begin_comment
comment|/* timer processor (14,17,34,35,36,37,38) */
end_comment

begin_decl_stmt
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|wp
operator|->
name|w_tcb
decl_stmt|;
specifier|register
name|type
operator|=
name|wp
operator|->
name|w_stype
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TINIT
case|:
comment|/* initialization timer */
comment|/* 	 * Haven't got an ACK of our SYN yet 	 */
if|if
condition|(
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
operator|->
name|so_state
operator|&
name|SS_NOFDREF
condition|)
block|{
comment|/* 	     * was a child socket of a listen(2)er trying to 	     * establish connection with other end. 	     * (state L_SYN_RCVD) 	     */
name|t_close
argument_list|(
name|tp
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
comment|/* socket in connect(2) */
name|advise_user
argument_list|(
name|tcpcbtoso
argument_list|(
name|tp
argument_list|)
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TINIT
index|]
operator|=
name|tp
operator|->
name|t_itimeo
expr_stmt|;
break|break;
case|case
name|TFINACK
case|:
comment|/* fin-ack timer */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TIME_WAIT
condition|)
block|{
comment|/* can be sure our ACK of for FIN was rcvd, 	       can close if no data left for user */
if|if
condition|(
name|rcv_empty
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* 14 */
name|t_close
argument_list|(
name|tp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
else|else
comment|/* 17 */
return|return
operator|(
name|RCV_WAIT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|CLOSING1
condition|)
comment|/* 37 */
comment|/* safe to close */
name|tp
operator|->
name|waited_2_ml
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|TREXMT
case|:
comment|/* retransmission timer */
if|if
condition|(
name|is_unacked
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* statistics */
name|tp
operator|->
name|t_rxtct
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|t_retransmit
operator|++
expr_stmt|;
comment|/* 	     * If we're retransmitting, then the network 	     * may be dropping packets because it is overloaded. 	     * Therefore, increase the retransmission time for 	     * successive retransmissions.  When we get an ACK, 	     * the srtt and rxmitime will be recalculated. 	     */
name|tp
operator|->
name|t_rxmitime
operator|=
name|tp
operator|->
name|t_rxmitime
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_rxmitime
operator|>
name|TCP_tvRXMAX
condition|)
name|tp
operator|->
name|t_rxmitime
operator|=
name|TCP_tvRXMAX
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
name|tp
operator|->
name|rexmt
operator|=
name|TRUE
expr_stmt|;
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rexmt
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|TREXMTTL
case|:
comment|/* retransmit too long */
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_REXMTTL, (caddr_t)0, 0); */
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|usr_abort
condition|)
block|{
comment|/* user has already closed for r/w so abort connection 	     * usr_closed == closed for w (close or shutdown). 	     */
name|t_close
argument_list|(
name|tp
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
name|advise_user
argument_list|(
name|tcpcbtoso
argument_list|(
name|tp
argument_list|)
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TREXMTTL
index|]
operator|=
name|tp
operator|->
name|t_rttltimeo
expr_stmt|;
break|break;
case|case
name|TPERSIST
case|:
comment|/* persist timer */
comment|/* force a byte send through closed window */
name|tp
operator|->
name|force_one
operator|=
name|TRUE
expr_stmt|;
comment|/* 38 */
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_DATA
argument_list|)
expr_stmt|;
comment|/* restarts timer */
name|tp
operator|->
name|force_one
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|TDELACK
case|:
comment|/* ack-delay timer */
comment|/* make sure an ack gets sent now */
name|tp
operator|->
name|force_ack
operator|=
name|TRUE
expr_stmt|;
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
break|break;
case|case
name|TNOACT
case|:
comment|/* no activity timer */
comment|/* 	 * This timer is used for 2 reasons: 	 * 1) by the user to determine if the connection is idle or if the 	 *    other side has aborted/rebooted...  This is open states entry. 	 *    See tcp_newtcpcb() 	 * 2) by the system to timeout on receipt of ACK of our FIN. 	 *    This is separate from use of FINACK timer for other guy 	 *    to get our ACK of his FIN.  If closing has started, finish it. 	 */
comment|/* 	 * if its a shutdown(), 	 *	usr_closed == TRUE, usr_abort == FALSE 	 *	the user will find out about any problems getting an ACK of our 	 *	    FIN through the retransmit took too long timer 	 *	the connection could be idle because it takes the remote end a 	 *	    while to compute and produce a reply 	 *	user only gets to crank up protocol close once, but he can 	 *	    shutdown and then close, thereby adjusting usr_abort so 	 *	    that things get cleaned up if the remote host died. 	 * 	 * if its a close(), 	 *	usr_closed == TRUE, usr_abort == TRUE 	 *	user could be lingering (and SS_NOFDREF will still be false) 	 *	connection could be idle because the other host failed, and it 	 *	    could be down for days.  We don't want to wait for it to 	 *	    come back up and give us a reset.  Release resources now. 	 */
if|if
condition|(
name|tp
operator|->
name|usr_abort
condition|)
block|{
name|t_close
argument_list|(
name|tp
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|CLOSED
operator|)
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_noactprobe
condition|)
name|send_tcp
argument_list|(
name|tp
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_noactsig
condition|)
name|advise_user
argument_list|(
name|tcpcbtoso
argument_list|(
name|tp
argument_list|)
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|SAME
operator|)
return|;
block|}
end_block

end_unit

