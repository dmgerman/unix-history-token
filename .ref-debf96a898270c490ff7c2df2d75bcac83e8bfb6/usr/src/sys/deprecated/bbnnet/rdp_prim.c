begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Log:	rdp_prim.c,v $  * Revision 2.15  85/03/12  08:41:13  walsh  * Don't advise the user about ENOBUFS errors passed back from device drivers+  * ip_send() when the protocol has a retransmission strategy.  *   * Revision 2.14  85/03/06  10:06:16  walsh  * Corrected some error handling and reporting.  *   * Revision 2.13  85/02/26  08:26:56  walsh  * First pass at using IP source routing information to establish connections  * (possibly with hosts not known by the Internet gateways.)  The hooks with  * TCP could be better done - particularly dealing with IP addresses in the  * header for checksums and tcpdb lookups.  *   * Revision 2.12  84/11/15  09:56:04  walsh  * redid how we deal with compiler padding in the RDP header structure.  *   * Revision 2.11  84/11/08  16:11:51  walsh  * Added code to gather statistics on RDP traffic.  This makes the RDPCB  * too big unles you make mbufs 512 bytes large.  RDP_CS should be turned off  * unless you do.  *   * Revision 2.10  84/11/06  15:24:26  walsh  * *** empty log message ***  *   * Revision 2.9  84/11/06  14:30:23  walsh  * intorduced RDP_HLSHIFT  *   * Revision 2.8  84/11/06  09:09:16  walsh  * added missing include.  *   * Revision 2.7  84/11/05  15:55:28  walsh  * update_nulltimer() macro began to look inappropriate with recent  * changes, so its been stripped out and put in-line.  *   * Revision 2.6  84/11/05  15:23:23  walsh  * *** empty log message ***  *   * Revision 2.5  84/11/05  15:17:53  walsh  * added comments on acknowledgement strategy.  *   * Revision 2.4  84/11/05  11:05:20  walsh  * comment and adjust number for rdp_iss in a mathematically correct way  * as a result of benchmarks (cf. operationally correct).  *   * Revision 2.3  84/11/02  18:24:09  walsh  * Protocol specifiers want NULL message to have own sequence number in  * case of slow (t>NULL msg timeout) packets.  I don't see this as a problem,  * and even if happened (dubious) would only delay discovery, but I  * didn't win this one.  Initially not designed for this, but fixes are  * in almost neatly.  *   * Revision 2.2  84/11/02  15:28:56  walsh  * Allow for RDP header fields not on natural boundries.  (Protocol  * specifiers say will be part of next version in 6-12 months).  * Until then, there goes the speed...  Yucho modifications.  *   * Revision 2.1  84/11/02  10:13:48  walsh  * Fixed to include RCS comments in checked out source.  *   *  * description:  * some primitives for RDP.  *   * revision 1.10          * date: 84/07/19 10:21:35;  author: walsh;  state: Exp;  lines added/del: 1/0  * Organized macros and classified their definitions in rdp_macros.h.  *   * revision 1.9          * date: 84/07/18 18:50:44;  author: walsh;  state: Exp;  lines added/del: 5/0  * Added provision for sending of NULL messages.  These are sent on an idle  * connection to determine that the other side still exists.  *   * revision 1.8          * date: 84/07/12 20:04:16;  author: walsh;  state: Exp;  lines added/del: 1/2  * *** empty log message ***  *   * revision 1.7          * date: 84/07/12 13:48:14;  author: walsh;  state: Exp;  lines added/del: 31/16  * Rather than in-line stuffing of IP/RDP headers, at least half of which are  * constant, copy headers in from a template of what the headers are like.  The  * bcopy() call is turned into a movc3 instruction on the VAX by a sed script  * run over the assembler output of the C compiler.  Marginal speed-up.  *   * revision 1.6          * date: 84/07/12 09:29:48;  author: walsh;  state: Exp;  lines added/del: 6/9  * Found:  * 1.  If MGET saves anything over mget, it's down in the noise, so skip it.  * 2.  stuff_eacks as macro DOES save time.  * 3.  Optimized stuff_eacks by timing and looking at a lot of assembler output  *	from the C compiler.  *   * revision 1.5          * date: 84/07/10 09:41:52;  author: walsh;  state: Exp;  lines added/del: 43/41  * Corrected problem with conversion of stuff_eacks from a function to a  * macro.  *   * Changed rdp_sendpkt to avoid unecessary allocation and deallocation of  * an mbuf for syn and eack options.  *   * revision 1.4          * date: 84/07/09 14:39:54;  author: walsh;  state: Exp;  lines added/del: 1/0  * Part of ACK-delay algorithm.  Whenever send a packet with an ACK, set  * ACK-delay timer to zero.  *   * revision 1.3          * date: 84/07/06 14:10:35;  author: wjacobso;  state: Exp;  lines added/del: 34/34  * stuff_eacks made into macro; added register var definitions  *   * revision 1.2          * date: 84/07/06 09:49:37;  author: root;  state: Exp;  lines added/del: 11/4  * This version seems to run bug-free.  *   * revision 1.1          * date: 84/06/26 14:17:39;  author: walsh;  state: Exp;    * Initial revision  *   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RDP
end_ifdef

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp_macros.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|inpcb
name|rdp
decl_stmt|;
end_decl_stmt

begin_macro
name|rdp_template
argument_list|(
argument|rdpcb
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|INPCB
modifier|*
name|inp
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|rdpcb
operator|->
name|r_template
expr_stmt|;
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|inp
operator|=
name|rdpcb
operator|->
name|r_inpcb
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_RDP
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
name|pkt
operator|->
name|rh_ver
operator|=
name|RDP_VERSION
expr_stmt|;
name|pkt
operator|->
name|rh_hdrlen
operator|=
name|RDPHDRSZ
operator|>>
name|RDP_HLSHIFT
expr_stmt|;
name|pkt
operator|->
name|rh_sport
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|pkt
operator|->
name|rh_dport
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
name|pkt
operator|->
name|rh_flags
operator|=
literal|0
expr_stmt|;
name|RDP_CKSUM
argument_list|(
name|pkt
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************************************  Comments on the Acknowledgement Strategy   I.  It would be desirable to save network, CPU, and buffering resources 	by not retransmitting packets which have arrived at the destination 	host.  One might think of doing this by using the cumulative ack 	(ACK) for flow control and the extended ack (EACK) for reliability. 	[EACK upon reception by protocol module, ACK upon reception by 	application]   You can't do this.   1.  The protocol specifiers state that an implementation may choose 	to treat ACK#1 EACK#2 EACK#3 as ACK#3.  We want to avoid receiving 	packets we can't buffer.  (see goals above)  2.  NULL packets are sent on idle connections (all packets acknowledged) 	and occupy sequence number space.  We want to avoid situations 	where a NULL packet goes out of our window, doesn't get acked, 	and the connection gets dropped.  (connection would be idle since 	no transmissions/retransmissions would be going on if packets 	received by RDP, but destination process busy doing something 	else.)  3.  Relying on ACKs to be sent to move the window's edge after the 	datagram is picked up by the user process has to deal with the 	fact that that ACK may be lost.  In TCP, one uses a persistence 	timer to deal with this.  Use of ACK/EACK above implies that 	there is no data with which to perform persistence (if buffers 	reclaimed at EACK and not at ACK.)  One could think of using 	NULL messages to reopen the window, but a) NULL messages only 	start up after LONG delays,  b) implementations are only required 	to respond to, not initiate, NULL messages.   2 would be a correctness error.  1+3 would be stylistic problems.  Therefore, the acknowledgement strategy implemented here is to  ACK or EACK messages only after they have been received by the destination  process.  This means that some unecessary retransmissions might occur,  but such is life.  (Unecessary from the point of view that the  information made it through the network a-o.k.)   If the application is slow to pick up messages from the protocol,  then that will be reflected in the round trip time estimate (and  retransmission time) for the other end.  So, maybe this isn't all  that bad.  Especially since most processes will be fairly interested  and responsive to network input.   ***********************************************************************/
end_comment

begin_comment
comment|/*  * rdp_init ensures max # of options fit in mbuf  */
end_comment

begin_define
define|#
directive|define
name|stuff_eacks
parameter_list|(
name|rdpcb
parameter_list|,
name|optm
parameter_list|)
define|\
value|{ \ 	register int		 pass;					\ 	register int		 index;					\ 		 EACKOPTIONS	*eopt;					\  \ 	pass	= 0;							\ 	index	= rdpcb->r_rcvq.rq_front;				\  \ 	do {								\ 		if (rdpcb->r_rcvq.rq_msgs[index] == RDP_DELIVERED){	\ 			if (optm == NULL){				\ 				optm = m_get(M_DONTWAIT, MT_HEADER);	\ 				if (optm == NULL)			\ 					break;				\ 				optm->m_len = 0;			\ 				eopt = mtod(optm, EACKOPTIONS *);	\ 			}						\ 			eopt->rh_eackno =				\ 				htonl(rdpcb->r_rcvq.rq_baseseq + pass); \ 			eopt ++;					\ 			optm->m_len += sizeof(EACKOPTIONS);		\ 		}							\ 		index = (index + 1) % rdpcb->r_rcvq.rq_maxqlen;		\ 	} while (++pass< rdpcb->r_rcvq.rq_maxqlen);			\ }
end_define

begin_expr_stmt
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|seqnum
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MBUF
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of data mbuf chain in bytes */
end_comment

begin_decl_stmt
name|rdpsequence
name|seqnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host order.  seq# of this packet */
end_comment

begin_block
block|{
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|RDPHDRSZ
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|RDPHDRSZ
operator|+
sizeof|sizeof
argument_list|(
name|SYNOPTIONS
argument_list|)
operator|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|data
expr_stmt|;
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
comment|/*      * Fills in most IP and RDP header fields      */
name|bcopy
argument_list|(
name|rdpcb
operator|->
name|r_template
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|RDP_TEMPLSIZE
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|rh_dlen
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|datalen
argument_list|)
expr_stmt|;
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
operator|=
name|htonl
argument_list|(
operator|(
name|u_long
operator|)
name|seqnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|->
name|r_sendrst
condition|)
block|{
name|pkt
operator|->
name|rh_flags
operator||=
name|RDP_fRST
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_rstpkts
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rdpcb
operator|->
name|r_synacked
condition|)
block|{
specifier|register
name|SYNOPTIONS
modifier|*
name|synopt
decl_stmt|;
name|pkt
operator|->
name|rh_flags
operator||=
name|RDP_fSYN
expr_stmt|;
name|pkt
operator|->
name|rh_hdrlen
operator|+=
sizeof|sizeof
argument_list|(
name|SYNOPTIONS
argument_list|)
operator|>>
name|RDP_HLSHIFT
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
name|SYNOPTIONS
argument_list|)
expr_stmt|;
name|synopt
operator|=
name|RDP_OPT
argument_list|(
name|pkt
argument_list|,
name|SYNOPTIONS
operator|*
argument_list|)
expr_stmt|;
name|synopt
operator|->
name|rh_nbuf
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|rdpcb
operator|->
name|r_ournbuf
argument_list|)
expr_stmt|;
name|synopt
operator|->
name|rh_maxlen
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|rdpcb
operator|->
name|r_ourmaxlen
operator|+
name|HDRSLOP
argument_list|)
expr_stmt|;
name|synopt
operator|->
name|rh_options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|->
name|r_sequential
condition|)
name|synopt
operator|->
name|rh_options
operator||=
name|RDP_oSEQUENTIAL
expr_stmt|;
name|synopt
operator|->
name|rh_options
operator|=
name|htons
argument_list|(
name|synopt
operator|->
name|rh_options
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_synpkts
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
specifier|register
name|MBUF
modifier|*
name|optm
decl_stmt|;
comment|/* possible EACK */
name|optm
operator|=
name|NULL
expr_stmt|;
name|stuff_eacks
argument_list|(
name|rdpcb
argument_list|,
name|optm
argument_list|)
expr_stmt|;
if|if
condition|(
name|optm
condition|)
block|{
define|#
directive|define
name|OKSZ
value|(datalen+RDPHDRSZ+sizeof(struct ip)+optm->m_len<= rdpcb->r_hismaxlen)
if|if
condition|(
name|OKSZ
condition|)
block|{
name|pkt
operator|->
name|rh_flags
operator||=
name|RDP_fEACK
expr_stmt|;
name|pkt
operator|->
name|rh_hdrlen
operator|+=
name|optm
operator|->
name|m_len
operator|>>
name|RDP_HLSHIFT
expr_stmt|;
name|optm
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|optm
expr_stmt|;
block|}
else|else
name|m_free
argument_list|(
name|optm
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|OKSZ
block|}
if|if
condition|(
name|rdpcb
operator|->
name|r_sendnull
condition|)
block|{
name|rdpcb
operator|->
name|r_sendnull
operator|=
name|FALSE
expr_stmt|;
name|pkt
operator|->
name|rh_flags
operator||=
name|RDP_fNULL
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_nullpkts
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|rdpcb
operator|->
name|r_synrcvd
condition|)
block|{
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tACKDELAY
index|]
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|rh_flags
operator||=
name|RDP_fACK
expr_stmt|;
name|RDP_ACKNO
argument_list|(
name|pkt
argument_list|)
operator|=
name|htonl
argument_list|(
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|RDP_CKSUM
argument_list|(
name|pkt
argument_list|)
operator|=
name|rdp_cksum
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_total
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug_rdpcb
argument_list|(
name|rdpcb
argument_list|)
condition|)
name|rdp_debug
argument_list|(
name|rdpcb
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|RDP_sSAME
argument_list|)
expr_stmt|;
comment|/*      * and ship packet off via IP.  Remember that since this protocol      * involves retransmissions, errors can occur asynchronous to a      * (write) system call, and that therefore we can not send the      * error all the way back up through subroutine return values.  We      * must also post it back via advise_user() at some point, and this      * looks like a good point to try it.      */
block|{
specifier|register
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ip_send
argument_list|(
name|rdpcb
operator|->
name|r_inpcb
argument_list|,
name|m
argument_list|,
call|(
name|int
call|)
argument_list|(
name|datalen
operator|+
name|hdrlen
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
comment|/* 	     * Since we use retransmissions, don't need to tell user 	     * process about this.  (Can be as simple as interface 	     * or host structure queues are too long due to current 	     * heavy traffic.  Backing off will take care of that.) 	     */
if|if
condition|(
name|error
operator|!=
name|ENOBUFS
condition|)
name|advise_user
argument_list|(
name|rdpcbtoso
argument_list|(
name|rdpcb
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|rdp_timeo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
specifier|register
name|int
name|timer
decl_stmt|;
name|int
name|s
decl_stmt|;
specifier|register
name|rdpstate
name|newstate
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rdp_iss
operator|+=
name|RDP_ISSINCR
expr_stmt|;
comment|/*      * Remember, if CLOSEWAIT timer goes off, lose rdpcb's mbuf and      * and next pointer in it.      */
name|inp
operator|=
name|rdp
operator|.
name|inp_next
expr_stmt|;
while|while
condition|(
name|inp
operator|!=
operator|&
name|rdp
condition|)
block|{
name|next
operator|=
name|inp
operator|->
name|inp_next
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|=
name|inptordpcb
argument_list|(
name|inp
argument_list|)
condition|)
block|{
name|rdpcb
operator|->
name|r_rtt
operator|++
expr_stmt|;
for|for
control|(
name|timer
operator|=
literal|0
init|;
name|timer
operator|<
name|RDP_NTIMERS
condition|;
name|timer
operator|++
control|)
block|{
if|if
condition|(
name|rdpcb
operator|->
name|r_timers
index|[
name|timer
index|]
condition|)
block|{
name|rdpcb
operator|->
name|r_timers
index|[
name|timer
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|->
name|r_timers
index|[
name|timer
index|]
operator|==
literal|0
condition|)
block|{
name|RDP_ACTION
argument_list|(
argument|RDP_iTIMER
argument_list|,
argument|rdpcb
argument_list|,
argument|timer
argument_list|,
argument|newstate
argument_list|)
if|if
condition|(
name|newstate
operator|==
name|RDP_sCLOSED
condition|)
comment|/* next rdpcb */
break|break;
block|}
block|}
block|}
block|}
name|inp
operator|=
name|next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

