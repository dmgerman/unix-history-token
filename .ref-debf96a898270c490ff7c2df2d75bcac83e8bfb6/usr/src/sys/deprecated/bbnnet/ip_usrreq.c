begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*                                                                        */
end_comment

begin_comment
comment|/*                    miscellaneous ip routines                           */
end_comment

begin_comment
comment|/*                                                                        */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../net/af.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_macro
name|ip_ioctl
argument_list|(
argument|inp
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* no IP ioctls */
return|return
name|in_ioctl
argument_list|(
name|command
argument_list|,
name|data
argument_list|)
return|;
block|}
end_block

begin_macro
name|ip_ctloutput
argument_list|(
argument|req
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|optname
argument_list|,
argument|optval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|,
name|optname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|optval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/*      * O.K., with the berkeley method of using the protocol number for the level,      * what magic cookie should we use to distinguish between IP and the interfaces?      */
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRCO_GETOPT
case|:
return|return
operator|(
name|ip_getopt
argument_list|(
name|inp
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
operator|)
return|;
case|case
name|PRCO_SETOPT
case|:
return|return
operator|(
name|ip_setopt
argument_list|(
name|inp
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"ip_ctloutput"
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_macro
name|ip_setopt
argument_list|(
argument|inpcb
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|data
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SO_IPROUTE
case|:
comment|/* this probably breaks!! */
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
comment|/* turns off use of options */
name|inpcb
operator|->
name|inp_optlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|<
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|m
operator|->
name|m_len
operator|>
operator|(
name|MAX_IPOPTLEN
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|m
operator|->
name|m_len
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 	 * O.K., user process specifies it as: 	 *      ->A->B->C->D 	 * D must be our final destination (but we can't 	 * check that since we haven't connected yet). 	 * Convert this into a form for ip_output. 	 */
name|inpcb
operator|->
name|inp_optlen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|inpcb
operator|->
name|inp_options
argument_list|,
operator|(
name|unsigned
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* 	 * Following could be moved to ip_send(), but let's 	 * do it once for efficiency even though user may 	 * retrieve different from what stored. 	 */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ipa
decl_stmt|;
name|p
operator|=
name|inpcb
operator|->
name|inp_options
expr_stmt|;
name|ipa
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|p
expr_stmt|;
name|ipa
index|[
name|m
operator|->
name|m_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
index|]
operator|=
name|ipa
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|IP_NOP_OPT
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|IP_LRTE_OPT
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|m
operator|->
name|m_len
operator|-
literal|1
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|4
expr_stmt|;
comment|/* offset: counting one based */
block|}
comment|/* 	 * Now we have a correct IP source route recorded, 	 * and the first hop comes after the source route. 	 */
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* they can futz with m */
if|if
condition|(
operator|*
name|data
condition|)
name|m_freem
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|ip_getopt
argument_list|(
argument|inpcb
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|error
operator|=
literal|0
expr_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
operator|*
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* o.k. (no data sent on getsockopt) */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SO_IPROUTE
case|:
if|if
condition|(
operator|!
name|inpcb
operator|->
name|inp_optlen
condition|)
break|break;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|inpcb
operator|->
name|inp_optlen
expr_stmt|;
name|bcopy
argument_list|(
name|inpcb
operator|->
name|inp_options
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|*
name|data
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|u_char
name|inetctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
name|ENETUNREACH
block|,
comment|/* PRC_IFDOWN: connection oriented protocols use 			 * interface with their local address.  Can't re-route. 			 */
name|ECONNABORTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|ENETUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

