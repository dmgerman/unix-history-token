begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_define
define|#
directive|define
name|NDOVARS
value|15
end_define

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/*  * Ndo  maclisp do function.  */
end_comment

begin_function
name|lispval
name|Ndo
parameter_list|()
block|{
specifier|register
name|lispval
name|current
decl_stmt|,
name|where
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|mybnp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lispval
name|atom
decl_stmt|,
name|temp
decl_stmt|;
name|lispval
name|body
decl_stmt|,
name|endtest
decl_stmt|,
name|endform
decl_stmt|,
name|varstuf
decl_stmt|,
name|renewals
index|[
name|NDOVARS
index|]
decl_stmt|;
name|struct
name|argent
modifier|*
name|start
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|getem
decl_stmt|,
modifier|*
name|savedlbot
decl_stmt|;
name|struct
name|nament
modifier|*
name|savedbnp
decl_stmt|,
modifier|*
name|lastbnd
decl_stmt|;
name|int
name|count
decl_stmt|,
name|index
decl_stmt|,
name|saveme
index|[
name|SAVSIZE
index|]
decl_stmt|,
name|virgin
init|=
literal|1
decl_stmt|;
name|int
name|myerrp
decl_stmt|;
specifier|extern
name|int
name|errp
decl_stmt|;
name|savedlbot
operator|=
name|lbot
expr_stmt|;
name|myerrp
operator|=
name|errp
expr_stmt|;
name|savedbnp
operator|=
name|bnp
expr_stmt|;
name|getexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
comment|/* common nonlocal return */
if|if
condition|(
name|retval
operator|=
name|setexit
argument_list|()
condition|)
block|{
name|errp
operator|=
name|myerrp
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|BRRETN
condition|)
block|{
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|savedlbot
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|contval
operator|)
return|;
block|}
else|else
block|{
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|savedlbot
expr_stmt|;
name|reset
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|varstuf
operator|=
name|current
operator|->
name|car
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|varstuf
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
comment|/* This is old style maclisp do; 					   atom is var, cadr(current) = init; 					   caddr(current) = repeat etc. */
name|atom
operator|=
name|varstuf
expr_stmt|;
if|if
condition|(
name|varstuf
operator|==
name|nil
condition|)
goto|goto
name|newstyle
goto|;
name|bnp
operator|->
name|atm
operator|=
name|atom
expr_stmt|;
comment|/* save current binding of atom */
name|bnp
operator|++
operator|->
name|val
operator|=
name|atom
operator|->
name|clb
expr_stmt|;
if|if
condition|(
name|bnp
operator|>
name|bnplim
condition|)
name|binderr
argument_list|()
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|cdr
expr_stmt|;
name|atom
operator|->
name|clb
operator|=
name|eval
argument_list|(
name|current
operator|->
name|car
argument_list|)
expr_stmt|;
comment|/* Init var.	    */
operator|*
name|renewals
operator|=
operator|(
name|current
operator|=
name|current
operator|->
name|cdr
operator|)
operator|->
name|car
expr_stmt|;
comment|/* get repeat form  */
name|endtest
operator|=
operator|(
name|current
operator|=
name|current
operator|->
name|cdr
operator|)
operator|->
name|car
expr_stmt|;
name|body
operator|=
name|current
operator|->
name|cdr
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|eval
argument_list|(
name|endtest
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|doprog
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|atom
operator|->
name|clb
operator|=
name|eval
argument_list|(
operator|*
name|renewals
argument_list|)
expr_stmt|;
block|}
name|newstyle
label|:
case|case
name|DTPR
case|:
comment|/* New style maclisp do; atom is 					   list of things of the form 					   (var init repeat)		*/
name|count
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|np
expr_stmt|;
for|for
control|(
name|where
operator|=
name|varstuf
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|cdr
control|)
block|{
comment|/* do inits and count do vars. */
comment|/* requires "simultaneous" eval 					   of all inits			*/
name|handy
operator|=
name|where
operator|->
name|car
operator|->
name|cdr
expr_stmt|;
name|temp
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|handy
operator|!=
name|nil
condition|)
name|temp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|NDOVARS
condition|)
name|error
argument_list|(
literal|"More than 15 do vars"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bnp
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|bnp
operator|>=
name|bnplim
condition|)
block|{
name|bnp
operator|=
name|savedbnp
expr_stmt|;
name|namerr
argument_list|()
expr_stmt|;
block|}
name|last
operator|=
name|np
expr_stmt|;
name|where
operator|=
name|varstuf
expr_stmt|;
name|mybnp
operator|=
name|savedbnp
expr_stmt|;
name|getem
operator|=
name|start
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
block|{
name|handy
operator|=
name|where
operator|->
name|car
expr_stmt|;
comment|/* get var name from group	*/
name|atom
operator|=
name|handy
operator|->
name|car
expr_stmt|;
name|mybnp
operator|->
name|atm
operator|=
name|atom
expr_stmt|;
name|mybnp
operator|->
name|val
operator|=
name|atom
operator|->
name|clb
expr_stmt|;
comment|/* Swap current binding of atom 					   for init val pushed on stack */
name|atom
operator|->
name|clb
operator|=
name|getem
operator|++
operator|->
name|val
expr_stmt|;
comment|/* As long as we are down here in the 					   list, save repeat form	*/
name|handy
operator|=
name|handy
operator|->
name|cdr
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|handy
operator|=
name|CNIL
expr_stmt|;
comment|/* be sure not to rebind later */
else|else
name|handy
operator|=
name|handy
operator|->
name|car
expr_stmt|;
name|renewals
index|[
name|index
index|]
operator|=
name|handy
expr_stmt|;
comment|/* more loop "increments" */
name|where
operator|=
name|where
operator|->
name|cdr
expr_stmt|;
name|mybnp
operator|++
expr_stmt|;
block|}
comment|/* Examine End test and End form */
name|current
operator|=
name|current
operator|->
name|cdr
expr_stmt|;
name|handy
operator|=
name|current
operator|->
name|car
expr_stmt|;
name|body
operator|=
name|current
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
block|{
name|doprog
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|endtest
operator|=
name|handy
operator|->
name|car
expr_stmt|;
name|endform
operator|=
name|handy
operator|->
name|cdr
expr_stmt|;
comment|/* The following is the loop: */
name|loop
label|:
if|if
condition|(
name|eval
argument_list|(
name|endtest
argument_list|)
operator|!=
name|nil
condition|)
block|{
for|for
control|(
name|handy
operator|=
name|nil
init|;
name|endform
operator|!=
name|nil
condition|;
name|endform
operator|=
name|endform
operator|->
name|cdr
control|)
block|{
name|handy
operator|=
name|eval
argument_list|(
name|endform
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
name|doprog
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* Simultaneously eval repeat forms */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
block|{
name|temp
operator|=
name|renewals
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|nil
operator|||
name|temp
operator|==
name|CNIL
condition|)
name|protect
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|protect
argument_list|(
name|eval
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getem
operator|=
operator|(
name|np
operator|=
name|last
operator|)
expr_stmt|;
comment|/* now simult. rebind all the atoms */
name|mybnp
operator|=
name|savedbnp
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
operator|,
name|getem
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|getem
operator|)
operator|->
name|val
operator|!=
name|CNIL
condition|)
comment|/* if this atom has a repeat form */
name|mybnp
operator|->
name|atm
operator|->
name|clb
operator|=
operator|(
name|getem
operator|)
operator|->
name|val
expr_stmt|;
comment|/* rebind */
name|mybnp
operator|++
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_expr_stmt
name|doprog
argument_list|(
name|body
argument_list|)
specifier|register
name|lispval
name|body
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|saveme
index|[
name|SAVSIZE
index|]
decl_stmt|;
specifier|register
name|lispval
name|where
decl_stmt|,
name|temp
decl_stmt|;
comment|/*register struct nament *savednp = np, *savedlbot = lbot;*/
specifier|extern
name|int
name|errp
decl_stmt|;
name|int
name|myerrp
init|=
name|errp
decl_stmt|;
name|struct
name|nament
modifier|*
name|savedbnp
init|=
name|bnp
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|where
operator|=
name|body
expr_stmt|;
name|getexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|=
name|setexit
argument_list|()
condition|)
block|{
name|errp
operator|=
name|myerrp
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
default|default:
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|retval
argument_list|)
expr_stmt|;
case|case
name|BRGOTO
case|:
for|for
control|(
name|where
operator|=
name|body
init|;
name|where
operator|->
name|car
operator|!=
operator|(
name|lispval
operator|)
name|contval
condition|;
name|where
operator|=
name|where
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|where
operator|==
name|nil
condition|)
block|{
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
comment|/* np is automatically restored here by 				   virtue of being a register */
block|}
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|temp
operator|=
name|where
operator|->
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|eval
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|cdr
expr_stmt|;
block|}
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|lispval
name|Nprogv
parameter_list|()
block|{
specifier|register
name|lispval
name|argptr
decl_stmt|,
name|where
decl_stmt|,
name|handy
decl_stmt|,
name|atoms
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|argent
modifier|*
name|namptr
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|protect
argument_list|(
name|eval
argument_list|(
name|where
operator|->
name|car
argument_list|)
argument_list|)
expr_stmt|;
comment|/* list of vars */
name|atoms
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|protect
argument_list|(
name|eval
argument_list|(
operator|(
name|where
operator|=
name|where
operator|->
name|cdr
operator|)
operator|->
name|car
argument_list|)
argument_list|)
expr_stmt|;
comment|/* list of vals */
name|handy
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
name|start
operator|=
name|np
expr_stmt|;
for|for
control|(
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
name|rebind
argument_list|(
name|atoms
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|handy
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|where
operator|=
name|where
operator|->
name|cdr
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|cdr
control|)
name|handy
operator|=
name|eval
argument_list|(
name|where
operator|->
name|car
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nprogn
parameter_list|()
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|where
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|where
operator|=
name|lbot
operator|->
name|val
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|cdr
control|)
name|result
operator|=
name|eval
argument_list|(
name|where
operator|->
name|car
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nprog2
parameter_list|()
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|where
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|eval
argument_list|(
name|where
operator|->
name|car
argument_list|)
expr_stmt|;
name|result
operator|=
name|eval
argument_list|(
operator|(
name|where
operator|=
name|where
operator|->
name|cdr
operator|)
operator|->
name|car
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|where
operator|=
name|where
operator|->
name|cdr
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|cdr
control|)
name|eval
argument_list|(
name|where
operator|->
name|car
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

