begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_argv.h"
end_include

begin_include
include|#
directive|include
file|"ex_temp.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * File input/output, unix escapes, source, filtering preserve and recover  */
end_comment

begin_comment
comment|/*  * Following remember where . was in the previous file for return  * on file switching.  */
end_comment

begin_decl_stmt
name|int
name|altdot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oldadot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|wasalt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cntch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of characters on unit io */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMUNIX
end_ifndef

begin_decl_stmt
name|short
name|cntln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of lines " */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|cntln
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|long
name|cntnull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of nulls " */
end_comment

begin_decl_stmt
name|long
name|cntodd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of non-ascii characters " */
end_comment

begin_comment
comment|/*  * Parse file name for command encoded by comm.  * If comm is E then command is doomed and we are  * parsing just so user won't have to retype the name.  */
end_comment

begin_macro
name|filename
argument_list|(
argument|comm
argument_list|)
end_macro

begin_decl_stmt
name|int
name|comm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
init|=
name|comm
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|comm
operator|!=
literal|'f'
condition|)
name|error
argument_list|(
literal|"No file|No current filename"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
name|wasalt
operator|=
literal|0
expr_stmt|;
name|oldadot
operator|=
name|altdot
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ungetchar
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|getone
argument_list|()
expr_stmt|;
name|eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|c
operator|!=
literal|'E'
operator|&&
name|c
operator|!=
literal|'e'
condition|)
block|{
name|c
operator|=
literal|'e'
expr_stmt|;
name|edited
operator|=
literal|0
expr_stmt|;
block|}
name|wasalt
operator|=
name|strcmp
argument_list|(
name|file
argument_list|,
name|altfile
argument_list|)
operator|==
literal|0
expr_stmt|;
name|oldadot
operator|=
name|altdot
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|edited
operator|=
literal|0
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'e'
case|:
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
condition|)
block|{
name|altdot
operator|=
name|lineDOT
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|altfile
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|(
name|savedfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|file
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'E'
condition|)
name|altdot
operator|=
name|lineDOT
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|altfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|hush
operator|&&
name|comm
operator|!=
literal|'f'
operator|||
name|comm
operator|==
literal|'E'
condition|)
return|return;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"\"%s\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|comm
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
operator|!
name|edited
condition|)
name|printf
argument_list|(
literal|" [Not edited]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tchng
condition|)
name|printf
argument_list|(
literal|" [Modified]"
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"No file "
argument_list|)
expr_stmt|;
if|if
condition|(
name|comm
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|lineDOL
argument_list|()
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|" line %d of %d --%ld%%--"
argument_list|,
name|lineDOT
argument_list|()
argument_list|,
name|lineDOL
argument_list|()
argument_list|,
operator|(
name|long
operator|)
literal|100
operator|*
name|lineDOT
argument_list|()
operator|/
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the argument words for a command into genbuf  * expanding # and %.  */
end_comment

begin_macro
name|getargs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
specifier|static
name|char
name|fpatbuf
index|[
literal|32
index|]
decl_stmt|;
comment|/* hence limit on :next +/pat */
name|pastwh
argument_list|()
expr_stmt|;
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'+'
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|fpatbuf
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
operator|&
name|fpatbuf
index|[
sizeof|sizeof
argument_list|(
name|fpatbuf
argument_list|)
index|]
condition|)
name|error
argument_list|(
literal|"Pattern too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|isspace
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
name|firstpat
operator|=
operator|&
name|fpatbuf
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|skipend
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CP
argument_list|(
name|genbuf
argument_list|,
literal|"echo "
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|genbuf
index|[
literal|5
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|any
argument_list|(
name|peekchar
argument_list|()
argument_list|,
literal|"#%"
argument_list|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* fall into... */
default|default:
if|if
condition|(
name|cp
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
name|flong
label|:
name|error
argument_list|(
literal|"Argument buffer overflow"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|fp
operator|=
name|altfile
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No alternate filename@to substitute for #"
argument_list|)
expr_stmt|;
goto|goto
name|filexp
goto|;
case|case
literal|'%'
case|:
name|fp
operator|=
name|savedfile
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No current filename@to substitute for %%"
argument_list|)
expr_stmt|;
name|filexp
label|:
while|while
condition|(
operator|*
name|fp
condition|)
block|{
if|if
condition|(
name|cp
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
goto|goto
name|flong
goto|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Glob the argument words in genbuf, or if no globbing  * is implied, just split them up directly.  */
end_comment

begin_macro
name|glob
argument_list|(
argument|gp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|glob
modifier|*
name|gp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pvec
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
init|=
name|gp
operator|->
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|gp
operator|->
name|argspac
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|nleft
init|=
name|NCARGS
decl_stmt|;
name|gp
operator|->
name|argc0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gscan
argument_list|()
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|v
init|=
name|genbuf
operator|+
literal|5
decl_stmt|;
comment|/* strlen("echo ") */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|v
condition|)
break|break;
operator|*
name|argv
operator|++
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|v
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|v
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|v
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|argc0
operator|++
expr_stmt|;
block|}
operator|*
name|argv
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|pvec
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't make pipe to glob"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
name|io
operator|=
name|pvec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Can't fork to do glob"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|oerrno
decl_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|svalue
argument_list|(
name|SHELL
argument_list|)
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|genbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oerrno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|filioerr
argument_list|(
name|svalue
argument_list|(
name|SHELL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|argv
operator|=
name|cp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|io
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
name|ch
operator|&
name|TRIM
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|--
name|nleft
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Arg list too long"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
operator|*
name|argv
condition|)
block|{
operator|--
name|nleft
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|argc0
operator|++
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|argc0
operator|>=
name|NARGS
condition|)
name|error
argument_list|(
literal|"Arg list too long"
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|>=
literal|0
condition|)
do|;
name|waitfor
argument_list|()
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|argc0
operator|==
literal|0
condition|)
name|error
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Scan genbuf for shell metacharacters.  * Set is union of v7 shell and csh metas.  */
end_comment

begin_macro
name|gscan
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|genbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"~{[*?$`'\"\\"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Parse one filename into file.  */
end_comment

begin_macro
name|getone
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|glob
name|G
decl_stmt|;
if|if
condition|(
name|getargs
argument_list|()
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Missing filename"
argument_list|)
expr_stmt|;
name|glob
argument_list|(
operator|&
name|G
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|argc0
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"Ambiguous|Too many file names"
argument_list|)
expr_stmt|;
name|str
operator|=
name|G
operator|.
name|argv
index|[
name|G
operator|.
name|argc0
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>
name|FNSIZE
operator|-
literal|4
condition|)
name|error
argument_list|(
literal|"Filename too long"
argument_list|)
expr_stmt|;
name|samef
label|:
name|CP
argument_list|(
name|file
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read a file from the world.  * C is command, 'e' if this really an edit (or a recover).  */
end_comment

begin_macro
name|rop
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|short
name|magic
decl_stmt|;
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|edited
operator|++
expr_stmt|;
name|syserror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|io
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
name|syserror
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFBLK
case|:
name|error
argument_list|(
literal|" Block special file"
argument_list|)
expr_stmt|;
case|case
name|S_IFCHR
case|:
if|if
condition|(
name|isatty
argument_list|(
name|io
argument_list|)
condition|)
name|error
argument_list|(
literal|" Teletype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|samei
argument_list|(
operator|&
name|stbuf
argument_list|,
literal|"/dev/null"
argument_list|)
condition|)
break|break;
name|error
argument_list|(
literal|" Character special file"
argument_list|)
expr_stmt|;
case|case
name|S_IFDIR
case|:
name|error
argument_list|(
literal|" Directory"
argument_list|)
expr_stmt|;
case|case
name|S_IFREG
case|:
name|i
operator|=
name|read
argument_list|(
name|io
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|io
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|magic
condition|)
block|{
case|case
literal|0405
case|:
case|case
literal|0407
case|:
case|case
literal|0410
case|:
case|case
literal|0411
case|:
name|error
argument_list|(
literal|" Executable"
argument_list|)
expr_stmt|;
case|case
literal|0177545
case|:
case|case
literal|0177555
case|:
name|error
argument_list|(
literal|" Archive"
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|magic
operator|&
literal|0100200
condition|)
name|error
argument_list|(
literal|" Non-ascii file"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|setdot
argument_list|()
expr_stmt|;
else|else
name|setall
argument_list|()
expr_stmt|;
if|if
condition|(
name|inopen
operator|&&
name|c
operator|==
literal|'r'
condition|)
name|undap1
operator|=
name|undap2
operator|=
name|dot
operator|+
literal|1
expr_stmt|;
name|rop2
argument_list|()
expr_stmt|;
name|rop3
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rop2
argument_list|()
end_macro

begin_block
block|{
name|deletenone
argument_list|()
expr_stmt|;
name|clrstats
argument_list|()
expr_stmt|;
name|ignore
argument_list|(
name|append
argument_list|(
name|getfile
argument_list|,
name|addr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rop3
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|iostats
argument_list|()
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'e'
condition|)
name|edited
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|wasalt
operator|||
name|firstpat
condition|)
block|{
specifier|register
name|line
modifier|*
name|addr
init|=
name|zero
operator|+
name|oldadot
decl_stmt|;
if|if
condition|(
name|addr
operator|>
name|dol
condition|)
name|addr
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|firstpat
condition|)
block|{
name|globp
operator|=
operator|(
operator|*
name|firstpat
operator|)
condition|?
name|firstpat
else|:
literal|"$"
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|firstpat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|>=
name|one
condition|)
block|{
if|if
condition|(
name|inopen
condition|)
name|dot
operator|=
name|addr
expr_stmt|;
name|markpr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|other
goto|;
block|}
else|else
name|other
label|:
if|if
condition|(
name|dol
operator|>
name|zero
condition|)
block|{
if|if
condition|(
name|inopen
condition|)
name|dot
operator|=
name|one
expr_stmt|;
name|markpr
argument_list|(
name|one
argument_list|)
expr_stmt|;
block|}
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|vcline
operator|=
literal|0
expr_stmt|;
name|vreplace
argument_list|(
literal|0
argument_list|,
name|LINES
argument_list|,
name|lineDOL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|laste
condition|)
block|{
name|laste
operator|=
literal|0
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Are these two really the same inode?  */
end_comment

begin_macro
name|samei
argument_list|(
argument|sp
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|stat
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
operator|||
name|sp
operator|->
name|st_dev
operator|!=
name|stb
operator|.
name|st_dev
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|sp
operator|->
name|st_ino
operator|==
name|stb
operator|.
name|st_ino
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Returns from edited() */
end_comment

begin_define
define|#
directive|define
name|EDF
value|0
end_define

begin_comment
comment|/* Edited file */
end_comment

begin_define
define|#
directive|define
name|NOTEDF
value|-1
end_define

begin_comment
comment|/* Not edited file */
end_comment

begin_define
define|#
directive|define
name|PARTBUF
value|1
end_define

begin_comment
comment|/* Write of partial buffer to Edited file */
end_comment

begin_comment
comment|/*  * Write a file.  */
end_comment

begin_macro
name|wop
argument_list|(
argument|dofname
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|dofname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if 1 call filename, else use savedfile */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|exclam
decl_stmt|,
name|nonexist
decl_stmt|;
name|line
modifier|*
name|saddr1
decl_stmt|,
modifier|*
name|saddr2
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|exclam
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dofname
condition|)
block|{
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'!'
condition|)
name|exclam
operator|++
operator|,
name|ignchar
argument_list|()
expr_stmt|;
name|ignore
argument_list|(
name|skipwh
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|peekchar
argument_list|()
operator|==
literal|'>'
condition|)
name|ignchar
argument_list|()
operator|,
name|c
operator|++
operator|,
name|ignore
argument_list|(
name|skipwh
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"Write forms are 'w' and 'w>>'"
argument_list|)
expr_stmt|;
name|filename
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saddr1
operator|=
name|addr1
expr_stmt|;
name|saddr2
operator|=
name|addr2
expr_stmt|;
name|addr1
operator|=
name|one
expr_stmt|;
name|addr2
operator|=
name|dol
expr_stmt|;
name|CP
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splitw
operator|++
expr_stmt|;
block|}
name|lprintf
argument_list|(
literal|"\"%s\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|nonexist
operator|=
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|exclam
operator|&&
operator|!
name|value
argument_list|(
name|WRITEANY
argument_list|)
condition|)
switch|switch
condition|(
name|edfile
argument_list|()
condition|)
block|{
case|case
name|NOTEDF
case|:
if|if
condition|(
name|nonexist
condition|)
break|break;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|samei
argument_list|(
operator|&
name|stbuf
argument_list|,
literal|"/dev/null"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|samei
argument_list|(
operator|&
name|stbuf
argument_list|,
literal|"/dev/tty"
argument_list|)
condition|)
break|break;
block|}
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
name|syserror
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|io
argument_list|)
condition|)
name|serror
argument_list|(
literal|" File exists| File exists - use \"w! %s\" to overwrite"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARTBUF
case|:
name|error
argument_list|(
literal|" Use \"w!\" to write partial buffer"
argument_list|)
expr_stmt|;
block|}
name|cre
label|:
comment|/* 		synctmp(); */
ifdef|#
directive|ifdef
name|V6
name|io
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
else|#
directive|else
name|io
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|io
operator|<
literal|0
condition|)
name|syserror
argument_list|()
expr_stmt|;
if|if
condition|(
name|hush
operator|==
literal|0
condition|)
if|if
condition|(
name|nonexist
condition|)
name|printf
argument_list|(
literal|" [New file]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
argument_list|(
name|WRITEANY
argument_list|)
operator|&&
name|edfile
argument_list|()
operator|!=
name|EDF
condition|)
name|printf
argument_list|(
literal|" [Existing file]"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|exclam
operator|||
name|value
argument_list|(
name|WRITEANY
argument_list|)
condition|)
goto|goto
name|cre
goto|;
name|syserror
argument_list|()
expr_stmt|;
block|}
name|lseek
argument_list|(
name|io
argument_list|,
literal|0l
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|putfile
argument_list|()
expr_stmt|;
name|ignore
argument_list|(
name|iostats
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|2
operator|&&
name|addr1
operator|==
name|one
operator|&&
name|addr2
operator|==
name|dol
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
condition|)
name|edited
operator|=
literal|1
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dofname
condition|)
block|{
name|addr1
operator|=
name|saddr1
expr_stmt|;
name|addr2
operator|=
name|saddr2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Is file the edited file?  * Work here is that it is not considered edited  * if this is a partial buffer, and distinguish  * all cases.  */
end_comment

begin_macro
name|edfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|edited
operator|||
operator|!
name|eq
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
condition|)
return|return
operator|(
name|NOTEDF
operator|)
return|;
return|return
operator|(
name|addr1
operator|==
name|one
operator|&&
name|addr2
operator|==
name|dol
condition|?
name|EDF
else|:
name|PARTBUF
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * First part of a shell escape,  * parse the line, expanding # and % and ! and printing if implied.  */
end_comment

begin_macro
name|unix0
argument_list|(
argument|warn
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|warn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|up
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
specifier|register
name|short
name|c
decl_stmt|;
name|char
name|printub
decl_stmt|,
name|puxb
index|[
name|UXBSIZE
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|printub
operator|=
literal|0
expr_stmt|;
name|CP
argument_list|(
name|puxb
argument_list|,
name|uxb
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|"Incomplete shell escape command@- use 'shell' to get a shell"
argument_list|)
expr_stmt|;
name|up
operator|=
name|uxb
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|any
argument_list|(
name|peekchar
argument_list|()
argument_list|,
literal|"%#!"
argument_list|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
default|default:
if|if
condition|(
name|up
operator|>=
operator|&
name|uxb
index|[
name|UXBSIZE
index|]
condition|)
block|{
name|tunix
label|:
name|uxb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Command too long"
argument_list|)
expr_stmt|;
block|}
operator|*
name|up
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|fp
operator|=
name|puxb
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
block|{
name|uxb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"No previous command@to substitute for !"
argument_list|)
expr_stmt|;
block|}
name|printub
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
block|{
if|if
condition|(
name|up
operator|>=
operator|&
name|uxb
index|[
name|UXBSIZE
index|]
condition|)
goto|goto
name|tunix
goto|;
operator|*
name|up
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
name|fp
operator|=
name|altfile
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
block|{
name|uxb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"No alternate filename@to substitute for #"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|uexp
goto|;
case|case
literal|'%'
case|:
name|fp
operator|=
name|savedfile
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
literal|0
condition|)
block|{
name|uxb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"No filename@to substitute for %%"
argument_list|)
expr_stmt|;
block|}
name|uexp
label|:
name|printub
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
block|{
if|if
condition|(
name|up
operator|>=
operator|&
name|uxb
index|[
name|UXBSIZE
index|]
condition|)
goto|goto
name|tunix
goto|;
operator|*
name|up
operator|++
operator|=
operator|*
name|fp
operator|++
operator||
name|QUOTE
expr_stmt|;
block|}
break|break;
block|}
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|'|'
operator|||
operator|!
name|endcmd
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|up
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|inopen
condition|)
name|resetflav
argument_list|()
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|ckaw
argument_list|()
expr_stmt|;
if|if
condition|(
name|warn
operator|&&
name|hush
operator|==
literal|0
operator|&&
name|chng
operator|&&
name|xchng
operator|!=
name|chng
operator|&&
name|value
argument_list|(
name|WARN
argument_list|)
operator|&&
name|dol
operator|>
name|zero
condition|)
block|{
name|xchng
operator|=
name|chng
expr_stmt|;
name|vnfl
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|mesg
argument_list|(
literal|"[No write]|[No write since last change]"
argument_list|)
argument_list|)
expr_stmt|;
name|noonl
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
name|warn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|printub
condition|)
block|{
if|if
condition|(
name|uxb
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous command@to repeat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|splitw
operator|++
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
name|vnfl
argument_list|()
expr_stmt|;
if|if
condition|(
name|hush
operator|==
literal|0
condition|)
name|lprintf
argument_list|(
literal|"!%s"
argument_list|,
name|uxb
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|vclreol
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|putnl
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Do the real work for execution of a shell escape.  * Mode is like the number passed to open system calls  * and indicates filtering.  If input is implied, newstdin  * must have been setup already.  */
end_comment

begin_macro
name|unixex
argument_list|(
argument|opt
argument_list|,
argument|up
argument_list|,
argument|newstdin
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|opt
decl_stmt|,
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newstdin
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pvec
index|[
literal|2
index|]
decl_stmt|,
name|f
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|f
operator|=
name|setty
argument_list|(
name|normf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
literal|1
operator|)
operator|&&
name|pipe
argument_list|(
name|pvec
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Newstdin should be io so it will be closed */
if|if
condition|(
name|inopen
condition|)
name|setty
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Can't make pipe for filter"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VFORK
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|&
literal|1
condition|)
block|{
name|close
argument_list|(
name|pvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|setrupt
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"No more processes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|&
literal|2
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|newstdin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|newstdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
literal|1
condition|)
block|{
name|close
argument_list|(
name|pvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
condition|)
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfile
condition|)
name|close
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMUNIX
name|close
argument_list|(
name|erfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|oldhup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|oldquit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruptible
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|svalue
argument_list|(
name|SHELL
argument_list|)
argument_list|,
literal|"sh"
argument_list|,
name|opt
argument_list|,
name|up
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No %s!\n"
argument_list|,
name|svalue
argument_list|(
name|SHELL
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
literal|1
condition|)
block|{
name|io
operator|=
name|pvec
index|[
literal|0
index|]
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newstdin
condition|)
name|close
argument_list|(
name|newstdin
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Wait for the command to complete.  * F is for restoration of tty mode if from open/visual.  * C flags suppression of printing.  */
end_comment

begin_macro
name|unixwt
argument_list|(
argument|c
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|waitfor
argument_list|()
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|setty
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inopen
operator|&&
name|c
operator|&&
name|hush
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|termreset
argument_list|()
expr_stmt|;
name|gettmode
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Setup a pipeline for the filtration implied by mode  * which is like a open number.  If input is required to  * the filter, then a child editor is created to write it.  * If output is catch it from io which is created by unixex.  */
end_comment

begin_expr_stmt
name|filter
argument_list|(
name|mode
argument_list|)
specifier|register
name|int
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|int
name|pvec
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
specifier|register
name|int
name|lines
init|=
name|lineDOL
argument_list|()
decl_stmt|;
name|mode
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|2
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pvec
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't make pipe"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
name|io
operator|=
name|pvec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|setrupt
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No more processes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|setrupt
argument_list|()
expr_stmt|;
name|io
operator|=
name|pvec
index|[
literal|1
index|]
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putfile
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|io
operator|=
name|pvec
index|[
literal|0
index|]
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
block|}
name|f
operator|=
name|unixex
argument_list|(
literal|"-c"
argument_list|,
name|uxb
argument_list|,
operator|(
name|mode
operator|&
literal|2
operator|)
condition|?
name|pvec
index|[
literal|0
index|]
else|:
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|3
condition|)
block|{
name|delete
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|addr1
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
literal|1
condition|)
block|{
name|undap1
operator|=
name|undap2
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
name|ignore
argument_list|(
name|append
argument_list|(
name|getfile
argument_list|,
name|addr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
operator|-
literal|1
expr_stmt|;
name|unixwt
argument_list|(
operator|!
name|inopen
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|netchHAD
argument_list|(
name|lines
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set up to do a recover, getting io to be a pipe from  * the recover process.  */
end_comment

begin_macro
name|recover
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|pvec
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pvec
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|" Can't make pipe for recovery"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
name|io
operator|=
name|pvec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" Can't fork to execute recovery"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|EXRECOVER
argument_list|,
literal|"exrecover"
argument_list|,
name|svalue
argument_list|(
name|DIRECTORY
argument_list|)
argument_list|,
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" No recovery routine"
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pvec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Wait for the process (pid an external) to complete.  */
end_comment

begin_macro
name|waitfor
argument_list|()
end_macro

begin_block
block|{
do|do
name|rpid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
do|while
condition|(
name|rpid
operator|!=
name|pid
operator|&&
name|rpid
operator|!=
operator|-
literal|1
condition|)
do|;
name|status
operator|=
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The end of a recover operation.  If the process  * exits non-zero, force not edited; otherwise force  * a write.  */
end_comment

begin_macro
name|revocer
argument_list|()
end_macro

begin_block
block|{
name|waitfor
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|rpid
operator|&&
name|status
operator|!=
literal|0
condition|)
name|edited
operator|=
literal|0
expr_stmt|;
else|else
name|change
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Extract the next line from the io stream.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextip
decl_stmt|;
end_decl_stmt

begin_macro
name|getfile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|short
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|fp
operator|=
name|nextip
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|ninbuf
operator|<
literal|0
condition|)
block|{
name|ninbuf
operator|=
name|read
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ninbuf
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lp
operator|!=
name|linebuf
condition|)
block|{
name|printf
argument_list|(
literal|" [Incomplete last line]"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|fp
operator|=
name|genbuf
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
index|]
condition|)
block|{
name|error
argument_list|(
literal|" Line too long"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|cntnull
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|&
name|QUOTE
condition|)
block|{
name|cntodd
operator|++
expr_stmt|;
name|c
operator|&=
name|TRIM
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
continue|continue;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|cntch
operator|+=
name|lp
operator|-
name|linebuf
expr_stmt|;
operator|*
operator|--
name|lp
operator|=
literal|0
expr_stmt|;
name|nextip
operator|=
name|fp
expr_stmt|;
name|cntln
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write a range onto the io stream.  */
end_comment

begin_macro
name|putfile
argument_list|()
end_macro

begin_block
block|{
name|line
modifier|*
name|a1
decl_stmt|;
specifier|register
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nib
decl_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|clrstats
argument_list|()
expr_stmt|;
name|cntln
operator|=
name|addr2
operator|-
name|a1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cntln
operator|==
literal|0
condition|)
return|return;
name|nib
operator|=
name|BUFSIZ
expr_stmt|;
name|fp
operator|=
name|genbuf
expr_stmt|;
do|do
block|{
name|getline
argument_list|(
operator|*
name|a1
operator|++
argument_list|)
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|nib
operator|<
literal|0
condition|)
block|{
name|nib
operator|=
name|fp
operator|-
name|genbuf
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|nib
argument_list|)
operator|!=
name|nib
condition|)
block|{
name|wrerror
argument_list|()
expr_stmt|;
block|}
name|cntch
operator|+=
name|nib
expr_stmt|;
name|nib
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|genbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fp
operator|++
operator|=
operator|*
name|lp
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|a1
operator|<=
name|addr2
condition|)
do|;
name|nib
operator|=
name|fp
operator|-
name|genbuf
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|nib
argument_list|)
operator|!=
name|nib
condition|)
block|{
name|wrerror
argument_list|()
expr_stmt|;
block|}
name|cntch
operator|+=
name|nib
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * A write error has occurred;  if the file being written was  * the edited file then we consider it to have changed since it is  * now likely scrambled.  */
end_comment

begin_macro
name|wrerror
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|eq
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
operator|&&
name|edited
condition|)
name|change
argument_list|()
expr_stmt|;
name|syserror
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Source command, handles nested sources.  * Traps errors since it mungs unit 0 during the source.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|slevel
decl_stmt|;
end_decl_stmt

begin_macro
name|source
argument_list|(
argument|fil
argument_list|,
argument|okfail
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|okfail
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|osetexit
decl_stmt|;
specifier|register
name|int
name|saveinp
decl_stmt|,
name|ointty
decl_stmt|,
name|oerrno
decl_stmt|;
name|int
name|oprompt
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|saveinp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveinp
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Too many nested sources"
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|fil
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
name|dup
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
if|if
condition|(
operator|!
name|okfail
condition|)
name|filioerr
argument_list|(
name|fil
argument_list|)
expr_stmt|;
return|return;
block|}
name|slevel
operator|++
expr_stmt|;
name|ointty
operator|=
name|intty
expr_stmt|;
name|intty
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|oprompt
operator|=
name|value
argument_list|(
name|PROMPT
argument_list|)
expr_stmt|;
name|value
argument_list|(
name|PROMPT
argument_list|)
operator|&=
name|intty
expr_stmt|;
name|getexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|setrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slevel
operator|>
literal|1
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|slevel
operator|--
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
name|intty
operator|=
name|ointty
expr_stmt|;
name|value
argument_list|(
name|PROMPT
argument_list|)
operator|=
name|oprompt
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|saveinp
argument_list|)
expr_stmt|;
name|slevel
operator|--
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear io statistics before a read or write.  */
end_comment

begin_macro
name|clrstats
argument_list|()
end_macro

begin_block
block|{
name|ninbuf
operator|=
literal|0
expr_stmt|;
name|cntch
operator|=
literal|0
expr_stmt|;
name|cntln
operator|=
literal|0
expr_stmt|;
name|cntnull
operator|=
literal|0
expr_stmt|;
name|cntodd
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Io is finished, close the unit and print statistics.  */
end_comment

begin_macro
name|iostats
argument_list|()
end_macro

begin_block
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hush
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|TERSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|" %d/%D"
argument_list|,
name|cntln
argument_list|,
name|cntch
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %d line%s, %D character%s"
argument_list|,
name|cntln
argument_list|,
name|plural
argument_list|(
operator|(
name|long
operator|)
name|cntln
argument_list|)
argument_list|,
name|cntch
argument_list|,
name|plural
argument_list|(
name|cntch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntnull
operator|||
name|cntodd
condition|)
block|{
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntnull
condition|)
block|{
name|printf
argument_list|(
literal|"%D null"
argument_list|,
name|cntnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntodd
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cntodd
condition|)
name|printf
argument_list|(
literal|"%D non-ASCII"
argument_list|,
name|cntodd
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|noonl
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|cntnull
operator|!=
literal|0
operator|||
name|cntodd
operator|!=
literal|0
operator|)
return|;
block|}
end_block

end_unit

